[ { "title": "Member 모듈 리펙토링 - 1단계", "url": "/posts/member-module-2/", "categories": "Member Module, Refactoring, 결과", "tags": "멋쟁이 사자처럼, Spring Security, Member, 인증/인가, Refactoring", "date": "2025-02-17 14:00:00 +0900", "snippet": "리펙토링 1단계   :   -리펙토링 2단계   :   SocialAccount Entity 변경⭕ SocialAccount ⇨ OAuthProvider로 Entity 변경 SocialAccount Code 보기 package com.msa.member.domain.member.auth.entity; im...", "content": "리펙토링 1단계   :   -리펙토링 2단계   :   SocialAccount Entity 변경⭕ SocialAccount ⇨ OAuthProvider로 Entity 변경 SocialAccount Code 보기 package com.msa.member.domain.member.auth.entity; import com.msa.member.domain.member.member.entity.Member; import com.msa.member.domain.member.member.enums.ProviderType; import jakarta.persistence.*; import lombok.*; import java.time.LocalDateTime; @Entity @Setter @Getter @AllArgsConstructor @NoArgsConstructor @Builder @EqualsAndHashCode(onlyExplicitlyIncluded = true) public class SocialAccount { @Id private Long id; @MapsId @OneToOne @JoinColumn(name = \"id\") @EqualsAndHashCode.Include private Member member; // Kakao @Column(unique = true, length = 50) private String kakaoProviderId; @Column(unique = true, length = 50) private String kakaoEmail; @Column(nullable = false) @Builder.Default private boolean kakaoActive = false; @Setter(AccessLevel.PRIVATE) private LocalDateTime kakaoCreateDate; @Setter(AccessLevel.PRIVATE) private LocalDateTime kakaoModifyDate; // Google @Column(length = 50, unique = true) private String googleProviderId; @Column(unique = true, length = 50) private String googleEmail; @Column(nullable = false) @Builder.Default private boolean googleActive = false; @Setter(AccessLevel.PRIVATE) private LocalDateTime googleCreateDate; @Setter(AccessLevel.PRIVATE) private LocalDateTime googleModifyDate; // Github @Column(length = 50, unique = true) private String githubProviderId; @Column(unique = true, length = 50) private String githubEmail; @Column(nullable = false) @Builder.Default private boolean githubActive = false; @Setter(AccessLevel.PRIVATE) private LocalDateTime githubCreateDate; @Setter(AccessLevel.PRIVATE) private LocalDateTime githubModifyDate; // Naver @Column(length = 150, unique = true) private String naverProviderId; @Column(unique = true, length = 50) private String naverEmail; @Column(nullable = false) @Builder.Default private boolean naverActive = false; @Setter(AccessLevel.PRIVATE) private LocalDateTime naverCreateDate; @Setter(AccessLevel.PRIVATE) private LocalDateTime naverModifyDate; // 공통 public boolean hasSocialAccount(ProviderType provider) { if (provider == null) { return false; } return switch (provider) { case ProviderType.KAKAO -&gt; kakaoActive; case ProviderType.GOOGLE -&gt; googleActive; case ProviderType.GITHUB -&gt; githubActive; case ProviderType.NAVER -&gt; naverActive; default -&gt; false; }; } // Kakao public void updateKakaoInfo(String providerId, String email, boolean active) { kakaoProviderId = providerId; kakaoEmail = email; kakaoActive = active; kakaoModifyDate = LocalDateTime.now(); } public void connectKakao(String providerId, String email) { if (kakaoCreateDate == null) { kakaoCreateDate = LocalDateTime.now(); } updateKakaoInfo(providerId, email, true); } public void disconnectKakao() { updateKakaoInfo(null, null, false); } // Google public void updateGoogleInfo(String providerId, String email, boolean active) { googleProviderId = providerId; googleEmail = email; googleActive = active; googleModifyDate = LocalDateTime.now(); } public void connectGoogle(String providerId, String email) { if (googleCreateDate == null) { googleCreateDate = LocalDateTime.now(); } updateGoogleInfo(providerId, email, true); } public void disconnectGoogle() { updateGoogleInfo(null, null, false); } // Github public void updateGithubInfo(String providerId, String email, boolean active) { githubProviderId = providerId; githubEmail = email; githubActive = active; githubModifyDate = LocalDateTime.now(); } public void connectGithub(String providerId, String email) { if (githubCreateDate == null) { githubCreateDate = LocalDateTime.now(); } updateGithubInfo(providerId, email, true); } public void disconnectGithub() { updateGithubInfo(null, null, false); } // Naver public void updateNaverInfo(String providerId, String email, boolean active) { naverProviderId = providerId; naverEmail = email; naverActive = active; naverModifyDate = LocalDateTime.now(); } public void connectNaver(String providerId, String email) { if (naverCreateDate == null) { naverCreateDate = LocalDateTime.now(); } updateNaverInfo(providerId, email, true); } public void disconnectNaver() { updateNaverInfo(null, null, false); } } 👉 Entity Layer🔆 BaseEntity BaseEntity 다른 모든 Entity에서 자주 사용되는 필드를 뽑아 놓은 추상클래스 Code 보기 import jakarta.persistence.*; import lombok.*; import lombok.experimental.SuperBuilder; import org.springframework.data.annotation.CreatedDate; import org.springframework.data.annotation.LastModifiedDate; import org.springframework.data.jpa.domain.support.AuditingEntityListener; import java.time.LocalDateTime; import static jakarta.persistence.GenerationType.IDENTITY; import static lombok.AccessLevel.PROTECTED; @MappedSuperclass // 상속 관계 매핑용 부모 클래스 @NoArgsConstructor(access = PROTECTED) // 외부에서 생성 제한 @AllArgsConstructor(access = PROTECTED) // 자식 클래스에서만 모든 필드 생성자 사용 가능 @Getter @SuperBuilder // 자식 클래스에서 빌더 패턴 사용 가능 @EntityListeners(AuditingEntityListener.class) // JPA Auditing 기능 활성화 @EqualsAndHashCode(onlyExplicitlyIncluded = true) // ID 필드만 equals, hashCode 비교 public abstract class BaseEntity { // abstract로 선언하여 직접 생성 방지 @Id @GeneratedValue(strategy = IDENTITY) @EqualsAndHashCode.Include // equals, hashCode에 이 필드만 포함 private Long id; @CreatedDate @Column(updatable = false) // 생성일은 수정 불가 private LocalDateTime createDate; @LastModifiedDate // 엔티티 수정시 자동 업데이트 private LocalDateTime modifiedDate; } ID 생성, 시간 관리 등 공통 관심사 분리 JPA 최적화 (ID 필드만 비교) 불변성 보장 (Setter 없음) 생성자 제한으로 안전성 보장 자동 감사(Audit) 기능 🔆 BaseOAuthProvider BaseOAuthProvider OAuth2 Provider들의 공통 동작 정의 (추상 클래스) 즉, 아래의 소셜 로그인 제공자별 Embedded 클래스의 공통 로직을 추출한 추상 클래스이다. connect(), disconnect() 등 공통 로직 제공 [GoF] Template Method 자식클래스에서 추상 메서드를 각 소셜 로그인 제공자별로 각각 구현한다. Code 보기 package com.msa.member.domain.member.auth.entity; import jakarta.persistence.MappedSuperclass; import lombok.AccessLevel; import lombok.Getter; import lombok.NoArgsConstructor; import lombok.experimental.SuperBuilder; import java.time.LocalDateTime; @MappedSuperclass @Getter @SuperBuilder @NoArgsConstructor(access = AccessLevel.PROTECTED) public abstract class BaseOAuthProvider { protected abstract String getProviderId(); protected abstract void setConnected(boolean connected); protected abstract void setConnectedDate(LocalDateTime connectedDate); protected abstract void setModifiedDate(LocalDateTime modifiedDate); protected void connect() { setConnected(true); setConnectedDate(LocalDateTime.now()); setModifiedDate(LocalDateTime.now()); } protected void disconnect() { setConnected(false); setModifiedDate(LocalDateTime.now()); } protected void validate() { if (getProviderId() == null || getProviderId().isBlank()) { throw new IllegalArgumentException(\"Provider ID가 유효하지 않습니다.\"); } } } 🔆 KakaoProvider, GoogleProvider, NaverProvider, GithubProvider KakaoProvider 각각의 클래스는 OAuthProvider의 Embedded 클래스이다. 즉, DB에서 각 클래스의 필드들은 OAuthProvider의 속성으로 들어간다. setConnected(), setConnectedDate(), setModifiedDate() 추상메서드 구현 [GoF] Template Method 패턴을 사용한 이유는 모든 제공자에서 공통으로 사용되는 connect(), disconnect(), validate()를 공통 로직으로 사용하기 위해서이다. 필요한 요소들을 미리 가져다 쓰고 메서드 내부 구현은 자식 클래스에게 맡기는 것이다. Code 보기 package com.msa.member.domain.member.auth.entity; import jakarta.persistence.Column; import jakarta.persistence.Embeddable; import lombok.*; import lombok.experimental.SuperBuilder; import java.time.LocalDateTime; @Embeddable @Getter @SuperBuilder @AllArgsConstructor(access = AccessLevel.PROTECTED) @NoArgsConstructor(access = AccessLevel.PROTECTED) @EqualsAndHashCode(of = \"providerId\", callSuper = false) public class KakaoProvider extends BaseOAuthProvider { @Column(name = \"kakao_provider_id\", length = 50) private String providerId; @Column(name = \"kakao_email\", length = 50) private String email; @Column(name = \"kakao_connected\") private boolean connected = false; @Column(name = \"kakao_connected_date\") private LocalDateTime connectedDate; @Column(name = \"kakao_modified_date\") private LocalDateTime modifiedDate; public void connect(String providerId, String email) { this.providerId = providerId; this.email = email; super.connect(); } @Override protected void setConnected(boolean connected) { this.connected = connected; } @Override protected void setConnectedDate(LocalDateTime connectedDate) { this.connectedDate = connectedDate; } @Override protected void setModifiedDate(LocalDateTime modifiedDate) { this.modifiedDate = modifiedDate; } } 이 클래스들의 목적은 소셜 로그인 정보를 담고 있는 것이다. 🔆 OAuthProvider OAuthProvider 모든 소셜 로그인 제공자들을 통합 관리하는 Entity이다. 즉, 위의 각 제공자별 Embedded 클래스를 모두 관리한다. Embedded된 Provider들의 추가/제거는 여기서 모두 처리하여 통합 관리한다. Member 엔티티와는 1대1 관계이다. Embedded 클래스에서 직접 Unique Key를 지정할 수 없다. 바깥 클래스에서 지정 지정했다. Code 보기 package com.msa.member.domain.member.auth.entity; import com.msa.member.domain.member.member.dto.OAuthProviderStatus; import com.msa.member.domain.member.member.entity.Member; import com.msa.member.domain.member.member.enums.ProviderType; import com.msa.member.global.jpa.BaseEntity; import jakarta.persistence.*; import lombok.*; import lombok.experimental.SuperBuilder; import java.util.HashMap; import java.util.Map; @Entity @Getter @NoArgsConstructor(access = AccessLevel.PROTECTED) @AllArgsConstructor(access = AccessLevel.PROTECTED) @SuperBuilder @EqualsAndHashCode(onlyExplicitlyIncluded = true) @Table(name = \"oauth_providers\", uniqueConstraints = { @UniqueConstraint(columnNames = \"kakao_provider_id\"), @UniqueConstraint(columnNames = \"google_provider_id\"), @UniqueConstraint(columnNames = \"naver_provider_id\"), @UniqueConstraint(columnNames = \"github_provider_id\") }) public class OAuthProvider extends BaseEntity { @MapsId @OneToOne @JoinColumn(name = \"member_id\") @EqualsAndHashCode.Include private Member member; // 소셜 계정 정보 @Embedded private KakaoProvider kakao; public void addKakaoProvider(String providerId, String email) { KakaoProvider kakaoProvider = KakaoProvider.builder() .providerId(providerId) .email(email) .build(); kakaoProvider.connect(); kakao = kakaoProvider; } public void removeKakaoProvider() { if (kakao != null) { kakao.disconnect(); kakao = null; } } @Embedded private GoogleProvider google; public void addGoogleProvider(String providerId, String email) { GoogleProvider googleProvider = GoogleProvider.builder() .providerId(providerId) .email(email) .build(); googleProvider.connect(); google = googleProvider; } public void removeGoogleProvider() { if (google != null) { google.disconnect(); google = null; } } @Embedded private NaverProvider naver; public void addNaverProvider(String providerId, String email) { NaverProvider naverProvider = NaverProvider.builder() .providerId(providerId) .email(email) .build(); naverProvider.connect(); naver = naverProvider; } public void removeNaverProvider() { if (naver != null) { naver.disconnect(); naver = null; } } @Embedded private GithubProvider github; public void addGithubProvider(String providerId, String email) { GithubProvider githubProvider = GithubProvider.builder() .providerId(providerId) .email(email) .build(); githubProvider.connect(); github = githubProvider; } public void removeGithubProvider() { if (github != null) { github.disconnect(); github = null; } } @Builder private OAuthProvider(Member member) { this.member = member; } public boolean isConnected(ProviderType type) { return switch (type) { case KAKAO -&gt; kakao != null &amp;&amp; kakao.isConnected(); case GOOGLE -&gt; google != null &amp;&amp; google.isConnected(); case NAVER -&gt; naver != null &amp;&amp; naver.isConnected(); case GITHUB -&gt; github != null &amp;&amp; github.isConnected(); case SELF -&gt; false; }; } public Map&lt;ProviderType, OAuthProviderStatus&gt; getOAuthProviderStatuses() { Map&lt;ProviderType, OAuthProviderStatus&gt; statuses = new HashMap&lt;&gt;(); statuses.put(ProviderType.KAKAO, OAuthProviderStatus.builder() .createDate(kakao.getConnectedDate()) .email(kakao.getEmail()) .active(kakao.isConnected()) .build()); statuses.put(ProviderType.GOOGLE, OAuthProviderStatus.builder() .createDate(google.getConnectedDate()) .email(google.getEmail()) .active(google.isConnected()) .build()); statuses.put(ProviderType.GITHUB, OAuthProviderStatus.builder() .createDate(github.getConnectedDate()) .email(github.getEmail()) .active(github.isConnected()) .build()); statuses.put(ProviderType.NAVER, OAuthProviderStatus.builder() .createDate(naver.getConnectedDate()) .email(naver.getEmail()) .active(naver.isConnected()) .build()); return statuses; } } 🔆 Member Member 각 Code 보기 package com.msa.member.domain.member.member.entity; import com.fasterxml.jackson.annotation.JsonIgnore; import com.msa.member.domain.member.auth.entity.OAuthProvider; import com.msa.member.domain.member.auth.entity.SocialAccount; import com.msa.member.domain.member.member.dto.MemberUpdateRequest; import com.msa.member.domain.member.member.dto.OAuthProviderStatus; import com.msa.member.domain.member.member.enums.Gender; import com.msa.member.domain.member.member.enums.ProviderType; import com.msa.member.domain.member.member.enums.MemberRole; import com.msa.member.domain.member.member.enums.MemberStatus; import com.msa.member.global.exceptions.ErrorCode; import com.msa.member.global.exceptions.ServiceException; import com.msa.member.global.jpa.BaseEntity; import jakarta.persistence.*; import lombok.*; import lombok.experimental.SuperBuilder; import org.hibernate.annotations.DynamicInsert; import org.springframework.security.core.GrantedAuthority; import org.springframework.security.core.authority.SimpleGrantedAuthority; import java.time.LocalDate; import java.util.*; import static jakarta.persistence.CascadeType.ALL; @Entity @Setter @Getter @AllArgsConstructor @NoArgsConstructor @SuperBuilder @DynamicInsert public class Member extends BaseEntity { @Column(unique = true, nullable = false, length = 30) private String email; @JsonIgnore private String password; public boolean hasPassword() { return password != null &amp;&amp; !password.isEmpty(); } @Column(nullable = false) private String nickname; // 닉네임 private LocalDate birthDate; private String address; // 주소 @Enumerated(EnumType.STRING) @Column(length = 1) private Gender gender; // 성별 @Column(length = 20) private String phoneNumber; // 전화번호 @Column(columnDefinition = \"VARCHAR(255) DEFAULT 'default.png'\") private String profileImageUrl = \"default.png\"; // 프로필 사진 경로 @Column(nullable = false, columnDefinition = \"BOOLEAN DEFAULT TRUE\") private boolean marketingAgree; // 마케팅 수신여부 @Enumerated(EnumType.STRING) @Column(nullable = false, columnDefinition = \"ENUM('ACTIVE', 'INACTIVE', 'BANNED', 'WITHDRAWN') DEFAULT 'ACTIVE'\") private MemberStatus status; // 회원 상태 public void deactivate() { status = MemberStatus.WITHDRAWN; } public void restore() { status = MemberStatus.ACTIVE; } @Enumerated(EnumType.STRING) @Column(nullable = false, columnDefinition = \"ENUM('ROLE_USER', 'ROLE_ADMIN') DEFAULT 'ROLE_USER'\") private MemberRole role = MemberRole.ROLE_USER; // 권한 (관리자, 사용자) public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() { if (this.role != null) { return Collections.singletonList(new SimpleGrantedAuthority(this.role.name())); } else { return Collections.singletonList(new SimpleGrantedAuthority(MemberRole.ROLE_USER.name())); } } @JsonIgnore @Column(unique = true, length = 50) private String apiKey; @Enumerated(EnumType.STRING) @Column(nullable = false, columnDefinition = \"VARCHAR(50) DEFAULT 'SELF'\") private ProviderType loginType = ProviderType.SELF; // 현재 로그인 방식 // 1대1 관계 설정 @JsonIgnore @OneToOne(mappedBy = \"member\", cascade = ALL, orphanRemoval = true) private OAuthProvider oauthProvider; public OAuthProvider getOAuthProviderOrCreate() { if (oauthProvider == null) { oauthProvider = OAuthProvider.builder() .member(this) .build(); } return oauthProvider; } public boolean hasOAuthProvider(ProviderType type) { return oauthProvider != null &amp;&amp; oauthProvider.isConnected(type); } public int getConnectedOAuthCount() { if (oauthProvider == null) return 0; int count = 0; if (oauthProvider.isConnected(ProviderType.KAKAO)) count++; if (oauthProvider.isConnected(ProviderType.GOOGLE)) count++; if (oauthProvider.isConnected(ProviderType.NAVER)) count++; if (oauthProvider.isConnected(ProviderType.GITHUB)) count++; return count; } public Map&lt;ProviderType, OAuthProviderStatus&gt; getOAuthProviderStatuses() { if (oauthProvider == null) { return new HashMap&lt;&gt;(); } return oauthProvider.getOAuthProviderStatuses(); } @JsonIgnore @OneToOne(mappedBy = \"member\", cascade = ALL, orphanRemoval = true) private SocialAccount socialAccount; public SocialAccount getSocialAccountOrCreate() { if (socialAccount == null) { socialAccount = SocialAccount.builder() .member(this) .build(); } return socialAccount; } public boolean hasSocialAccount(ProviderType provider) { return socialAccount != null &amp;&amp; socialAccount.hasSocialAccount(provider); } public int getConnectedSocialCount() { if (socialAccount == null) return 0; int count = 0; if (socialAccount.isKakaoActive()) count++; if (socialAccount.isGoogleActive()) count++; if (socialAccount.isNaverActive()) count++; if (socialAccount.isGithubActive()) count++; return count; } public void disconnectSocialAccount(ProviderType provider) { if (socialAccount == null) { throw new ServiceException(ErrorCode.NOT_CONNECTED_SOCIAL_ACCOUNT); } switch (provider) { case ProviderType.KAKAO -&gt; socialAccount.disconnectKakao(); case ProviderType.GOOGLE -&gt; socialAccount.disconnectGoogle(); case ProviderType.GITHUB -&gt; socialAccount.disconnectGithub(); case ProviderType.NAVER -&gt; socialAccount.disconnectNaver(); default -&gt; throw new ServiceException(ErrorCode.DISCONNECT_FAIL); } } public Map&lt;ProviderType, OAuthProviderStatus&gt; getSocialAccountStatuses() { Map&lt;ProviderType, OAuthProviderStatus&gt; statuses = new HashMap&lt;&gt;(); if (socialAccount != null) { // Kakao statuses.put(ProviderType.KAKAO, OAuthProviderStatus.builder() .createDate(socialAccount.getKakaoCreateDate()) .email(socialAccount.getKakaoEmail()) .active(socialAccount.isKakaoActive()) .build()); // Google statuses.put(ProviderType.GOOGLE, OAuthProviderStatus.builder() .createDate(socialAccount.getGoogleCreateDate()) .email(socialAccount.getGoogleEmail()) .active(socialAccount.isGoogleActive()) .build()); // Github statuses.put(ProviderType.GITHUB, OAuthProviderStatus.builder() .createDate(socialAccount.getGithubCreateDate()) .email(socialAccount.getGithubEmail()) .active(socialAccount.isGithubActive()) .build()); // Naver statuses.put(ProviderType.NAVER, OAuthProviderStatus.builder() .createDate(socialAccount.getNaverCreateDate()) .email(socialAccount.getNaverEmail()) .active(socialAccount.isNaverActive()) .build()); } return statuses; } // 1:N 관계 설정 // Entity 메서드 public Member(String email, String nickname, String profileImageUrl, MemberRole role) { this.email = email; this.nickname = nickname; this.profileImageUrl = profileImageUrl; this.role = role; } public void updateInfo(MemberUpdateRequest request) { gender = request.getGender(); nickname = request.getNickname(); marketingAgree = request.isMkAlarm(); birthDate = request.getBirthday(); address = request.getLocation(); phoneNumber = request.getPhoneNumber(); } } s 👉 Strategy Layer🔆 OAuthProviderStrategy OAuthProviderStrategy 각각의 소셜 로그인 제공자별 동작을 정의하는 인터페이스 ProviderType을 반환 해당 ProviderType과 ProviderId에 해당하는 회원 찾기 OAuthProvider의 각각의 Provider의 연결/해제를 동작?? Code 보기 package com.msa.member.domain.member.auth.strategy; import com.msa.member.domain.member.member.entity.Member; import com.msa.member.domain.member.member.enums.ProviderType; public interface OAuthProviderStrategy { ProviderType getProviderType(); Member findByProviderId(String providerId); void connect(Member member, String providerId, String email); void disconnect(Member member); } 🔆 KakaoProviderStrategy, GoogleProviderStrategy 등 KakaoProviderStrategy 인터페이스를 구현하여 실질적인 연결/해제를 구현한다. MemberRepository를 사용하여 해당하는 Member 엔티티를 가져온다. Code 보기 package com.msa.member.domain.member.auth.strategy; import com.msa.member.domain.member.auth.entity.OAuthProvider; import com.msa.member.domain.member.member.entity.Member; import com.msa.member.domain.member.member.enums.ProviderType; import com.msa.member.domain.member.member.repository.MemberRepository; import lombok.RequiredArgsConstructor; import org.springframework.stereotype.Component; @Component @RequiredArgsConstructor public class KakaoProviderStrategy implements OAuthProviderStrategy { private final MemberRepository memberRepository; @Override public ProviderType getProviderType() { return ProviderType.KAKAO; } @Override public Member findByProviderId(String providerId) { return memberRepository.findByKakaoProviderId(providerId).orElse(null); } @Override public void connect(Member member, String providerId, String email) { OAuthProvider oAuthProvider = member.getOAuthProviderOrCreate(); oAuthProvider.addKakaoProvider(providerId, email); } @Override public void disconnect(Member member) { OAuthProvider oAuthProvider = member.getOAuthProviderOrCreate(); oAuthProvider.removeKakaoProvider(); } } 👉 Service Layer🔆 OAuthService OAuthService Strategy 패턴을 활용한 OAuth 처리 서비스 ProviderType에 따라 적절한 Strategy를 선택하여 처리한다. Code 보기 package com.msa.member.domain.member.auth.service; import com.msa.member.domain.member.auth.entity.SocialAccount; import com.msa.member.domain.member.auth.strategy.*; import com.msa.member.domain.member.member.entity.Member; import com.msa.member.domain.member.member.enums.ProviderType; import com.msa.member.global.exceptions.ErrorCode; import com.msa.member.global.exceptions.ServiceException; import org.springframework.stereotype.Service; import org.springframework.transaction.annotation.Transactional; import java.util.List; import java.util.Map; import java.util.stream.Collectors; @Service @Transactional(readOnly = true) public class OAuthService { private final Map&lt;ProviderType, OAuthProviderStrategy&gt; strategies; public OAuthService(List&lt;OAuthProviderStrategy&gt; providerStrategies) { this.strategies = providerStrategies.stream() .collect(Collectors.toMap( OAuthProviderStrategy::getProviderType, strategy -&gt; strategy )); } public void connectProvider(Member member, ProviderType type, String providerId, String email) { OAuthProviderStrategy strategy = strategies.get(type); if (strategy == null) { throw new ServiceException(ErrorCode.INVALID_LOGIN_TYPE); } strategy.connect(member, providerId, email); } public void disconnectProvider(Member member, ProviderType type) { OAuthProviderStrategy strategy = strategies.get(type); if (strategy == null) { throw new ServiceException(ErrorCode.INVALID_LOGIN_TYPE); } strategy.disconnect(member); } public Member findByProviderId(ProviderType type, String providerId) { OAuthProviderStrategy strategy = strategies.get(type); if (strategy == null) { throw new ServiceException(ErrorCode.INVALID_LOGIN_TYPE); } return strategy.findByProviderId(providerId); } } s 🔆 AuthService AuthService OAuthService의 상위 서비스로 인증 관련 로직을 처리한다. 회원가입, 소셜 로그인, Token 생성 등 Code 보기 package com.msa.member.domain.member.auth.service; import com.msa.member.domain.member.auth.dto.EmailInfo; import com.msa.member.domain.member.auth.dto.FindEmailsResponse; import com.msa.member.domain.member.auth.entity.SocialAccount; import com.msa.member.domain.member.member.entity.Member; import com.msa.member.domain.member.member.enums.ProviderType; import com.msa.member.domain.member.member.enums.MemberRole; import com.msa.member.domain.member.member.enums.MemberStatus; import com.msa.member.domain.member.member.repository.MemberRepository; import com.msa.member.global.exceptions.ErrorCode; import com.msa.member.global.exceptions.ServiceException; import com.msa.member.standard.util.Ut; import lombok.RequiredArgsConstructor; import org.springframework.security.crypto.password.PasswordEncoder; import org.springframework.stereotype.Service; import org.springframework.transaction.annotation.Transactional; import java.util.List; import java.util.Map; import java.util.Optional; import java.util.UUID; @Transactional(readOnly = true) @Service @RequiredArgsConstructor public class AuthService { private final AuthTokenService authTokenService; private final OAuthService oAuthService; private final PasswordEncoder passwordEncoder; private final MemberRepository memberRepository; @Transactional public Member signup( String email, String password, String nickname, ProviderType loginType, String providerId, String providerEmail, String profileImageUrl ) { _validateEmailAndPassword(email, password, loginType); Optional&lt;Member&gt; existingMember = memberRepository.findByEmail(email); if (existingMember.isPresent()) { throw new ServiceException(ErrorCode.DUPLICATE_EMAIL); } Member member = Member.builder() .email(email) .password( loginType.equals(ProviderType.SELF) ? passwordEncoder.encode(password) : null ) .nickname(nickname) .loginType(loginType) .profileImageUrl(profileImageUrl) .apiKey(UUID.randomUUID().toString()) .role(MemberRole.ROLE_USER) .status(MemberStatus.ACTIVE) .build(); if (providerId != null) { oAuthService.connectProvider(member, loginType, providerId, providerEmail); } return memberRepository.save(member); } // @Transactional // public Member signup( // String email, String password, String nickname, // ProviderType loginType, String providerId, String providerEmail, String profileImageUrl // ) { // _validateEmailAndPassword(email, password, loginType); // // Optional&lt;Member&gt; existingMember = memberRepository.findByEmail(email); // if (existingMember.isPresent()) { // throw new ServiceException(ErrorCode.DUPLICATE_EMAIL); // } // // Member member = Member.builder() // .email(email) // .password( // loginType.equals(ProviderType.SELF) ? passwordEncoder.encode(password) : null // ) // .nickname(nickname) // .loginType(loginType) // .profileImageUrl(profileImageUrl) // .apiKey(UUID.randomUUID().toString()) // .role(MemberRole.ROLE_USER) // .status(MemberStatus.ACTIVE) // .build(); // // if (providerId != null) { // _connectProviderToMember(member, loginType, providerId, providerEmail); // } // // return memberRepository.save(member); // } public Optional&lt;Member&gt; findByEmail(String email) { return memberRepository.findByEmail(email); } public Optional&lt;Member&gt; findByApiKey(String apiKey) { return memberRepository.findByApiKey(apiKey); } public String genAccessToken(Member member) { return authTokenService.genAccessToken(member); } public String genAuthToken(Member member) { return member.getApiKey() + \" \" + genAccessToken(member); } public Member getMemberFromAccessToken(String accessToken) { Map&lt;String, Object&gt; payload = authTokenService.payload(accessToken); if (payload == null) { return null; } long id = (long) payload.get(\"id\"); String email = (String) payload.get(\"email\"); String nickname = (String) payload.get(\"nickname\"); String profileImageUrl = (String) payload.get(\"profileImageUrl\"); String role = (String) payload.get(\"role\"); return new Member(id, email, nickname, profileImageUrl, MemberRole.valueOf(role)); } public FindEmailsResponse findEmailsByPhoneNumber(String phoneNumber) { List&lt;Member&gt; members = memberRepository.findAllByPhoneNumber(phoneNumber); if (members.isEmpty()) { throw new ServiceException(ErrorCode.INVALID_PHONE_NUMBER); } List&lt;EmailInfo&gt; emailInfos = members.stream() .map(member -&gt; new EmailInfo( Ut.str.maskEmail(member.getEmail()), member.getCreateDate() )) .toList(); return new FindEmailsResponse(emailInfos); } @Transactional public Member handleSocialLogin( String email, String nickname, ProviderType loginType, String profilePath, String providerId ) { Member connectedMember = oAuthService.findByProviderId(loginType, providerId); if (connectedMember != null) { connectedMember.setLoginType(loginType); return connectedMember; // 연결된 계정이 있다면 그 계정으로 로그인 } Optional&lt;Member&gt; existingMember = findByEmail(email); // 이메일이 사용중인지 확인 if (existingMember.isPresent()) { Member member = existingMember.get(); oAuthService.connectProvider(member, loginType, providerId, email); // 기존 계정에 소셜 계정 연결 return member; } return signup(email, null, nickname, loginType, providerId, email, profilePath); } // @Transactional // public Member handleSocialLogin( // String email, String nickname, // ProviderType loginType, String profilePath, String providerId // ) { // Member connectedMember = _findMemberByProviderId(loginType, providerId); // if (connectedMember != null) { // connectedMember.setLoginType(loginType); // return connectedMember; // 연결된 계정이 있다면 그 계정으로 로그인 // } // // Optional&lt;Member&gt; existingMember = findByEmail(email); // 이메일이 사용중인지 확인 // if (existingMember.isPresent()) { // Member member = existingMember.get(); // _connectProviderToMember(member, loginType, providerId, email); // 기존 계정에 소셜 계정 연결 // return member; // } // // return signup(email, null, nickname, loginType, providerId, email, profilePath); // } // @Transactional // public void connectOAuthProvider2( // Member loginUser, ProviderType loginType, String providerId, String providerEmail // ) { // Member connectedMember = _findMemberByProviderId(loginType, providerId); // if (connectedMember != null) { // throw new ServiceException(ErrorCode.SOCIAL_ACCOUNT_ALREADY_IN_USE); // } // _connectProviderToMember(loginUser, loginType, providerId, providerEmail); // } @Transactional public void connectOAuthProvider( Member loginUser, ProviderType loginType, String providerId, String providerEmail ) { Member connectedMember = oAuthService.findByProviderId(loginType, providerId); if (connectedMember != null) { throw new ServiceException(ErrorCode.SOCIAL_ACCOUNT_ALREADY_IN_USE); } oAuthService.connectProvider(loginUser, loginType, providerId, providerEmail); } private void _validateEmailAndPassword(String email, String password, ProviderType loginType) { if (email == null || email.trim().isEmpty()) { throw new ServiceException(ErrorCode.EMAIL_REQUIRED); } if (ProviderType.SELF.equals(loginType) &amp;&amp; (password == null || password.trim().isEmpty())) { throw new ServiceException(ErrorCode.PASSWORD_REQUIRED); } } private void _connectProviderToMember( Member member, ProviderType loginType, String providerId, String providerEmail ) { SocialAccount socialAccount = member.getSocialAccountOrCreate(); switch (loginType) { case ProviderType.KAKAO -&gt; socialAccount.connectKakao(providerId, providerEmail); case ProviderType.GOOGLE -&gt; socialAccount.connectGoogle(providerId, providerEmail); case ProviderType.GITHUB -&gt; socialAccount.connectGithub(providerId, providerEmail); case ProviderType.NAVER -&gt; socialAccount.connectNaver(providerId, providerEmail); } } private Member _findMemberByProviderId(ProviderType loginType, String providerId) { return switch (loginType) { case ProviderType.KAKAO -&gt; memberRepository.findByKakaoProviderId(providerId).orElse(null); case ProviderType.GOOGLE -&gt; memberRepository.findByGoogleProviderId(providerId).orElse(null); case ProviderType.GITHUB -&gt; memberRepository.findByGithubProviderId(providerId).orElse(null); case ProviderType.NAVER -&gt; memberRepository.findByNaverProviderId(providerId).orElse(null); default -&gt; null; }; } } s 🔆 BaseOAuthProvider s 🔆 BaseOAuthProvider s 🔆 BaseOAuthProvider s package com.msa.member.domain.member.member.enums;import lombok.Getter;import lombok.RequiredArgsConstructor;@Getter@RequiredArgsConstructorpublic enum MemberStatus { ACTIVE(\"정상\"), INACTIVE(\"휴면\"), BANNED(\"정지\"), WITHDRAWN(\"탈퇴\"); private final String description; public boolean canLogin() { return this == ACTIVE; }}package com.msa.member.domain.member.member.enums;import lombok.Getter;import lombok.RequiredArgsConstructor;@Getter@RequiredArgsConstructorpublic enum ProviderType { SELF(\"일반\"), KAKAO(\"카카오\"), GOOGLE(\"구글\"), NAVER(\"네이버\"), GITHUB(\"깃허브\"); private final String displayName;}" }, { "title": "Member 모듈 리펙토링 - 개요 및 진행상황", "url": "/posts/member-module-1/", "categories": "Member Module, Refactoring, 개요", "tags": "멋쟁이 사자처럼, Spring Security, Member, 인증/인가, Refactoring", "date": "2025-02-17 14:00:00 +0900", "snippet": "리펙토링 진행 단계   (현재 : 3단계)⭕ 초기 흐름도⭕ 흐름도 (3단계) AuthService 회원가입/로그인/인증 총괄 OAuthService에 소셜 연동 처리 위임 Member 정보 관리 OAuthService 소셜 연동 관리 전략 패턴으로 각 소셜 로그인 처리 ...", "content": "리펙토링 진행 단계   (현재 : 3단계)⭕ 초기 흐름도⭕ 흐름도 (3단계) AuthService 회원가입/로그인/인증 총괄 OAuthService에 소셜 연동 처리 위임 Member 정보 관리 OAuthService 소셜 연동 관리 전략 패턴으로 각 소셜 로그인 처리 Member와 OAuthProvider 연결 관리 Strategy Layer 각 소셜 로그인별 구체적인 처리 Member 찾기, 연결, 해제 등 구현 실제 비즈니스 로직 수행 Member 회원 정보 OAuthProvider와 1:1 관계 소셜 연동 상태 관리 OAuthProvider 소셜 연동 정보 각 소셜 로그인 제공자별 상태 관리 Member에 종속 s s" }, { "title": "Spring Security 탐구 - 동작 원리", "url": "/posts/spring-security2/", "categories": "Spring Boot, Spring Security, 동작 원리", "tags": "멋쟁이 사자처럼, Spring Security, Spring Boot, SpringConfig, 인증/인가", "date": "2025-02-15 13:00:00 +0900", "snippet": "Spring Security 탐구 - 동작 원리1. 참고 자료 개발자 유미   (Youtube) 스프링 시큐리티 구조   :   스프링 공식 문서 Spring Security 의존성 내부 실제 클래스 Chat GPT, Claude AI 내가 Spring Security를 적용하고 커스텀한 프로젝트2. Security 의존성이 없는 상태 ...", "content": "Spring Security 탐구 - 동작 원리1. 참고 자료 개발자 유미   (Youtube) 스프링 시큐리티 구조   :   스프링 공식 문서 Spring Security 의존성 내부 실제 클래스 Chat GPT, Claude AI 내가 Spring Security를 적용하고 커스텀한 프로젝트2. Security 의존성이 없는 상태 클라이언트 요청     ⇒     Controller 클라이언트 요청은 서버 컴퓨터의 WAS(톰캣)의 필터들을 통과한 뒤 스프링 컨테이너의 컨트롤러에 도달한다. 즉, 클라이언트 요청이 서버에 도착하게 되면 특정 URL을 매핑하여 페이지나 데이터를 응답해준다. 3. Security 의존성을 추가한 상태 Spring Security가 WAS의 필터단으로부터 클라이언트 요청을 가로챈 후 FilterChainProxy에게 요청을 전달한다. WAS의 필터단에 하나의 필터를 만들어서 넣어서 해당 필터에서 요청을 가로챈다. 이렇게 가로챈 요청은 Spring Container 내부에 구현되어 있는 Spring Security 감시 로직을 거치게 된다. Spring Security 감시 로직을 마친 후 다시 WAS의 다음 필터로 복귀한다 상세 과정 Security 의존성을 추가하면 WAS의 필터 체인에 DelegatingFilterProxy라는 필터가 추가된다. SecurityAutoConfiguration 클래스에 의해 DelegatingFilterProxy 객체가 생성되고 WAS의 필터 체인에 등록된다. DelegatingFilterProxy 객체가 생성될 때 FilterChainProxy의 Bean 이름을 전달해 Bean을 가져올 수 있게 한다. DelegatingFilterProxy 필터가 요청을 가로채서 Spring Container 내부에 구현된 Spring Security 필터 체인을 거치게 한다. 이러한 Spring Security 필터 체인을 다 마치면 다시 WAS의 필터 체인으로 돌아간 뒤 Spring Container로 들어간다. 4. Spring의 SecurityFilterChain Spring Security의 로직은 여러 개의 필터들이 나열된 필터 체인 형태로 구성되어 있다. 각각의 필터에서 CSRF, 로그아웃, 로그인, 인가 등 여러 작업을 수행 SecurityFilterChain 일련의 과정들을 수행하는 필터들의 묶음 여러 개의 SecurityFilterChain SecurityFilterChain은 하나만 둘 수도 있지만 여러 개를 사용할 수도 있다. httpSecurity.securityMatcher(url) @Bean SecurityFilterChain apiFilterChain(HttpSecurity http) throws Exception { http .securityMatcher(\"/api/**\", \"/oauth2/**\", \"/login/oauth2/**\", \"/login/**\") .authorizeHttpRequests( 해당 SecurityFilterChain은 이 경로에 유효하다고 정하는 것 다만 이렇게 경로를 나누어 지정하거나 순서를 지정해줘야 오류가 발생하지 않는다. 🔆 용어 정리 DelegatingFilterProxy FilterChainProxy Spring Bean을 찾아 요청을 넘겨주는 서블릿 필터 FilterChainProxy Spring Security 의존성을 추가하면 DelegatingFilterProxy에 의해 호출되는 클래스 SecurityFilterChain들을 들고 있는 Bean이다. DelegatingFilterProxy가 요청을 가로채서 전달할 목적지 SecurityFilterChain 스프링 시큐리티 필터들의 묶음으로 실제 시큐리티 로직이 처리되는 부분 FilterChainProxy가 SecurityFilterChain을 들고 있다. " }, { "title": "Spring Security 탐구 - 개요", "url": "/posts/spring-security/", "categories": "Spring Boot, Spring Security, 동작 원리", "tags": "멋쟁이 사자처럼, Spring Security, Spring Boot, SpringConfig, 인증/인가", "date": "2025-02-14 13:00:00 +0900", "snippet": "Spring Security 탐구 - 개요1. 참고 자료 개발자 유미   (Youtube) Chat GPT, Claude AI 스프링 시큐리티 구조 : 스프링 공식 문서 Spring Security 의존성 내부 실제 클래스 Spring Security를 내가 적용하고 커스텀한 프로젝트2. 탐구 버전 Java 23 Spring Boot ...", "content": "Spring Security 탐구 - 개요1. 참고 자료 개발자 유미   (Youtube) Chat GPT, Claude AI 스프링 시큐리티 구조 : 스프링 공식 문서 Spring Security 의존성 내부 실제 클래스 Spring Security를 내가 적용하고 커스텀한 프로젝트2. 탐구 버전 Java 23 Spring Boot 3.4.13. 탐구 목표 Spring Security Framework의 구조와 내부 동작 원리 파악하기 실제 프로젝트에서 커스텀한 클래스가 어떻게 적용되고 있는지 확인하기 실제 프로젝트에서 적용한 것을 회고해보고 보완할 점 탐구하기" }, { "title": "JWT 인증 / 인가", "url": "/posts/jwt/", "categories": "멋쟁이 사자처럼, Spring Boot, Spring Security", "tags": "멋쟁이 사자처럼, Spring Security, JWT, SpringConfig, 로그인/로그아웃", "date": "2025-01-26 11:00:00 +0900", "snippet": "멋쟁이 사자처럼 수업 링크 루프코딩 연구소 재생목록1. article 메인 모듈 구현🔆 article 메인 모듈의 article 서브 모듈 구현 ApiV1ArticleController REST API Method에 따라 생성 코드 보기 package com.ll.chatAp...", "content": "멋쟁이 사자처럼 수업 링크 루프코딩 연구소 재생목록1. article 메인 모듈 구현🔆 article 메인 모듈의 article 서브 모듈 구현 ApiV1ArticleController REST API Method에 따라 생성 코드 보기 package com.ll.chatApp.domain.article.article.controller; import ... @RestController @RequestMapping(\"/api/v1/articles\") @RequiredArgsConstructor public class ApiV1ArticleController { private final ArticleService articleService; @GetMapping public List&lt;ArticleDto&gt; getArticles() { List&lt;Article&gt; articles = articleService.findAll(); List&lt;ArticleDto&gt; articleDtoList = articles.stream().map(ArticleDto::new).toList(); return articleDtoList; } @GetMapping({\"/{id}\"}) private ArticleDto getArticle(@PathVariable(\"id\") Long id) { Article article = articleService.findById(id).orElse(null); return new ArticleDto(article); } @PostMapping public RsData&lt;ArticleDto&gt; writeArticle( @Valid @RequestBody ArticleWriteRequest articleWriteRequest) { Article article = articleService.write(articleWriteRequest.getTitle(), articleWriteRequest.getContent()); return new RsData&lt;&gt;(\"200\", \"게시글이 작성에 성공하였습니다.\", new ArticleDto(article)); } @PatchMapping({\"/{id}\"}) public RsData&lt;ArticleDto&gt; updateArticle(@PathVariable(\"id\") Long id, @Valid @RequestBody ArticleModifyRequest articleModifyRequest) { Article article = this.articleService.findById(id).orElse(null); Article modifiedArticle = this.articleService.modify(article, articleModifyRequest.getTitle(), articleModifyRequest.getContent()); return new RsData&lt;&gt;(\"200\", \"게시글이 수정에 성공하였습니다.\", new ArticleDto(modifiedArticle)); } @DeleteMapping({\"/{id}\"}) public RsData&lt;Void&gt; deleteArticle(@PathVariable(\"id\") Long id) { this.articleService.delete(id); return new RsData&lt;&gt;(\"200\", \"게시글이 삭제에 성공하였습니다.\"); } } REST API 메서드 CREATE POST   -   생성 READ GET   -   단건, 다건 조회 UPDATE PUT/FATCH   -   업데이트 DELETE DELETET   -   삭제 ApiV1ArticleService 코드 보기 package com.ll.chatApp.domain.article.article.service; import ... @Transactional(readOnly = true) @RequiredArgsConstructor @Service public class ArticleService { private final ArticleRepository articleRepository; @Transactional public Article write(String title, String content) { Article article = Article.builder() .author(Member.builder().id(1L).build()) .title(title) .content(content) .build(); return articleRepository.save(article); } public Optional&lt;Article&gt; findById(Long id) { return articleRepository.findById(id); } @Transactional public Article modify(Article article, String title, String content) { article.setTitle(title); article.setContent(content); return article; } @Transactional public void modifyComment(ArticleComment comment, String commentBody) { comment.setBody(commentBody); } public List&lt;Article&gt; findAll() { return articleRepository.findAll(); } @Transactional public void delete(Long id) { this.articleRepository.deleteById(id); } } ArticleRepository 코드 보기 package com.ll.chatApp.domain.article.article.repository; import com.ll.chatApp.domain.article.article.entity.Article; import org.springframework.data.jpa.repository.JpaRepository; public interface ArticleRepository extends JpaRepository&lt;Article, Long&gt; { } Article 코드 보기 package com.ll.chatApp.domain.article.article.entity; import ... @Entity @Setter @Getter @AllArgsConstructor @NoArgsConstructor @SuperBuilder @ToString(callSuper = true) public class Article extends BaseEntity { private String title; private String content; @JsonIgnore @ManyToOne(fetch = FetchType.LAZY) private Member author; @JsonIgnore @OneToMany(mappedBy = \"article\", cascade = ALL, orphanRemoval = true) // fetch = FetchType.LAZY @Builder.Default @ToString.Exclude private List&lt;ArticleComment&gt; comments = new ArrayList&lt;&gt;(); public void addComment(Member memberAuthor, String commentBody) { ArticleComment comment = ArticleComment.builder() .article(this) .author(memberAuthor) .body(commentBody) .build(); comments.add(comment); } public void removeComment(ArticleComment articleComment) { comments.remove(articleComment); } @JsonIgnore @OneToMany(mappedBy = \"article\", cascade = ALL, orphanRemoval = true) @Builder.Default @ToString.Exclude private List&lt;ArticleTag&gt; tags = new ArrayList&lt;&gt;(); public void addTag(String tagContent) { ArticleTag tag = ArticleTag.builder() .article(this) .content(tagContent) .build(); tags.add(tag); } public void addTags(String... tagContents) { for (String tagContent : tagContents) { addTag(tagContent); } } public String getTagsStr() { String tagsStr = tags .stream() .map(ArticleTag::getContent) .collect(Collectors.joining(\" #\")); if (tagsStr.isBlank()) { return \"\"; } return \"#\" + tagsStr; } } 🔆 @Valid 애노테이션 추가 Validation 의존성 추가 데이터 검증할 때 사용하는 라이브러리 build.gradle implementation 'org.springframework.boot:spring-boot-starter-validation' 필요한 데이터가 들어오지 않으면 사전에 처리한다. @NotBlank @Valid @NotBlank를 개별 DTO 필드(필수 항목)에 추가하고 해당 DTO를 Controller 클래스의 메서드에서 파라미터로 받을 때 @Valid를 사용하여 검증할 수 있게 한다. 🔆 ArticleService 삭제 @Transactional 애노테이션 추가 @Transactional(readOnly = true) 클래스에 readOnly를 사용하고 생성, 수정, 삭제 메서드에 @Transactional 설정을 하지 않으면 조회만 할 수 있다. 즉, 생성, 수정, 삭제의 경우 @Transactional 설정 필요   (데이터 변경이 가능해진다) ArticleService @Transactional(readOnly = true) @RequiredArgsConstructor @Service public class ArticleService { private final ArticleRepository articleRepository; \t@Transactional public Article write(String title, String content) { Article article = Article.builder() .author(Member.builder().id(1L).build()) .title(title) .content(content) .build(); return articleRepository.save(article); } ... 이렇게 생성 메서드는 @Transactional 애노테이션을 추가해야 한다. 2. 회원가입 구현🔆 전체 최종 코드 ApiV1MemberController 코드 보기 package com.ll.chatApp.domain.member.member.controller; import com.ll.chatApp.domain.member.member.dto.MemberDto; import com.ll.chatApp.domain.member.member.dto.MemberRequest; import com.ll.chatApp.domain.member.member.entity.Member; import com.ll.chatApp.domain.member.member.service.MemberService; import com.ll.chatApp.global.jwt.JwtProvider; import com.ll.chatApp.global.rsData.RsData; import jakarta.servlet.http.Cookie; import jakarta.servlet.http.HttpServletRequest; import jakarta.servlet.http.HttpServletResponse; import jakarta.validation.Valid; import lombok.RequiredArgsConstructor; import org.springframework.web.bind.annotation.*; import java.util.Map; @RestController @RequestMapping(\"/api/v1/members\") @RequiredArgsConstructor public class ApiV1MemberController { private final MemberService memberService; private final JwtProvider jwtProvider; @PostMapping(\"/signup\") public RsData&lt;MemberDto&gt; signup(@Valid @RequestBody MemberRequest memberRequest) { Member member = memberService.join(memberRequest.getUsername(), memberRequest.getPassword()); return new RsData&lt;&gt;(\"200\", \"회원가입에 성공하였습니다.\", new MemberDto(member)); } @PostMapping(\"/login\") public RsData&lt;Void&gt; login(@Valid @RequestBody MemberRequest memberRequest, HttpServletResponse response) { Member member = memberService.getMember(memberRequest.getUsername()); // 토큰 생성 String token = jwtProvider.genAccessToken(member); // 응답 데이터에 accessToken 이름으로 토큰을 발급 Cookie cookie = new Cookie(\"accessToken\", token); cookie.setHttpOnly(true); cookie.setSecure(true); cookie.setPath(\"/\"); cookie.setMaxAge(60 * 60); response.addCookie(cookie); String refreshToken = member.getRefreshToken(); Cookie refreshTokenCookie = new Cookie(\"refreshToken\", refreshToken); refreshTokenCookie.setHttpOnly(true); refreshTokenCookie.setSecure(true); refreshTokenCookie.setPath(\"/\"); refreshTokenCookie.setMaxAge(60 * 60); response.addCookie(refreshTokenCookie); return new RsData&lt;&gt;(\"200\", \"로그인에 성공하였습니다.\"); } @GetMapping(\"/logout\") public RsData&lt;Void&gt; logout(HttpServletResponse response) { Cookie cookie = new Cookie(\"accessToken\", null); cookie.setPath(\"/\"); cookie.setMaxAge(0); response.addCookie(cookie); Cookie refreshTokenCookie = new Cookie(\"refreshToken\", null); refreshTokenCookie.setPath(\"/\"); refreshTokenCookie.setMaxAge(0); response.addCookie(refreshTokenCookie); return new RsData&lt;&gt;(\"200\", \"로그아웃에 성공하였습니다.\"); } @GetMapping(\"/me\") public RsData&lt;MemberDto&gt; me(HttpServletRequest request) { Cookie[] cookies = request.getCookies(); String accessToken = \"\"; for (Cookie cookie : cookies) { if (cookie.getName().equals(\"accessToken\")) { accessToken = cookie.getValue(); } } Map&lt;String, Object&gt; claims = jwtProvider.getClaims(accessToken); String username = (String) claims.get(\"username\"); Member member = this.memberService.getMember(username); return new RsData(\"200\", \"회원정보 조회 성공\", new MemberDto(member)); } } MemberService 코드 보기 package com.ll.chatApp.domain.member.member.service; import com.ll.chatApp.domain.member.member.entity.Member; import com.ll.chatApp.domain.member.member.repository.MemberRepository; import com.ll.chatApp.global.jwt.JwtProvider; import com.ll.chatApp.global.rsData.RsData; import com.ll.chatApp.global.security.SecurityUser; import lombok.RequiredArgsConstructor; import org.springframework.security.core.GrantedAuthority; import org.springframework.security.crypto.password.PasswordEncoder; import org.springframework.stereotype.Service; import java.util.ArrayList; import java.util.List; import java.util.Map; import java.util.Optional; @Service @RequiredArgsConstructor public class MemberService { private final MemberRepository memberRepository; private final PasswordEncoder passwordEncoder; private final JwtProvider jwtProvider; public Member join(String username, String password) { Member CheckedSignUpMember = memberRepository.findByUsername(username); if (CheckedSignUpMember != null) { throw new IllegalArgumentException(\"이미 존재하는 회원입니다.\"); } Member member = Member.builder().username(username).password(passwordEncoder.encode(password)).build(); String refreshToken = jwtProvider.genRefreshToken(member); member.setRefreshToken(refreshToken); return memberRepository.save(member); } public Optional&lt;Member&gt; findById(Long id) { return memberRepository.findById(id); } public Member getMember(String username) { return memberRepository.findByUsername(username); } // 토큰 유효성 검증 public boolean validateToken(String token) { return jwtProvider.verify(token); } // 토큰갱신 public RsData&lt;String&gt; refreshAccessToken(String refreshToken) { Member member = memberRepository.findByRefreshToken(refreshToken) .orElseThrow(() -&gt; new IllegalArgumentException(\"유효하지 않은 토큰입니다.\")); String accessToken = jwtProvider.genAccessToken(member); return new RsData&lt;&gt;(\"200\", \"토큰 갱신에 성공하였습니다.\", accessToken); } // 토큰으로 User 정보 가져오기 public SecurityUser getUserFromAccessToken(String accessToken) { Map&lt;String, Object&gt; payloadBody = jwtProvider.getClaims(accessToken); long id = (int) payloadBody.get(\"id\"); String username = (String) payloadBody.get(\"username\"); List&lt;GrantedAuthority&gt; authorities = new ArrayList&lt;&gt;(); return new SecurityUser(id, username, \"\", authorities); } } Member 코드 보기 package com.ll.chatApp.domain.member.member.entity; import com.fasterxml.jackson.annotation.JsonIgnore; import com.ll.chatApp.global.jpa.BaseEntity; import jakarta.persistence.Column; import jakarta.persistence.Entity; import lombok.AllArgsConstructor; import lombok.Getter; import lombok.NoArgsConstructor; import lombok.Setter; import lombok.experimental.SuperBuilder; @Entity @Setter @Getter @AllArgsConstructor @NoArgsConstructor @SuperBuilder public class Member extends BaseEntity { @Column(unique = true) private String username; @JsonIgnore private String password; @JsonIgnore private String refreshToken; } MemberRepository 코드 보기 package com.ll.chatApp.domain.member.member.repository; import com.ll.chatApp.domain.member.member.entity.Member; import org.springframework.data.jpa.repository.JpaRepository; import org.springframework.stereotype.Repository; import java.util.Optional; @Repository public interface MemberRepository extends JpaRepository&lt;Member, Long&gt; { Member findByUsername(String username); Optional&lt;Member&gt; findByRefreshToken(String refreshToken); } MemberDto 코드 보기 package com.ll.chatApp.domain.member.member.dto; import com.ll.chatApp.domain.member.member.entity.Member; import lombok.Getter; @Getter public class MemberDto { private String username; public MemberDto(Member member) { this.username = member.getUsername(); } } MemberRequest 코드 보기 package com.ll.chatApp.domain.member.member.dto; import jakarta.validation.constraints.NotBlank; import lombok.Data; @Data public class MemberRequest { @NotBlank private String username; @NotBlank private String password; } JwtProvider 코드 보기 package com.ll.chatApp.global.jwt; import com.ll.chatApp.domain.member.member.entity.Member; import com.ll.chatApp.global.util.Ut; import io.jsonwebtoken.Jwts; import io.jsonwebtoken.SignatureAlgorithm; import io.jsonwebtoken.security.Keys; import org.springframework.beans.factory.annotation.Value; import org.springframework.stereotype.Component; import javax.crypto.SecretKey; import java.util.Base64; import java.util.Date; import java.util.HashMap; import java.util.Map; @Component public class JwtProvider { @Value(\"${custom.jwt.secretKey}\") private String secretKeyOrigin; @Value(\"${custom.accessToken.expirationSeconds}\") private int accessTokenExpirationSeconds; private SecretKey cachedSecretKey; public SecretKey getSecretKey() { if (cachedSecretKey == null) { cachedSecretKey = _getSecretKey(); } return cachedSecretKey; } private SecretKey _getSecretKey() { String keyBase64Encoded = Base64.getEncoder().encodeToString(secretKeyOrigin.getBytes()); return Keys.hmacShaKeyFor(keyBase64Encoded.getBytes()); } public String genAccessToken(Member member) { return genToken(member, accessTokenExpirationSeconds); } public String genRefreshToken(Member member) { return genToken(member, 60 * 60 * 24 * 365 * 1); } public String genToken(Member member, int seconds) { Map&lt;String, Object&gt; claims = new HashMap&lt;&gt;(); claims.put(\"id\", member.getId()); claims.put(\"username\", member.getUsername()); long now = new Date().getTime(); Date accessTokenExpiresIn = new Date(now + 1000L * seconds); return Jwts.builder().claim(\"body\", Ut.json.toStr(claims)).setExpiration(accessTokenExpiresIn) .signWith(getSecretKey(), SignatureAlgorithm.HS512).compact(); } // 클레임 정보 받아오기 public Map getClaims(String token) { String body = Jwts.parserBuilder().setSigningKey(getSecretKey()).build().parseClaimsJws(token).getBody() .get(\"body\", String.class); return Ut.toMap(body); } // 유효성 검증 public boolean verify(String token) { try { Jwts.parserBuilder().setSigningKey(getSecretKey()).build().parseClaimsJws(token); return true; } catch (Exception e) { return false; } } } SecurityConfig 코드 보기 package com.ll.chatApp.global.security; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity; import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder; import org.springframework.security.crypto.password.PasswordEncoder; import org.springframework.security.web.SecurityFilterChain; import org.springframework.security.web.util.matcher.AntPathRequestMatcher; @Configuration @EnableWebSecurity public class SecurityConfig { @Bean SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http.csrf(csrf -&gt; csrf.disable()).authorizeHttpRequests( (authorizeHttpRequests) -&gt; authorizeHttpRequests.requestMatchers( new AntPathRequestMatcher(\"/**\")).permitAll()); return http.build(); } @Bean PasswordEncoder passwordEncoder() { return new BCryptPasswordEncoder(); } } ApiSecurityConfig 코드 보기 package com.ll.chatApp.global.security; import lombok.RequiredArgsConstructor; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.http.HttpMethod; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity; import org.springframework.security.config.http.SessionCreationPolicy; import org.springframework.security.web.SecurityFilterChain; import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter; @Configuration @EnableWebSecurity @RequiredArgsConstructor public class ApiSecurityConfig { private final JwtAuthorizationFilter jwtAuthorizationFilter; @Bean SecurityFilterChain apiFilterChain(HttpSecurity http) throws Exception { http.securityMatcher(\"/api/**\").authorizeHttpRequests( authorizeRequests -&gt; authorizeRequests.requestMatchers(HttpMethod.GET, \"/api/*/articles\") .permitAll().requestMatchers(HttpMethod.GET, \"/api/*/articles/*\").permitAll() .requestMatchers(HttpMethod.POST, \"/api/*/members/login\") .permitAll() // 로그인은 누구나 가능, post 요청만 허용 .requestMatchers(HttpMethod.GET, \"/api/*/members/logout\") .permitAll() // 로그인은 누구나 가능, post 요청만 허용 .anyRequest().authenticated()).csrf(csrf -&gt; csrf.disable()) // csrf 토큰 끄기 .httpBasic(httpBasic -&gt; httpBasic.disable()) // httpBasic 로그인 방식 끄기 .formLogin(formLogin -&gt; formLogin.disable()) // 폼 로그인 방식 끄기 .sessionManagement(sessionManagement -&gt; sessionManagement.sessionCreationPolicy( SessionCreationPolicy.STATELESS)) .addFilterBefore(jwtAuthorizationFilter, //엑세스 토큰을 이용한 로그인 처리 UsernamePasswordAuthenticationFilter.class); return http.build(); } } JwtAuthorizationFilter 코드 보기 package com.ll.chatApp.global.security; import com.ll.chatApp.domain.member.member.service.MemberService; import com.ll.chatApp.global.rsData.RsData; import jakarta.servlet.FilterChain; import jakarta.servlet.http.Cookie; import jakarta.servlet.http.HttpServletRequest; import jakarta.servlet.http.HttpServletResponse; import lombok.RequiredArgsConstructor; import lombok.SneakyThrows; import org.springframework.http.ResponseCookie; import org.springframework.security.core.context.SecurityContextHolder; import org.springframework.stereotype.Component; import org.springframework.web.filter.OncePerRequestFilter; import java.util.Arrays; @Component @RequiredArgsConstructor public class JwtAuthorizationFilter extends OncePerRequestFilter { private final HttpServletRequest req; private final HttpServletResponse resp; private final MemberService memberService; @Override @SneakyThrows protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) { if (request.getRequestURI().equals(\"/api/v1/members/login\") || request.getRequestURI() .equals(\"/api/v1/members/logout\")) { filterChain.doFilter(request, response); return; } String accessToken = _getCookie(\"accessToken\"); // accessToken 검증 or refreshToken 발급 if (!accessToken.isBlank()) { // 토큰 유효기간 검증 if (!memberService.validateToken(accessToken)) { String refreshToken = _getCookie(\"refreshToken\"); RsData&lt;String&gt; rs = memberService.refreshAccessToken(refreshToken); _addHeaderCookie(\"accessToken\", rs.getData()); } // securityUser 가져오기 SecurityUser securityUser = memberService.getUserFromAccessToken(accessToken); // 인가 처리 SecurityContextHolder.getContext().setAuthentication(securityUser.genAuthentication()); } filterChain.doFilter(request, response); } private String _getCookie(String name) { Cookie[] cookies = req.getCookies(); return Arrays.stream(cookies).filter(cookie -&gt; cookie.getName().equals(name)).findFirst() .map(Cookie::getValue).orElse(\"\"); } private void _addHeaderCookie(String tokenName, String token) { ResponseCookie cookie = ResponseCookie.from(tokenName, token).path(\"/\").sameSite(\"None\").secure(true).httpOnly(true) .build(); resp.addHeader(\"Set-Cookie\", cookie.toString()); } } SecurityUser 코드 보기 package com.ll.chatApp.global.security; import lombok.Getter; import org.springframework.security.authentication.UsernamePasswordAuthenticationToken; import org.springframework.security.core.Authentication; import org.springframework.security.core.GrantedAuthority; import org.springframework.security.core.userdetails.User; import java.util.Collection; public class SecurityUser extends User { @Getter private long id; public SecurityUser(long id, String username, String password, Collection&lt;? extends GrantedAuthority&gt; authorities) { super(username, password, authorities); this.id = id; } public Authentication genAuthentication() { Authentication auth = new UsernamePasswordAuthenticationToken(this, this.getPassword(), this.getAuthorities()); return auth; } } 🔆 스프링 시큐리티 도입, 초기 권한설정 Spring Security 의존성 추가 build.gradle implementation 'org.springframework.boot:spring-boot-starter-security' 설정하면 자동으로 기본 로그인 화면이 추가된다. 기존의 로그인을 요청한다면 401 Unauthorized 에러 발생   ⇒   정상 Security 설정을 위한 클래스 생성 SecurityConfig @Configuration @EnableWebSecurity public class SecurityConfig { @Bean SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http .csrf(csrf -&gt; csrf.disable()) .authorizeHttpRequests((authorizeHttpRequests) -&gt; authorizeHttpRequests .requestMatchers(new AntPathRequestMatcher(\"/**\")).permitAll()) ; return http.build(); } @Bean PasswordEncoder passwordEncoder() { return new BCryptPasswordEncoder(); } } .csrf(csrf -&gt; csrf.disable()) csrf 토큰 인증 끄기 csrf(AbstractHttpConfigurer::disable)는 결과는 같지만 람다를 사용하여 간단히 표현한 것 .authorizeHttpRequests((authorizeHttpRequests) -&gt; authorizeHttpRequests.requestMatchers(new AntPathRequestMatcher(\"/**\")).permitAll()) .authorizeHttpRequests(*auth* -&gt; *auth*.anyRequest().permitAll()) 두 코드는 동일하다. (\"/**\") 모든 End Point를 뜻한다. permitAll() 모두 허용 passwordEncoder()는 비밀번호 인코딩하려고 등록한 팩토리 메서드이다. @EnableWebSecurity Spring Security의 기본 설정을 비활성화하고, 개발자가 제공한 커스텀 설정(SecurityFilterChain 등)을 적용하도록 Spring Security 환경을 구성하는 것 없어도 Spring Boot 2.7 이상과 Spring Security 5.7 이상 버전에서는 SecurityFilterChain를 정의하고 Bean으로 등록하면 자동 인식한다. 🔆 회원가입 구현 ApiV1MemberController @RestController @RequestMapping(\"/api/v1/members\") @RequiredArgsConstructor public class ApiV1MemberController { private final MemberService memberService; private final JwtProvider jwtProvider; @PostMapping(\"/signup\") public RsData&lt;MemberDto&gt; signup(@Valid @RequestBody MemberRequest memberRequest) { Member member = memberService.join(memberRequest.getUsername(), memberRequest.getPassword()); return new RsData&lt;&gt;(\"200\", \"회원가입에 성공하였습니다.\", new MemberDto(member)); } 회원 가입용 Request DTO를 사용하고 @Valid로 검증한다. MemberService @Service @RequiredArgsConstructor public class MemberService { private final MemberRepository memberRepository; private final PasswordEncoder passwordEncoder; private final JwtProvider jwtProvider; public Member join(String username, String password) { Member CheckedSignUpMember = memberRepository.findByUsername(username); if (CheckedSignUpMember != null) { throw new IllegalArgumentException(\"이미 존재하는 회원입니다.\"); } Member member = Member.builder().username(username).password(passwordEncoder.encode(password)).build(); return memberRepository.save(member); } 기존 DB에서 회원 가입 전 존재 여부를 파악한다. MemberRequest 생성 package com.ll.chatApp.domain.member.member.dto; import jakarta.validation.constraints.NotBlank; import lombok.Data; @Data public class MemberRequest { @NotBlank private String username; @NotBlank private String password; } DTO 클래스 🔆 RsData 클래스 수정 RsData @JsonInclude(JsonInclude.Include.NON_NULL) @AllArgsConstructor @Getter public class RsData&lt;T&gt; { private String resultCode; private String msg; private T data; public RsData(String resultCode, String msg) { this(resultCode, msg, null); } @JsonIgnore public int getStatusCode() { return Integer.parseInt(resultCode.split(\"-\")[0]); } } 🔆 JWT 토큰 발급을 위한 작업 JWT 관련 의존성 추가하기 build.gradle implementation 'io.jsonwebtoken:jjwt-api:0.11.5' runtimeOnly 'io.jsonwebtoken:jjwt-impl:0.11.5' runtimeOnly 'io.jsonwebtoken:jjwt-jackson:0.11.5' JWT Secret 키 및 AccessToken 유효 시간을 환경변수로 설정하기 application-secret.yml custom: jwt: secretKey: 12314124124dfsdf9sdfa8f89asd8f9sdaf8t238f9safsdf98sadfsdafasd2342dsgrer2 accessToken: expirationSeconds: \"#{60 * 10}\" 나중에 이렇게 설정한 정보로 JwtProvider로 값을 꺼내서 사용한다. Ut.java JwtProvider에서 토큰 생성 시 Map으로 만든 claims 데이터를 json으로 전환한다. public class Ut { public static class json { public static Object toStr(Map&lt;String, Object&gt; map) { try { return new ObjectMapper().writeValueAsString(map); } catch (JsonProcessingException e) { return null; } } } public static Map&lt;String, Object&gt; toMap(String jsonStr) { try { return new ObjectMapper().readValue(jsonStr, LinkedHashMap.class); } catch (JsonProcessingException e) { return null; } } } global/jwt/JwtProvider @Component public class JwtProvider { @Value(\"${custom.jwt.secretKey}\") private String secretKeyOrigin; @Value(\"${custom.accessToken.expirationSeconds}\") private int accessTokenExpirationSeconds; private SecretKey cachedSecretKey; public SecretKey getSecretKey() { if (cachedSecretKey == null) { cachedSecretKey = _getSecretKey(); } return cachedSecretKey; } application-secret.yml에서 설정한 secretKey와 expirationSeconds를 @Value 애노테이션으로 가져와서 필드에 주입한다. cachedSecretKey는 secretKey로 부터 생성된 SecretKey 객체이다. 즉 SecretKey를 생성하는 작업은 상대적으로 Base64 인코딩 및 HMAC 키 생성으로 비용이 높은 작업이다. 따라서 캐싱과 싱글톤 패턴을 사용하여 비용을 줄인다. 캐싱   (Caching) 데이터를 빠르게 접근하기 위해 메모리에 임시로 저장하는 기술 getSecretKey()는 캐싱과 싱글톤 패턴을 통해 반복적으로 동일한 키를 생성하지 않고, 이미 생성된 객체를 재사용하기 위한 메서드이다. private SecretKey _getSecretKey() { String keyBase64Encoded = Base64.getEncoder().encodeToString(secretKeyOrigin.getBytes()); return Keys.hmacShaKeyFor(keyBase64Encoded.getBytes()); } public String genAccessToken(Member member) { return genToken(member, accessTokenExpirationSeconds); } public String genRefreshToken(Member member) { return genToken(member, 60 * 60 * 24 * 365 * 1); } public String genToken(Member member, int seconds) { Map&lt;String, Object&gt; claims = new HashMap&lt;&gt;(); claims.put(\"id\", member.getId()); claims.put(\"username\", member.getUsername()); long now = new Date().getTime(); Date accessTokenExpiresIn = new Date(now + 1000L * seconds); return Jwts.builder().claim(\"body\", Ut.json.toStr(claims)).setExpiration(accessTokenExpiresIn) .signWith(getSecretKey(), SignatureAlgorithm.HS512).compact(); } 메서드명 앞에 _를 붙이는 것은 해당 클래스 내부에서만 활용하는 private 메서드를 표시하기 위한 것이다. _getSecretKey() 설정 파일에서 설정한 secretKey를 Base64로 인코딩 한 후 HMAC으로 SecretKey 객체를 생성하는 것 genToken()은 genAccessToken()과 genToken()의 공통 코드를 분리한 메서드이다. 사용자 정보로부터 Token을 만든다. 만료 시간을 받아서 설정할 수 있도록 한다. claims라는 Map을 만들어 사용자 정보를 저장한다. claims와 parsing에 사용할 Ut 클래스와 함께 넘겨서 JWT 토큰을 생성하고 token 문자열을 리턴한다. 🔆 ApiSecurityConfig API와 관련된 처리를 할 Config 설정 SecurityConfig 설정의 우선 순위는 작은 범위가 먼저이다. ⭐ ApiSecurityConfig @Configuration @EnableWebSecurity @RequiredArgsConstructor public class ApiSecurityConfig { @Bean SecurityFilterChain apiFilterChain(HttpSecurity http) throws Exception { http .securityMatcher(\"/api/**\") .authorizeHttpRequests( authorizeRequests -&gt; authorizeRequests .requestMatchers(HttpMethod.GET, \"/api/*/articles\").permitAll() .requestMatchers(HttpMethod.GET, \"/api/*/articles/*\").permitAll() .requestMatchers(HttpMethod.POST, \"/api/*/members/login\").permitAll() // 로그인은 누구나 가능, post 요청만 허용 .requestMatchers(HttpMethod.GET, \"/api/*/members/logout\").permitAll() .anyRequest().authenticated() ) .csrf(csrf -&gt; csrf.disable()) // csrf 토큰 끄기 .httpBasic(httpBasic -&gt; httpBasic.disable()) // httpBasic 로그인 방식 끄기 .formLogin(formLogin -&gt; formLogin.disable()) // 폼 로그인 방식 끄기 .sessionManagement( sessionManagement -&gt; sessionManagement.sessionCreationPolicy( SessionCreationPolicy.STATELESS) ); return http.build(); } } .securityMatcher(\"/api/**\") 설정한 URL 요청이 들어오면 아래의 설정을 따르겠다는 말이다. .requestMatchers(HttpMethod.GET, \"/api/*/articles\").permitAll() /api/*/   :   /api/v1, /api/v2 .. 등 모두를 의미한다. 즉, 목록 조회를 인증/인가 없이 허용하겠다는 의미이다. requestMatchers(HttpMethod.GET, \"/api/*/articles/*\").permitAll() 상세 조회를 인증/인가 없이 허용하겠다는 의미이다. .httpBasic(httpBasic -&gt; httpBasic.disable()) httpBasic 로그인 방식 끄기   ⇒   기본 로그인 사용 안 함 .formLogin(formLogin -&gt; formLogin.disable()) 폼 로그인 방식 끄기 .sessionManagement(sessionManagement -&gt; sessionManagement.sessionCreationPolicy(SessionCreationPolicy.STATELESS)) 세션 방식 끄기   (SessionCreationPolicy.STATELESS) 허용 되지 않는 End Point 요청 시   ⇒   403 에러   (권한 없음)3. 로그인 구현🔆 JWT AccessToken 발급 확인 테스트 ApiV1MemberController @PostMapping(\"/login\") public RsData&lt;Void&gt; login(@Valid @RequestBody MemberRequest memberRequest) { Member member = memberService.getMember(memberRequest.getUsername()); // 토큰 생성 String token = jwtProvider.genAccessToken(member); return new RsData&lt;&gt;(\"200\", \"로그인에 성공하였습니다.\"); } String token = jwtProvider.genAccessToken(member); 회원 정보를 넘기며 AcessToken을 생성한다. 🔆 JWT AccessToken 발급 쿠키에 담아 보내기 쿠키는 Spring에서 제공하는 HttpServletResponse 객체를 이용한다. 해당 객체에게 addCookie()를 호출하고 new Cookie()로 객체를 만들어 넘긴다. ApiV1MemberController @PostMapping(\"/login\") public RsData&lt;Void&gt; login(@Valid @RequestBody MemberRequest memberRequest, HttpServletResponse response) { Member member = memberService.getMember(memberRequest.getUsername()); // 토큰 생성 String token = jwtProvider.genAccessToken(member); // 응답 데이터에 accessToken 이름으로 토큰을 발급 Cookie cookie = new Cookie(\"accessToken\", token); cookie.setHttpOnly(true); cookie.setSecure(true); cookie.setPath(\"/\"); cookie.setMaxAge(60 * 60); response.addCookie(cookie); return new RsData&lt;&gt;(\"200\", \"로그인에 성공하였습니다.\"); } setPath()로 사용 가능한 경로를 설정하지 않는다면 특정 경로에서 쿠키를 사용할 수 없을 수도 있다. 브라우저의 개발자 도구에서 쿠키를 확인할 수 있다. 🔆 쿠키에 담긴 토큰을 이용해 내 회원정보 불러오기 JwtProvider 클레임 정보 받아오는 메서드 추가 토큰을 복호화하여 Body 안의 데이터(json)를 Map으로 다시 바꿔준다. public Map getClaims(String token) { String body = Jwts.parserBuilder() .setSigningKey(getSecretKey()).build() .parseClaimsJws(token).getBody() .get(\"body\", String.class); return Ut.toMap(body); } Jwts.parserBuilder()는 JWT 토큰을 파싱하는 용도이다. token의 body 안의 claims 정보를 가지고 오기 위한 것이다. ApiV1MemberController Cookie에서 토큰을 가져와서 내 정보를 읽어오는 메서드 생성 @GetMapping(\"/me\") public RsData&lt;MemberDto&gt; me(HttpServletRequest request) { Cookie[] cookies = request.getCookies(); String accessToken = \"\"; for (Cookie cookie : cookies) { if (cookie.getName().equals(\"accessToken\")) { accessToken = cookie.getValue(); } } Map&lt;String, Object&gt; claims = jwtProvider.getClaims(accessToken); String username = (String) claims.get(\"username\"); Member member = this.memberService.getMember(username); return new RsData(\"200\", \"회원정보 조회 성공\", new MemberDto(member)); } 그러나 Token을 쿠키에 담을 때 쿠키에 setPath(\"/\")를 명시적으로 설정하지 않으면, 기본적으로 쿠키의 경로는 쿠키가 생성된 요청 경로로 설정된다 ⭐ (메서드의 경로가 api/v1/auth/me인 경우 /auth로 경로가 설정된다.) 설정된 경로 하위 경로까지 쿠키가 유효하다 ⭐` 🔆 HttpOnly Cookie로 변경 일반 쿠키를 사용하면 사용자가 임의로 처리할 수 있다. 즉 탈취의 위험성이 있다. 따라서, 보안 설정이 적용된 쿠키인 HttpOnly Cookie를 사용한다. ApiV1MemberController @PostMapping(\"/login\") public RsData&lt;Void&gt; login(@Valid @RequestBody MemberRequest memberRequest, HttpServletResponse response) { Member member = memberService.getMember(memberRequest.getUsername()); // 토큰 생성 String token = jwtProvider.genAccessToken(member); // 응답 데이터에 accessToken 이름으로 토큰을 발급 Cookie cookie = new Cookie(\"accessToken\", token); cookie.setHttpOnly(true); cookie.setSecure(true); cookie.setPath(\"/\"); cookie.setMaxAge(60 * 60); response.addCookie(cookie); return new RsData&lt;&gt;(\"200\", \"로그인에 성공하였습니다.\"); } 4. JWT 인가 처리🔆 JWT 토큰 인가 처리 Member refresh 토큰 필드 추가 @Entity @Setter @Getter @AllArgsConstructor @NoArgsConstructor @SuperBuilder public class Member extends BaseEntity { @Column(unique = true) private String username; @JsonIgnore private String password; @JsonIgnore private String refreshToken; } DB에 refreshToken을 저장하여 클라이언트가 보유한 refresh Token과 비교하여 검증한다. 방법 중 하나는 아래와 같다. MemberRepository refresh 토큰으로 해당 사용자를 찾는 메서드 추가 @Repository public interface MemberRepository extends JpaRepository&lt;Member, Long&gt; { Member findByUsername(String username); Optional&lt;Member&gt; findByRefreshToken(String refreshToken); } MemberService // 토큰 유효성 검증 public boolean validateToken(String token) { return jwtProvider.verify(token); } // 토큰갱신 public RsData&lt;String&gt; refreshAccessToken(String refreshToken) { Member member = memberRepository.findByRefreshToken(refreshToken) .orElseThrow(() -&gt; new IllegalArgumentException(\"유효하지 않은 토큰입니다.\")); String accessToken = jwtProvider.genAccessToken(member); return new RsData&lt;&gt;(\"200\", \"토큰 갱신에 성공하였습니다.\", accessToken); } // 토큰으로 User 정보 가져오기 public SecurityUser getUserFromAccessToken(String accessToken) { Map&lt;String, Object&gt; payloadBody = jwtProvider.getClaims(accessToken); long id = (int) payloadBody.get(\"id\"); String username = (String) payloadBody.get(\"username\"); List&lt;GrantedAuthority&gt; authorities = new ArrayList&lt;&gt;(); return new SecurityUser(id, username, \"\", authorities); } 토큰 유효성 검증   (validateToken(String token)) 토큰 갱신   (refresh 토큰으로 새로운 accessToken 생성) refreshAccessToken(String refreshToken) 토큰으로 User 정보 가져오기   (getUserFromAccessToken(String accessToken)) SecurityUser Security의 User 클래스를 상속받아서 처리한다. 생성자로 데이터를 받아서 Security의 User 클래스 한 번 더 가공하여 리턴하는 용도 public class SecurityUser extends User { @Getter private long id; public SecurityUser(long id, String username, String password, Collection&lt;? extends GrantedAuthority&gt; authorities) { super(username, password, authorities); this.id = id; } public Authentication genAuthentication() { Authentication auth = new UsernamePasswordAuthenticationToken(this, this.getPassword(), this.getAuthorities()); return auth; } } SecurityUser 객체를 만들 때 생성자로 정보를 받아서 설정한다. genAuthentication() Authentication 클래스는 Spring Security에서 제공하는 인터페이스 이 메서드는 Authentication 구현체인 UsernamePasswordAuthenticationToken 객체를 반환하는 메서드이다. Security User 객체의 비밀번호와, 권한으로 UsernamePasswordAuthenticationToken 객체를 생성한다. 즉, 인증된 객체를 만드는 것이다. 🔆 JwtAuthorizationFilter ⭐ JwtAuthorizationFilter JWT 인가 처리를 위한 클래스이다. @Component @RequiredArgsConstructor public class JwtAuthorizationFilter extends OncePerRequestFilter { private final HttpServletRequest req; private final HttpServletResponse resp; private final MemberService memberService; @Override @SneakyThrows protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) { if (request.getRequestURI().equals(\"/api/v1/members/login\") || request.getRequestURI() .equals(\"/api/v1/members/logout\")) { filterChain.doFilter(request, response); return; } String accessToken = _getCookie(\"accessToken\"); // accessToken 검증 or refreshToken 발급 if (!accessToken.isBlank()) { // 토큰 유효기간 검증 if (!memberService.validateToken(accessToken)) { String refreshToken = _getCookie(\"refreshToken\"); RsData&lt;String&gt; rs = memberService.refreshAccessToken(refreshToken); _addHeaderCookie(\"accessToken\", rs.getData()); } // securityUser 가져오기 SecurityUser securityUser = memberService.getUserFromAccessToken(accessToken); // 인가 처리 SecurityContextHolder.getContext().setAuthentication(securityUser.genAuthentication()); } filterChain.doFilter(request, response); } private String _getCookie(String name) { Cookie[] cookies = req.getCookies(); return Arrays.stream(cookies).filter(cookie -&gt; cookie.getName().equals(name)).findFirst() .map(Cookie::getValue).orElse(\"\"); } private void _addHeaderCookie(String tokenName, String token) { ResponseCookie cookie = ResponseCookie.from(tokenName, token).path(\"/\").sameSite(\"None\").secure(true).httpOnly(true) .build(); resp.addHeader(\"Set-Cookie\", cookie.toString()); } } 이 클래스는 JWT 토큰 인가를 확인하는 클래스이다. 먼저 인가 확인을 제외할 URL을 지정한다. 즉, 로그인 또는 로그아웃 API URL과 일치하는 경우, 필터 체인에서 다음 필터로 요청을 전달하고, 이후의 로직을 실행하지 않도록 return한다. if (request.getRequestURI().equals(\"/api/v1/members/login\") || request.getRequestURI() .equals(\"/api/v1/members/logout\")) { filterChain.doFilter(request, response); return; } String accessToken = _getCookie(\"accessToken\"); // accessToken 검증 or refreshToken 발급 if (!accessToken.isBlank()) { // 토큰 유효기간 검증 if (!memberService.validateToken(accessToken)) { String refreshToken = _getCookie(\"refreshToken\"); RsData&lt;String&gt; rs = memberService.refreshAccessToken(refreshToken); _addHeaderCookie(\"accessToken\", rs.getData()); } // securityUser 가져오기 SecurityUser securityUser = memberService.getUserFromAccessToken(accessToken); // 인가 처리 SecurityContextHolder.getContext().setAuthentication(securityUser.genAuthentication()); } filterChain.doFilter(request, response); } HttpServletRequest에서 Cookie 배열을 읽어와서 원하는 쿠키 이름의 쿠키를 찾아 가져온다. 만약 쿠키가 있지만, Token이 유효하지 않다면 refresh token을 가져와서 refresh token으로 새로운 Access Token을 발급 받고 _addHeaderCookie()로 응답 Header의 쿠키에 다시 넣어준다. 또 Access Token으로 해당 Security User 객체를 가져와서 인증 정보로 SecurityContext에 넣어준다. ApiSecurityConfig 수정하기 JwtAuthorizationFilter 필터를 추가하여 AccessToken을 이용한 로그인을 처리한다. @Configuration @EnableWebSecurity @RequiredArgsConstructor public class ApiSecurityConfig { private final JwtAuthorizationFilter jwtAuthorizationFilter; @Bean SecurityFilterChain apiFilterChain(HttpSecurity http) throws Exception { http.securityMatcher(\"/api/**\").authorizeHttpRequests( authorizeRequests -&gt; authorizeRequests.requestMatchers(HttpMethod.GET, \"/api/*/articles\") .permitAll().requestMatchers(HttpMethod.GET, \"/api/*/articles/*\").permitAll() .requestMatchers(HttpMethod.POST, \"/api/*/members/login\") .permitAll() // 로그인은 누구나 가능, post 요청만 허용 .requestMatchers(HttpMethod.GET, \"/api/*/members/logout\") .permitAll() // 로그인은 누구나 가능, post 요청만 허용 .anyRequest().authenticated()).csrf(csrf -&gt; csrf.disable()) // csrf 토큰 끄기 .httpBasic(httpBasic -&gt; httpBasic.disable()) // httpBasic 로그인 방식 끄기 .formLogin(formLogin -&gt; formLogin.disable()) // 폼 로그인 방식 끄기 .sessionManagement(sessionManagement -&gt; sessionManagement.sessionCreationPolicy( SessionCreationPolicy.STATELESS)) .addFilterBefore( jwtAuthorizationFilter, //엑세스 토큰을 이용한 로그인 처리 UsernamePasswordAuthenticationFilter.class); return http.build(); } } jwtAuthorizationFilter 필터를 UsernamePasswordAuthenticationFilter 보다 먼저 실행하도록 설정한다. .addFilterBefore(jwtAuthorizationFilter, UsernamePasswordAuthenticationFilter.class); 이렇게 하면 모든 End Point 요청이 먼저 jwtAuthorizationFilter 필터를 거쳐서 토큰을 통해 접근을 허가 받는다. 이 때 특정 End Point(로그인, 로그아웃 등)은 제외 처리를 하여 검사하지 않도록 한다. 위의 jwtAuthorizationFilter 필터를 거치지 않은 End Point 요청은 UsernamePasswordAuthenticationFilter 필터를 거치게 된다. 필터 대상   :   로그인, 로그아웃 등   (JWT 필터에서 제외 받은 End Point) 다만 사전에 이 필터에 지정된 End Point는 모두 허용시킨다. 즉, 로그인, 로그아웃은 요청을 보내면 통과시킬 수 있다. JwtProvider에 verify() 메서드 추가하기 public boolean verify(String token) { try { Jwts.parserBuilder().setSigningKey(getSecretKey()).build().parseClaimsJws(token); return true; } catch (Exception e) { return false; } } 유효성 검증을 위한 메서드이다. JWT의 클레임(Claims) 데이터를 추출할 수 있는 경우 true를 반환하고 예외가 발생했다면 false를 반환 5. RefreshToken 및 로그아웃 구현🔆 회원가입 시 refreshToken 저장, 토큰 재발급 테스트 ApiV1MemberController @PostMapping(\"/login\") public RsData&lt;Void&gt; login(@Valid @RequestBody MemberRequest memberRequest, HttpServletResponse response) { Member member = memberService.getMember(memberRequest.getUsername()); // 토큰 생성 String token = jwtProvider.genAccessToken(member); // 응답 데이터에 accessToken 이름으로 토큰을 발급 Cookie cookie = new Cookie(\"accessToken\", token); cookie.setHttpOnly(true); cookie.setSecure(true); cookie.setPath(\"/\"); cookie.setMaxAge(60 * 60); response.addCookie(cookie); String refreshToken = member.getRefreshToken(); Cookie refreshTokenCookie = new Cookie(\"refreshToken\", refreshToken); refreshTokenCookie.setHttpOnly(true); refreshTokenCookie.setSecure(true); refreshTokenCookie.setPath(\"/\"); refreshTokenCookie.setMaxAge(60 * 60); response.addCookie(refreshTokenCookie); return new RsData&lt;&gt;(\"200\", \"로그인에 성공하였습니다.\"); } 최초의 로그인을 하면 사용자에게 AccessToken, RefreshToken을 모두 쿠키로 전달한다. member로 부터 DB에 저장된 refreshToken을 가져와서 새로운 쿠키를 만든다. 쿠키 옵션 설정   (AccessToken 쿠키 설정과 동일) 🔆 로그아웃 ApiV1MemberController @GetMapping(\"/logout\") public RsData&lt;Void&gt; logout(HttpServletResponse response) { Cookie cookie = new Cookie(\"accessToken\", null); cookie.setPath(\"/\"); cookie.setMaxAge(0); response.addCookie(cookie); Cookie refreshTokenCookie = new Cookie(\"refreshToken\", null); refreshTokenCookie.setPath(\"/\"); refreshTokenCookie.setMaxAge(0); response.addCookie(refreshTokenCookie); return new RsData&lt;&gt;(\"200\", \"로그아웃에 성공하였습니다.\"); } 방법은 쿠키를 다 없애는 것이다. 인증/인가를 쿠키로 하고 있기 때문이다. 기존에 쿠키를 설정하는 것과 동일하다. 다만 null을 넘긴다. 다른 쿠키 설정은 필요 없고 setPath()와 setMaxAge()만 0으로 설정한다. ⇒   쿠키가 제거된다. " }, { "title": "점프 투 스프링부트 2장", "url": "/posts/springboot-jpa-basic/", "categories": "개인 공부, Spring Boot, 기초", "tags": "JPA, Domain, Thymeleaf", "date": "2025-01-04 22:00:00 +0900", "snippet": " 2025/01/04 기존에 프로젝트 경험은 Mybatis와 React를 이용한 경험을 했지만 JPA와 Thymeleaf는 사용한 경험이 없다. 이를 해결하기 위해 기초 과정을 공부해본다. 참고   :   https://wikidocs.net/book/7601HTTP 오류 404 오류는 HTTP 오류 코드 중 하나로, 브라우저가 요청한 페이지...", "content": " 2025/01/04 기존에 프로젝트 경험은 Mybatis와 React를 이용한 경험을 했지만 JPA와 Thymeleaf는 사용한 경험이 없다. 이를 해결하기 위해 기초 과정을 공부해본다. 참고   :   https://wikidocs.net/book/7601HTTP 오류 404 오류는 HTTP 오류 코드 중 하나로, 브라우저가 요청한 페이지를 찾을 수 없다는 의미 요청한 URL과 매핑되는 메서드를 만들어야 한다. 500 오류는 브라우저가 http://localhost:8080/xxxx 요청했을 때 해당하는 클래스의 해당하는 메서드가 호출되긴 했지만 원래 URL과 매핑된 메서드는 결괏값을 리턴해야 하는데 아무 값도 리턴하지 않아 이와 같은 오류가 발생 반환 타입을 String으로 하고 @ResponseBody 애노테이션을 붙이지 않는다면 스프링부트는 문자열을 리턴하지 않고 리턴한 값에 해당하는 템플릿 파일을 찾는다. 405 오류는 ‘Method Not Allowed’라는 의미로, /question/create 처럼 해당 URL을 POST 방식으로는 처리할 수 없음을 나타낸다.ORM ORM은 SQL을 사용하지 않고 데이터베이스를 관리할 수 있는 도구 ORM은 데이터베이스의 테이블을 자바 클래스로 만들어 관리할 수 있다 SQL 쿼리문이란 데이터베이스에 데이터를 저장, 조회, 수정, 삭제 등을 하기 위해 작성하는 명령문이다. insertinto question (id, subject, content)values (1, '안녕하세요', '가입 인사드립니다 ^^'); insertinto question (id, subject, content)values (2, '질문 있습니다', 'ORM이 궁금합니다'); 하지만 ORM을 사용하면 이러한 쿼리문 대신 자바 코드로 다음처럼 작성할 수 있다. Question q1 =newQuestion(); q1.setId(1); q1.setSubject(\"안녕하세요\"); q1.setContent(\"가입 인사드립니다 ^^\"); this.questionRepository.save(q1); Question q2 =newQuestion(); q2.setId(2); q2.setSubject(\"질문 있습니다\"); q2.setContent(\"ORM이 궁금합니다\"); this.questionRepository.save(q2); 별도의 SQL 문법을 배우지 않아도 데이터베이스를 사용할 수 있기 때문에 매우 편리 ORM을 이용하면 MySQL, 오라클 DB, MS SQL과 같은 DBMS의 종류에 관계 없이 일관된 자바 코드를 사용할 수 있어서 프로그램을 유지·보수하기가 편리 코드 내부에서 안정적인 SQL 쿼리문을 자동으로 생성JPA란? 스프링 부트는 JPA(Java Persistence API)를 사용하여 데이터베이스를 관리 스프링 부트는 JPA를 ORM(Object-Relational Mapping) 기술의 표준으로 사용 JPA는 인터페이스 모음이므로, 이 인터페이스를 구현한 실제 클래스가 필 JPA를 구현한 실제 클래스에는 대표적으로 하이버네이트(Hibernate)가 있다. (하이버네이트는 JPA의 인터페이스를 구현한 실제 클래스이자 자바의 ORM 프레임워크) H2 데이터베이스 application.properties 파일 # DATABASE spring.h2.console.enabled=true spring.h2.console.path=/h2-console spring.datasource.url=jdbc:h2:~/local spring.datasource.driverClassName=org.h2.Driver spring.datasource.username=sa spring.datasource.password= spring.h2.console.enabled H2 콘솔에 접속할 것인지 여부 H2 콘솔은 H2 데이터베이스를 웹 UI로 보여 주는 것 spring.h2.console.path H2 콘솔로 접속하기 위한 URL 경로 spring.datasource.url 데이터베이스에 접속하기 위한 경로 =jdbc:h2:~/local 특정 위치에 만들겠다는 것 (여기서는 local = 홈폴더) =jdbc:h2:mem:chat_dev 메모리에 생성하겠다는 것 spring.datasource.driverClassName 데이터베이스에 접속할 때 사용하는 드라이버 클래스명 spring.datasource.username 데이터베이스의 사용자명   (사용자명으로 기본값인 sa로 설정) spring.datasource.password 데이터베이스의 비밀번호 (개발 용도로만 사용하므로 비밀번호를 설정하지 않고 비워 두었다) implementation이란? build.gradle 파일에서 작성한 implementation은 필요한 라이브러리 설치를 위해 가장 일반적으로 사용하는 설정이다. implementation은 해당 라이브러리가 변경되더라도 이 라이브러리와 연관된 모든 모듈을 컴파일하지 않고 변경된 내용과 관련이 있는 모듈만 컴파일하므로 프로젝트를 리빌드(rebuild)하는 속도가 빠르다. application.properties # JPA spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.H2Dialect spring.jpa.hibernate.ddl-auto=update spring.jpa.properties.hibernate.dialect 스프링 부트와 하이버네이트를 함께 사용할 때 필요한 설정 항목 표준 SQL이 아닌 하이버네이트만의 SQL을 사용할 때 필요한 항 하이버네이트의 org.hibernate.dialect.H2Dialect 클래스를 설정 Spring Boot가 자동으로 Dialect를 추론하기 때문에 생략할 수 있다 spring.jpa.hibernate.ddl-auto 엔티티를 기준으로 데이터의 테이블을 생성하는 규칙을 설정 none   :   엔티티가 변경되더라도 데이터베이스를 변경하지 않는다. update   :   엔티티의 변경된 부분만 데이터베이스에 적용한다. validate   :   엔티티와 테이블 간에 차이점이 있는지 검사만 한다. create   :   스프링 부트 서버를 시작할 때 테이블을 모두 삭제한 후 다시 생성한다. create-drop   :   create와 동일하지만 스프링 부트 서버를 종료할 때에도 테이블을 모두 삭제한다. 개발 환경에서는 보통 update 모드를 사용하고, 운영 환경에서는 none 또는 validate를 주로 사용한다. 엔티티 (Entity) 엔티티는 데이터베이스 테이블과 매핑되는 자바 클래스 엔티티를 모델 또는 도메인 모델이라고도 한다. 엔티티의 속성은 테이블의 열과 매핑이 된다. 질문 엔티티 속성 이름 설명 id 질문 데이터의 고유 번호 subject 질문 데이터의 제목 content 질문 데이터의 내용 createDate 질문 데이터를 작성한 일시 답변 엔티티 속성 이름 설명 id 답변 데이터의 고유 번호 question 질문 데이터 (어떤 질문의 답변인지 알아야 하므로 이 속성이 필요하다.) content 답변 데이터의 내용 createDate 답변 데이터를 작성한 일시 엔티티 만드는 방법 import java.time.LocalDateTime; import jakarta.persistence.Column; import jakarta.persistence.Entity; import jakarta.persistence.GeneratedValue; import jakarta.persistence.GenerationType; import jakarta.persistence.Id; import lombok.Getter; import lombok.Setter; @Getter @Setter @Entity public class Question { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; @Column(length = 200) private String subject; @Column(columnDefinition = \"TEXT\") private String content; private LocalDateTime createDate; } @Entity @Entity 애너테이션을 적용해야 스프링 부트가 클래스를 엔티티로 인식 롬복(Lombok)의 @Getter와 @Setter 애너테이션을 적용 Getter와 Setter를 자동 생성 @Id id 속성에 적용한 @Id 애너테이션은 id 속성을 기본키로 지정한다. @GeneratedValue @GeneratedValue 애너테이션을 적용하면 데이터를 저장할 때 해당 속성에 값을 일일이 입력하지 않아도 자동으로 1씩 증가하여 저장 strategy = GenerationType.IDENTITY 고유한 번호를 생성하는 방법을 지정하는 부분 GenerationType.IDENTITY는 해당 속성만 별도로 번호가 차례대로 늘어나도록 할 때 사용 strategy 옵션을 생략한다면 @GeneratedValue 애너테이션이 지정된 모든 속성에 번호를 차례로 생성하므로 순서가 일정한 고유 번호를 가질 수 없게 된다. (생략 시 1, 2, 3 이렇게 증가하는 것은 맞으나 아닐 수도 있다는 것) @Column 엔티티의 속성은 테이블의 열 이름과 일치하는데 열의 세부 설정을 위해 @Column 애너테이션을 사용한다. length 열의 길이를 설정할 때 사용하고   (여기서는 열의 길이를 200으로 정함) columnDefinition 열 데이터의 유형이나 성격을 정의할 때 사용한다. columnDefinition = \"TEXT\"는 말 그대로 ‘텍스트’를 열 데이터로 넣을 수 있음을 의미하고, 글자 수를 제한할 수 없는 경우에 사용 엔티티의 속성은 @Column 애너테이션을 사용하지 않더라도 테이블의 열로 인식한다. 테이블의 열로 인식하고 싶지 않다면 @Transient 애너테이션을 사용한다. @Transient 애너테이션은 엔티티의 속성을 테이블의 열로 만들지 않고 클래스의 속성 기능으로만 사용하고자 할 때 쓴다. 엔티티를 만들 때 Setter 메서드는 사용하지 않는다 일반적으로 엔티티를 만들 때에는 Setter 메서드를 사용하지 않기를 권한다. 왜냐하면 엔티티는 데이터베이스와 바로 연결되므로 데이터를 자유롭게 변경할 수 있는 Setter 메서드를 허용하는 것이 안전하지 않다고 판단하기 때문 엔티티는 생성자에 의해서만 엔티티의 값을 저장할 수 있게 하고, 데이터를 변경해야 할 경우에는 메서드를 추가로 작성하면 된다. 답변 엔티티package com.mysite.myapp;import jakarta.persistence.*;import lombok.Getter;import lombok.Setter;import java.time.LocalDateTime;@Entity@Getter@Setterpublic class Answer { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; @Column(columnDefinition = \"TEXT\") private String content; private LocalDateTime createDate; @ManyToOne private Question question;} 답변 엔티티의 경우 질문 엔티티를 참조하기 위해 question 속성을 추가한다. 그러나 엔티티를 속성으로 사용하기 위해서는 연결된 속성임을 표시해야 한다. @ManyToOne 애너테이션 현재 Entity가 많은 것이고 참조 Entity가 하나라는 뜻이다. ⇒   실제 DB에서는 외래키(FK) 관계 생성 ⇒   부모는 Question, 자식은 Answer 질문 Entity의 답변 Entity 역참조 package com.mysite.myapp; import java.time.LocalDateTime; import java.util.List; import jakarta.persistence.*; import lombok.Getter; import lombok.Setter; @Getter @Setter @Entity public class Question { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; @Column(length = 200) private String subject; @Column(columnDefinition = \"TEXT\") private String content; private LocalDateTime createDate; @OneToMany(mappedBy = \"question\", cascade = CascadeType.REMOVE) private List&lt;Answer&gt; answerList; } answerList를 Question 엔티티의 속성으로 추가하고 @OneToMany 애너테이션을 설정 이제 질문에서 답변을 참조하려면 question.getAnswerList()를 호출 mappedBy는 참조 엔티티의 속성명을 정의 Answer 엔티티에서 Question 엔티티를 참조한 속성인 question을 mappedBy에 전달해야 한다. 즉, Answer 엔티티에서 어떻게 정의했는지 알려주는 것 CascadeType.REMOVE 질문 하나에 답변이 여러 개 작성될 수 있다. 보통 게시판에서는 질문을 삭제하면 그에 달린 답변들도 함께 삭제된다 cascade = CascadeType.REMOVE를 사용하여 구현 H2 데이터베이스 결과 JPA에서 @OneToMany와 같은 컬렉션 필드는 데이터베이스 테이블에 직접 저장되지 않는다. 단순히 데이터베이스 테이블 간의 관계를 나타내기 위한 매핑 리포지터리 엔티티가 데이터베이스 테이블을 생성했다면, 리포지터리는 이와 같이 생성된 데이터베이스 테이블의 데이터들을 저장, 조회, 수정, 삭제 등을 할 수 있도록 도와주는 인터페이스 리포지터리로 만들기 위해 JpaRepository 인터페이스를 상속한다. JpaRepository JPA가 제공하는 인터페이스 중 하나 CRUD 작업을 처리하는 메서드들을 이미 내장하고 있다 JpaRepository&lt;Question, Integer&gt;는 Question 엔티티로 리포지터리를 생성한다는 의미 Question 엔티티의 기본키의 타입을 Integer 처럼 추가로 지정해야 한다. JUnit 리포지터리를 이용하여 데이터를 저장하려면 프론트단과 컨트롤러, 서비스 등이 필요하다. ⇒   하지만 JUnit을 사용하면 리포지터리만 개별적으로 실행해 테스트가 가능하다 JUnit은 자바의 테스트 프레임워크 리포지터리뿐만 아니라 소프트웨어 개발 시 테스트 작업을 수행할 때 많이 사용한다. build.gradle testImplementation 'org.junit.jupiter:junit-jupiter' testRuntimeOnly 'org.junit.platform:junit-platform-launcher' testRuntimeOnly   :   해당 라이브러리가 테스트 실행 시에만 사용됨 src/test/java의 MyappApplicationTests package com.mysite.myapp; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import java.time.LocalDateTime; @SpringBootTest class MyappApplicationTests { @Autowired private QuestionRepository questionRepository; @Test void testJpa() { Question q1 = new Question(); q1.setSubject(\"sbb가 무엇인가요?\"); q1.setContent(\"sbb에 대해서 알고 싶습니다.\"); q1.setCreateDate(LocalDateTime.now()); this.questionRepository.save(q1); // 첫번째 질문 저장 Question q2 = new Question(); q2.setSubject(\"스프링부트 모델 질문입니다.\"); q2.setContent(\"id는 자동으로 생성되나요?\"); q2.setCreateDate(LocalDateTime.now()); this.questionRepository.save(q2); // 두번째 질문 저장 } } 테스트를 진행할 리포지토리를 의존성으로 주입하여 테스트한다. @Autowired @Autowired 애너테이션을 해당 변수에 적용하면 스프링 부트가 questionRepository 객체를 자동으로 만들어 주입해준다. 개발 시 @Autowired보다는 생성자를 통한 객체 주입 방식을 권장 @Test @Test 애너테이션은 해당 메서드가 테스트 메서드임을 나타낸다. 클래스를 JUnit으로 실행하면 @Test 애너테이션이 붙은 testJpa 메서드가 실행된다. SELECT (목록) @Test void testJpa() { List&lt;Question&gt; all = this.questionRepository.findAll(); assertEquals(2, all.size()); Question q = all.get(0); assertEquals(\"sbb가 무엇인가요?\", q.getSubject()); } findAll()는 H2 콘솔에서 입력해 본 SELECT * FROM QUESTION과 같은 결과 assertEquals(기댓값, 실젯값) JPA 또는 데이터베이스에서 데이터를 올바르게 가져오는지를 확인하려는 것 SELECT (조회) @Test void testJpa() { Optional&lt;Question&gt; oq = this.questionRepository.findById(1); if(oq.isPresent()) { Question q = oq.get(); assertEquals(\"sbb가 무엇인가요?\", q.getSubject()); } } findById 메서드   (내장) 리턴 타입   :   Optional 가져오는 것이 null 일 수도 있기 때문에 사용 Optional 클래스는 null 값을 유연하게 처리하기 위하여 사용 해당 클래스의 isPresent()로 값이 존재하는지 확인할 수 있다 존재한다면, get()으로 실제 값을 가져온다. findBySubject 메서드   (내장 X) package com.mysite.myapp; import org.springframework.data.jpa.repository.JpaRepository; import org.springframework.stereotype.Repository; @Repository public interface QuestionRepository extends JpaRepository&lt;Question, Integer&gt; { Question findBySubject(String subject); } @Test void testJpa() { Question q = this.questionRepository.findBySubject(\"sbb가 무엇인가요?\"); assertEquals(1, q.getId()); } 기본적으로 제공하는 메서드가 아니다. ⇒   Repository 인터페이스를 수정해야 한다 JPA에서 Repository의 메서드명을 분석하여 쿼리를 만들고 실행한다. findBy   +   엔티티의 속성명 application.properties # JPA spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.H2Dialect spring.jpa.hibernate.ddl-auto=update spring.jpa.properties.hibernate.format_sql=true spring.jpa.properties.hibernate.show_sql=true 실제 데이터베이스에서는 어떤 쿼리문이 실행되는지 Console 로그에서 확인하는 방법이다. findBySubjectAndContent 메서드   (내장 X) @Repository public interface QuestionRepository extends JpaRepository&lt;Question, Integer&gt; { Question findBySubject(String subject); Question findBySubjectAndContent(String subject, String content); } @Test void testJpa() { Question q = this.questionRepository.findBySubjectAndContent( \"sbb가 무엇인가요?\", \"sbb에 대해서 알고 싶습니다.\"); assertEquals(1, q.getId()); } 마찬가지로 기본적으로 제공하는 메서드가 아니다. SQL문의 And를 메서드명에 추가하여 만들 수 있다. SQL 연산자와 Repository의 메서드 https://docs.spring.io/spring-data/jpa/reference/jpa/query-methods.html And findBySubjectAndContent(String subject, String content) Or findBySubjectOrContent(String subject, String content) Between findByCreateDateBetween(LocalDateTime fromDate, LocalDateTime toDate) LessThan (작은) findByIdLessThan(Integer id) GreaterThanEqual (크거나 같은) findByIdGreaterThanEqual(Integer id) Like findBySubjectLike(String subject) In (주어진 배열에 포함되는 애들만) findBySubjectIn(String[] subjects) OrderBy findBySubjectOrderByCreateDateAsc(String subject) findBySubjectLike(String subject) public interface QuestionRepository extends JpaRepository&lt;Question, Integer&gt; { Question findBySubject(String subject); Question findBySubjectAndContent(String subject, String content); List&lt;Question&gt; findBySubjectLike(String subject); } @Test void testJpa() { List&lt;Question&gt; qList = this.questionRepository.findBySubjectLike(\"sbb%\"); Question q = qList.get(0); assertEquals(\"sbb가 무엇인가요?\", q.getSubject()); } sbb%   :   ‘sbb’로 시작하는 문자열 %sbb   :   ‘sbb’로 끝나는 문자열 %sbb%   :   ‘sbb’를 포함하는 문자열 assertTrue() 파라미터로 받은 값이 true인지 테스트하는 것. Repository.count() 테이블 행의 전체 개수를 반환 답변 데이터를 통해 질문 데이터 찾기 vs 질문 데이터를 통해 답변 데이터 찾기 a.getQuestion() a는 답변 객체 반대의 경우, @Test void testJpa() { Optional&lt;Question&gt; oq = this.questionRepository.findById(2); assertTrue(oq.isPresent()); Question q = oq.get(); List&lt;Answer&gt; answerList = q.getAnswerList(); assertEquals(1, answerList.size()); assertEquals(\"네 자동으로 생성됩니다.\", answerList.get(0).getContent()); } 오류 발생 먼저 Id가 2인 질문을 조회하고 이후에 해당 질문의 답변을 가져온다. 그러나, Id로 질문을 가져오고 나서 DB 세션이 끊어지기 때문에 오류가 발생한다. DB 세션 스피링부트 애플리케이션과 데이터베이스 간의 연결 이렇게 데이터를 필요한 시점에 가져오는 방식을 지연(Lazy) 방식이라 한다. 반대로 조회할 때 미리 answer 리스트를 모두 가져오는 방식은 즉시(Eager) 방식이라 한다. @OneToMany, @ManyToOne 애너테이션의 옵션으로 fetch=FetchType.LAZY 또는 fetch=FetchType.EAGER처럼 가져오는 방식을 설정할 수 있다. 실제로 JPA 프로그램을 실행 시 DB 세션은 종료되지 않기 때문에 오류가 발생하지 않는다. 테스트 코드에서는 @Transactional 애너테이션으로 유지할 수 있다. 서비스 (Service) 서비스가 필요한 이유 Service는 스프링에서 데이터 처리를 위해 작성하는 클래스 복잡한 코드를 모듈화할 수 있다 Entity 객체를 DTO 객체로 변환할 수 있다. 왜냐하면 엔티티 객체에는 민감한 데이터가 포함될 수 있는데 민감한 데이터가 노출될 위험이 있기 때문 Thymeleaf questoin_list.html &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;제목&lt;/th&gt; &lt;th&gt;작성일시&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr th:each=\"question : ${questionList}\"&gt; &lt;td th:text=\"${question.subject}\"&gt;&lt;/td&gt; &lt;td th:text=\"${question.createDate}\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; th:는 타임리프에서 사용하는 속성임을 나타낸다. &lt;tr th:each=\"question : ${questionList}\"&gt; QuestionController의 list 메서드에서 조회한 질문 목록 데이터를 ‘questionList’라는 이름으로 Model 객체에 저장 @GetMapping(\"/question/list\") public String list(Model model) { List&lt;Question&gt; questionList = questionService.getQuestionList(); model.addAttribute(\"questionList\", questionList); return \"domain/question/question_list\"; } 타임리프는 Model 객체에 저장한 questionList를 ${questionList}로 읽을 수 있다 &lt;td th:text=\"${question.subject}\"&gt;&lt;/td&gt; Thymeleaf 문법 분기문 (if 등) th:if=\"${question != null}” 반복문 (for 등) th:each=\"question : ${questionList}” th:each=\"question, loop : ${questionList}” loop.index: 루프의 순서(루프의 반복 순서, 0부터 1씩 증가) loop.count: 루프의 순서(루프의 반복 순서, 1부터 1씩 증가) loop.size: 반복 객체의 요소 개수(예를 들어 questionList의 요소 개수) loop.first: 루프의 첫 번째 순서인 경우 true loop.last: 루프의 마지막 순서인 경우 true loop.odd: 루프의 홀수 번째 순서인 경우 true loop.even: 루프의 짝수 번째 순서인 경우 true loop.current: 현재 대입된 객체(여기서는 question과 동일) 텍스트 th:text=\"${question.subject}” 텍스트는 th:text 속성 대신에 다음처럼 대괄호를 사용하여 값을 직접 출력할 수 있다 &lt;tr th:each=\"question : ${questionList}\"&gt; &lt;td&gt;[[${question.subject}]]&lt;/td&gt; &lt;td&gt;[[${question.createDate}]]&lt;/td&gt; &lt;/tr&gt; 링크 ★```java&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;제목&lt;/th&gt; &lt;th&gt;작성일시&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr th:each=\"question : ${questionList}\"&gt; &lt;td th:text=\"${question.subject}\"&gt;&lt;/td&gt; &lt;td th:text=\"${question.createDate}\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt;``````java&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;제목&lt;/th&gt; &lt;th&gt;작성일시&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr th:each=\"question, index : ${questionList}\"&gt; &lt;td&gt; &lt;a th:href=\"@{|/question/detail/${question.id}|}\" th:text=\"${question.subject}\"&gt;&lt;/a&gt; &lt;/td&gt; &lt;td th:text=\"${question.createDate}\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt;```- 링크의 URL은 &lt;span class=\"back\"&gt;반드시 `@{`와 `}` 문자 사이에 입력&lt;/span&gt;해야 한다- &lt;span class=\"red line\"&gt;좌우에 `|` 없이 다음과 같이 사용하면 오류&lt;/span&gt; 타임리프에서는 `/question/detail/`과 같은 문자열과 `${question.id}`와 같은 자바 객체의 값을 더할 때는 반드시 다음처럼 `|`로 좌우를 감싸 주어야 한다 `&lt;a th:href=\"@{|/question/detail/${question.id}|}\" th:text=\"${question.subject}\"&gt;&lt;/a&gt;` 상세 페이지 예시 &lt;h1 th:text=\"${question.subject}\"&gt;&lt;/h1&gt; &lt;div th:text=\"${question.content}\"&gt;&lt;/div&gt; 상세 페이지 만들기public class QuestionService { (... 생략 ...) public Question getQuestion(Integer id) { Optional&lt;Question&gt; question = this.questionRepository.findById(id); if (question.isPresent()) { return question.get(); } else { throw new DataNotFoundException(\"question not found\"); } }} DataNotFoundException.java import org.springframework.http.HttpStatus; import org.springframework.web.bind.annotation.ResponseStatus; @ResponseStatus(value = HttpStatus.NOT_FOUND, reason = \"entity not found\") public class DataNotFoundException extends RuntimeException { private static final long serialVersionUID = 1L; public DataNotFoundException(String message) { super(message); } } 특정 엔티티 또는 데이터를 찾을 수 없을 때 발생시키는 예외 클래스 이 예외가 발생하면 스프링 부트는 설정된 HTTP 상태 코드(HttpStatus.NOT_FOUND)와 이유(\"entity not found\")를 포함한 응답을 생성하여 클라이언트에게 반환 404 오류(NOT_FOUND)를 반환 RuntimeException 클래스를 상속하는 것은 사용자 정의 예외 클래스를 정의하는 방법 중 하나 @ResponseStatus 컨트롤러에서 던져진 예외를 처리하면서 HTTP 응답 상태 코드를 지정하는 데 사용 value 속성   :   반환할 HTTP 상태 코드를 설정 reason 속성   :   응답에 포함될 메시지를 설정 입력 폼 만들기&lt;h1 th:text=\"${question.subject}\"&gt;&lt;/h1&gt;&lt;div th:text=\"${question.content}\"&gt;&lt;/div&gt;&lt;form th:action=\"@{|/answer/create/${question.id}|}\" method=\"post\"&gt; &lt;textarea name=\"content\" id=\"content\" rows=\"15\"&gt;&lt;/textarea&gt; &lt;input type=\"submit\" value=\"답변등록\"&gt;&lt;/form&gt; &lt;form th:action=\"@{|/answer/create/${question.id}|}\" method=\"post\"&gt; 해당 URL로 POST 요청을 보내는 것 submit 버튼 생성 AnswerController, AnswerService @Controller @RequiredArgsConstructor @RequestMapping(\"/answer\") public class AnswerController { private final QuestionService questionService; private final AnswerService answerService; @PostMapping(\"create/{id}\") public String createAnswer( @PathVariable Integer id, @RequestParam String content, Model model) { Question question = questionService.getQuestion(id); answerService.create(question, content); return String.format(\"redirect:/question/detail/%s\", id); } } @Service @RequiredArgsConstructor public class AnswerService { private final AnswerRepository answerRepository; public void create(Question question, String content) { Answer answer = new Answer(); answer.setContent(content); answer.setCreateDate(LocalDateTime.now()); answer.setQuestion(question); this.answerRepository.save(answer); } } 답변 표시 UI 수정 question_detail.html &lt;h1 th:text=\"${question.subject}\"&gt;&lt;/h1&gt; &lt;div th:text=\"${question.content}\"&gt;&lt;/div&gt; &lt;form th:action=\"@{|/answer/create/${question.id}|}\" method=\"post\"&gt; &lt;textarea name=\"content\" id=\"content\" rows=\"15\"&gt;&lt;/textarea&gt; &lt;input type=\"submit\" value=\"답변등록\"&gt; &lt;/form&gt; &lt;h1 th:text=\"${question.subject}\"&gt;&lt;/h1&gt; &lt;div th:text=\"${question.content}\"&gt;&lt;/div&gt; &lt;h5 th:text=\"|${#lists.size(question.answerList)}개의 답변이 있습니다.|\"&gt;&lt;/h5&gt; &lt;div&gt; &lt;ul&gt; &lt;li th:each=\"answer : ${question.answerList}\" th:text=\"${answer.content}\"&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;form th:action=\"@{|/answer/create/${question.id}|}\" method=\"post\"&gt; &lt;textarea name=\"content\" id=\"content\" rows=\"15\"&gt;&lt;/textarea&gt; &lt;input type=\"submit\" value=\"답변등록\"&gt; &lt;/form&gt; 추가 부분 (1) &lt;div&gt; &lt;ul&gt; &lt;li th:each=\"answer : ${question.answerList}\" th:text=\"${answer.content}\"&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; th:each로 반복문을 돌며 answer를 꺼내서 해당 값에서 content를 뽑아서 출력한다. 추가 부분 (2) &lt;h5 th:text=\"|${#lists.size(question.answerList)}개의 답변이 있습니다.|\"&gt;&lt;/h5&gt; #lists.size(객체) 타임리프에서 제공하는 기능으로, 해당 객체의 길이를 반환 ★ 화면 꾸미기 /resources/static/style.css textarea { width:100%; } input[type=submit] { margin-top:10px; } question_detail.html &lt;link rel=\"stylesheet\" type=\"text/css\" th:href=\"@{/style.css}\"&gt; 스타일시트 파일을 상세 페이지 템플릿에 적용 static 디렉터리에 style.css 파일이 위치하지만 /static/style.css 대신 /style.css로 작성해야 한다. ⇒   왜냐하면 static 디렉터리가 루트 디렉터리이므로 적을 필요가 없기 때문 부트스트랩 활용하기 부트스트랩 다운로드 https://getbootstrap.com/docs/5.3/getting-started/download/ Compiled CSS and JS의 Download bootstrap.min.css 파일을 복사하여 스태틱 디렉터리에 저장 기존의 Thymeleaf 템플릿에 부트스트랩 적용하기 question_list.html &lt;link rel=\"stylesheet\" type=\"text/css\" th:href=\"@{/bootstrap.min.css}\"&gt; &lt;div class=\"container my-3\"&gt; &lt;table class=\"table\"&gt; &lt;thead class=\"table-dark\"&gt; &lt;tr&gt; &lt;th&gt;번호&lt;/th&gt; &lt;th&gt;제목&lt;/th&gt; &lt;th&gt;작성일시&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr th:each=\"question, loop : ${questionList}\"&gt; &lt;td th:text=\"${loop.count}\"&gt;&lt;/td&gt; &lt;td&gt; &lt;a th:href=\"@{|/question/detail/${question.id}|}\" th:text=\"${question.subject}\"&gt;&lt;/a&gt; &lt;/td&gt; &lt;td th:text=\"${#temporals.format(question.createDate, 'yyyy-MM-dd HH:mm')}\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; 테이블 항목으로 ‘번호’를 추가했다. 번호는 loop.count를 사용하여 표시 loop.count는 questionList의 항목을 th:each로 반복할 때 현재의 순서 날짜를 보기 좋게 출력하기 위해 타임리프의 #temporals.format 기능을 사용 #temporals.format은 #temporals.format(날짜 객체, 날짜 포맷)와 같이 사용 class=\"container my-3\", class=\"table\", class=\"table-dark 등은 bootstrap.min.css에 이미 정의되어 있는 클래스들로 간격을 조정하고 테이블에 스타일을 지정하는 용도로 사용 question_detail.html &lt;link rel=\"stylesheet\" type=\"text/css\" th:href=\"@{/bootstrap.min.css}\"&gt; &lt;div class=\"container my-3\"&gt; &lt;!-- 질문 --&gt; &lt;h2 class=\"border-bottom py-2\" th:text=\"${question.subject}\"&gt;&lt;/h2&gt; &lt;div class=\"card my-3\"&gt; &lt;div class=\"card-body\"&gt; &lt;div class=\"card-text\" style=\"white-space: pre-line;\" th:text=\"${question.content}\"&gt;&lt;/div&gt; &lt;div class=\"d-flex justify-content-end\"&gt; &lt;div class=\"badge bg-light text-dark p-2 text-start\"&gt; &lt;div th:text=\"${#temporals.format(question.createDate, 'yyyy-MM-dd HH:mm')}\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 답변의 갯수 표시 --&gt; &lt;h5 class=\"border-bottom my-3 py-2\" th:text=\"|${#lists.size(question.answerList)}개의 답변이 있습니다.|\"&gt;&lt;/h5&gt; &lt;!-- 답변 반복 시작 --&gt; &lt;div class=\"card my-3\" th:each=\"answer : ${question.answerList}\"&gt; &lt;div class=\"card-body\"&gt; &lt;div class=\"card-text\" style=\"white-space: pre-line;\" th:text=\"${answer.content}\"&gt;&lt;/div&gt; &lt;div class=\"d-flex justify-content-end\"&gt; &lt;div class=\"badge bg-light text-dark p-2 text-start\"&gt; &lt;div th:text=\"${#temporals.format(answer.createDate, 'yyyy-MM-dd HH:mm')}\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 답변 반복 끝 --&gt; &lt;!-- 답변 작성 --&gt; &lt;form th:action=\"@{|/answer/create/${question.id}|}\" method=\"post\" class=\"my-3\"&gt; &lt;textarea name=\"content\" id=\"content\" rows=\"10\" class=\"form-control\"&gt;&lt;/textarea&gt; &lt;input type=\"submit\" value=\"답변등록\" class=\"btn btn-primary my-2\"&gt; &lt;/form&gt; &lt;/div&gt; 부트스트랩의 card 컴포넌트를 사용 어떤 내용을 그룹화하여 보여 줄 때 사용 부트스트랩 클래스 설명 card, card-body, card-text card 컴포넌트를 적용하는 클래스들이다. badge badge 컴포넌트를 적용하는 클래스이다. form-control 텍스트 창에 form 컴포넌트를 적용하는 클래스이다. border-bottom 아래 방향 테두리 선을 만드는 클래스이다. my-3 상하 마진값으로 3을 지정하는 클래스이다. py-2 상하 패딩값으로 2를 지정하는 클래스이다. p-2 상하좌우 패딩값으로 2를 지정하는 클래스이다. d-flex justify-content-end HTML 요소를 오른쪽으로 정렬하는 클래스이다. bg-light 연회색으로 배경을 지정하는 클래스이다. text-dark 글자색을 검은색으로 지정하는 클래스이다. text-start 글자를 왼쪽으로 정렬하는 클래스이다. btn btn-primary 버튼 컴포넌트를 적용하는 클래스이다. style=\"white-space: pre-line;\"은 CSS 스타일 속성으로, 사용자가 입력한 대로 줄 바꿈이 적용 표준 HTML 구조 지금까지의 .html 파일들은 표준 HTML 구조로 작성되지 않았다. 표준 HTML 구조 &lt;!doctype html&gt; &lt;html lang=\"ko\"&gt; &lt;head&gt; &lt;!-- Required meta tags --&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"&gt; &lt;!-- Bootstrap CSS --&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" th:href=\"@{/bootstrap.min.css}\"&gt; &lt;!-- sbb CSS --&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" th:href=\"@{/style.css}\"&gt; &lt;title&gt;Hello, sbb!&lt;/title&gt; &lt;/head&gt; &lt;body&gt; (... 생략 ...) &lt;/body&gt; &lt;/html&gt; 표준 HTML 문서의 구조는 html, head, body 요소가 있어야 하며, CSS 파일은 &lt;head&gt; 태그 안에 링크되어야 한다. 또한 &lt;head&gt; 태그 안에는 meta, title 요소 등이 포함되어야 한다 템플릿에 표준 HTML 구조 적용하기 각각의 .html 파일 모두에 중복되는 내용이 존재 ⇒   템플릿 상속 사용 template/domain/layout.html &lt;!doctype html&gt; &lt;html lang=\"ko\"&gt; &lt;head&gt; &lt;!-- Required meta tags --&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"&gt; &lt;!-- Bootstrap CSS --&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" th:href=\"@{/bootstrap.min.css}\"&gt; &lt;!-- sbb CSS --&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" th:href=\"@{/style.css}\"&gt; &lt;title&gt;Hello, sbb!&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 기본 템플릿 안에 삽입될 내용 Start --&gt; &lt;th:block layout:fragment=\"content\"&gt;&lt;/th:block&gt; &lt;!-- 기본 템플릿 안에 삽입될 내용 End --&gt; &lt;/body&gt; &lt;/html&gt; &lt;th:block layout:fragment=\"content\"&gt;&lt;/th:block&gt; layout.html을 상속한 템플릿에서 개별적으로 구현해야 하는 영역 상속 받고 이 영역만 수정해도 표준 HTML 문서가 된다. template/domain/question/question_list.html   /   question_detail &lt;html layout:decorate=\"~{layout}\"&gt; &lt;div layout:fragment=\"content\" class=\"container my-3\"&gt; &lt;table class=\"table\"&gt; &lt;thead class=\"table-dark\"&gt; &lt;tr&gt; &lt;th&gt;번호&lt;/th&gt; &lt;th&gt;제목&lt;/th&gt; &lt;th&gt;작성일시&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr th:each=\"question, loop : ${questionList}\"&gt; &lt;td th:text=\"${loop.count}\"&gt;&lt;/td&gt; &lt;td&gt; &lt;a th:href=\"@{|/question/detail/${question.id}|}\" th:text=\"${question.subject}\"&gt;&lt;/a&gt; &lt;/td&gt; &lt;td th:text=\"${#temporals.format(question.createDate, 'yyyy-MM-dd HH:mm')}\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/html&gt; &lt;html layout:decorate=\"~{layout}\"&gt; &lt;div layout:fragment=\"content\" class=\"container my-3\"&gt; &lt;!-- 질문 --&gt; &lt;h2 class=\"border-bottom py-2\" th:text=\"${question.subject}\"&gt;&lt;/h2&gt; &lt;div class=\"card my-3\"&gt; &lt;div class=\"card-body\"&gt; &lt;div class=\"card-text\" style=\"white-space: pre-line;\" th:text=\"${question.content}\"&gt;&lt;/div&gt; &lt;div class=\"d-flex justify-content-end\"&gt; &lt;div class=\"badge bg-light text-dark p-2 text-start\"&gt; &lt;div th:text=\"${#temporals.format(question.createDate, 'yyyy-MM-dd HH:mm')}\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 답변의 갯수 표시 --&gt; &lt;h5 class=\"border-bottom my-3 py-2\" th:text=\"|${#lists.size(question.answerList)}개의 답변이 있습니다.|\"&gt;&lt;/h5&gt; &lt;!-- 답변 반복 시작 --&gt; &lt;div class=\"card my-3\" th:each=\"answer : ${question.answerList}\"&gt; &lt;div class=\"card-body\"&gt; &lt;div class=\"card-text\" style=\"white-space: pre-line;\" th:text=\"${answer.content}\"&gt;&lt;/div&gt; &lt;div class=\"d-flex justify-content-end\"&gt; &lt;div class=\"badge bg-light text-dark p-2 text-start\"&gt; &lt;div th:text=\"${#temporals.format(answer.createDate, 'yyyy-MM-dd HH:mm')}\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 답변 반복 끝 --&gt; &lt;!-- 답변 작성 --&gt; &lt;form th:action=\"@{|/answer/create/${question.id}|}\" method=\"post\" class=\"my-3\"&gt; &lt;textarea name=\"content\" id=\"content\" rows=\"10\" class=\"form-control\"&gt;&lt;/textarea&gt; &lt;input type=\"submit\" value=\"답변등록\" class=\"btn btn-primary my-2\"&gt; &lt;/form&gt; &lt;/div&gt; &lt;/html&gt; &lt;html layout:decorate=\"~{layout}\"&gt; 타임리프의 layout:decorate 템플릿의 레이아웃(부모 템플릿, 여기서는 layout.html)으로 사용할 템플릿을 설정 속성값인 ~{layout}이 바로 layout.html 파일을 의미 &lt;div layout:fragment=\"content\" class=\"container my-3\"&gt; 이 &lt;div&gt; 내부의 것이 이동하는 것이다. 부모 템플릿인 layout.html &lt;th:block layout:fragment=\"content\"&gt;&lt;/th:block&gt; 부모 템플릿의 th:block 요소의 내용이 자식 템플릿의 div 요소의 내용으로 교체된다 질문 등록 버튼 만들기 question_list.html &lt;a th:href=\"@{/question/create}\" class=\"btn btn-primary\"&gt;질문 등록하기&lt;/a&gt; 이 1줄을 추가한다. URL 매핑하기   (/question/create) QuestionController @GetMapping(\"/create\") public String questionCreate() { return \"question_form\"; } question_form.html &lt;html layout:decorate=\"~{layout}\"&gt; &lt;div layout:fragment=\"content\" class=\"container\"&gt; &lt;h5 class=\"my-3 border-bottom pb-2\"&gt;질문등록&lt;/h5&gt; &lt;form th:action=\"@{/question/create}\" method=\"post\"&gt; &lt;div class=\"mb-3\"&gt; &lt;label for=\"subject\" class=\"form-label\"&gt;제목&lt;/label&gt; &lt;input type=\"text\" name=\"subject\" id=\"subject\" class=\"form-control\"&gt; &lt;/div&gt; &lt;div class=\"mb-3\"&gt; &lt;label for=\"content\" class=\"form-label\"&gt;내용&lt;/label&gt; &lt;textarea name=\"content\" id=\"content\" class=\"form-control\" rows=\"10\"&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;input type=\"submit\" value=\"저장하기\" class=\"btn btn-primary my-2\"&gt; &lt;/form&gt; &lt;/div&gt; &lt;/html&gt; 그러나 저장하기 버튼을 누르면 405 오류 발생 ‘Method Not Allowed’라는 의미로, /question/create URL을 POST 방식으로는 처리할 수 없음을 나타낸다 ⇒   POST 처리를 추가한다. @PostMapping(\"/create\") public String questionCreate( @RequestParam(value=\"subject\") String subject, @RequestParam(value=\"content\") String content) { return \"redirect:/question/list\"; } 문제 질문을 등록할 때 비어 있는 값으로도 등록할 수 있다 ⇒   Form 클래스를 생성하여 제어한다. URL 루트 URL 서버의 URL을 요청할 때 도메인명 뒤에 아무런 주소도 덧붙이지 않는 URL을 루트 URL [ex] http://localhost:8080 google.com MainController @Controller public class MainController { @GetMapping(\"/\") public String index() { return \"redirect:/question/list\"; } } 루트 URL로 들어오면 /question/list로 보내는 것 리다이렉트란 클라이언트가 요청하면 새로운 URL로 전송하는 것 Form 클래스Spring Boot Validation 라이브러리 build.gradle dependencies { (... 생략 ...) implementation 'org.springframework.boot:spring-boot-starter-validation' } Spring Boot Validation 라이브러리의 기능 항목 설명 @Size 문자 길이를 제한한다. @NotNull Null을 허용하지 않는다. @NotEmpty Null 또는 빈 문자열(““)을 허용하지 않는다. @Past 과거 날짜만 입력할 수 있다. @Future 미래 날짜만 입력할 수 있다. @FutureOrPresent 미래 또는 오늘 날짜만 입력할 수 있다. @Max 최댓값 이하의 값만 입력할 수 있도록 제한한다. @Min 최솟값 이상의 값만 입력할 수 있도록 제한한다. @Pattern 입력값을 정규식 패턴으로 검증한다. 보다 많은 기능(https://beanvalidation.org/) Form 클래스 생성 /question/QuestionForm.java import jakarta.validation.constraints.NotEmpty; import jakarta.validation.constraints.Size; import lombok.Getter; import lombok.Setter; @Getter @Setter public class QuestionForm { @NotEmpty(message=\"제목은 필수항목입니다.\") @Size(max=200) private String subject; @NotEmpty(message=\"내용은 필수항목입니다.\") private String content; } @NotEmpty 해당 값이 Null 또는 빈 문자열(““)을 허용하지 않음을 의미 message는 검증이 실패할 경우 화면에 표시할 오류 메시지 @Size max=200은 최대 길이가 200 바이트(byte)를 넘으면 안 된다는 의미 폼 클래스는 입력값 검증할 때뿐만 아니라 입력 항목을 바인딩할 때도 사용한다. question_form.html 템플릿의 입력 항목인 subject와 content가 폼 클래스의 subject, content 속성과 바인딩된다. 컨트롤러에 전송하기 QuestionController.java @PostMapping(\"/create\") public String questionCreate( @Valid QuestionForm questionForm, BindingResult bindingResult) { if (bindingResult.hasErrors()) { return \"domain/question/question_form\"; } questionService.createQuestion(questionForm.getSubject(), questionForm.getContent()); return \"redirect:/question/list\"; } questionCreate() 메서드의 매개변수를 subject, content 대신 QuestionForm 객체로 변경 subject, content 항목을 지닌 폼이 전송되면 QuestionForm의 subject, content 속성이 자동으로 바인딩된다 (이렇게 이름이 동일하면 함께 연결되어 묶이는 것이 바로 폼의 바인딩 기능이다) @Valid 애너테이션 QuestionForm의 @NotEmpty, @Size 등으로 설정한 검증 기능이 동작한다. BindingResult 매개변수 ★ @Valid 애너테이션으로 검증이 수행된 결과를 의미하는 객체 BindingResult 매개변수는 항상 @Valid 매개변수 바로 뒤에 위치해야 한다 ⇒   아니라면 입력값 검증 실패 시 400 오류 발생 questionCreate 메서드는 bindResult.hasErrors()를 호출 ⇒   오류가 있는 경우에는 다시 제목과 내용을 작성하는 화면으로 돌아가도록 설정 하지만 QuestionForm에 설정한 ‘제목은 필수 항목입니다.’와 같은 오류 메시지는 보이지 않는다. 검증에 실패했다는 오류 메시지 보여주기 ⭐⭐ /templates/question_form.html &lt;html layout:decorate=\"~{layout}\"&gt; &lt;div layout:fragment=\"content\" class=\"container\"&gt; &lt;h5 class=\"my-3 border-bottom pb-2\"&gt;질문등록&lt;/h5&gt; &lt;form th:action=\"@{/question/create}\" th:object=\"${questionForm}\" method=\"post\"&gt; &lt;div class=\"alert alert-danger\" role=\"alert\" th:if=\"${#fields.hasAnyErrors()}\"&gt; &lt;div th:each=\"err : ${#fields.allErrors()}\" th:text=\"${err}\" /&gt; &lt;/div&gt; &lt;div class=\"mb-3\"&gt; &lt;label for=\"subject\" class=\"form-label\"&gt;제목&lt;/label&gt; &lt;input type=\"text\" name=\"subject\" id=\"subject\" class=\"form-control\"&gt; &lt;/div&gt; &lt;div class=\"mb-3\"&gt; &lt;label for=\"content\" class=\"form-label\"&gt;내용&lt;/label&gt; &lt;textarea name=\"content\" id=\"content\" class=\"form-control\" rows=\"10\"&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;input type=\"submit\" value=\"저장하기\" class=\"btn btn-primary my-2\"&gt; &lt;/form&gt; &lt;/div&gt; &lt;/html&gt; 검증에 실패할 경우 오류 메시지를 출력할 수 있도록 수정했다. &lt;form th:action=\"@{/question/create}\" th:object=\"${questionForm}\" method=\"post\"&gt; &lt;div class=\"alert alert-danger\" role=\"alert\" th:if=\"${#fields.hasAnyErrors()}\"&gt; &lt;div th:each=\"err : ${#fields.allErrors()}\" th:text=\"${err}\" /&gt; &lt;/div&gt; #fields.hasAnyErrors()가 true라면 QuestionForm 검증이 실패한 것 #fields.allErrors()에는 오류의 내용이 담겨 있다. 부트스트랩의 alert alert-danger 클래스를 사용하여 오류 메시지가 붉은 색으로 표시되도록 설정 오류를 표시하려면 타임리프의 th:object 속성이 반드시 필요 &lt;form&gt;의 입력 항목들이 QuestionForm과 연결된다는 점을 타임리프에 알려주는 역할을 한다. 그러나 오류 발생 th:object 속성을 추가한 것에 따른 GetMapping으로 매핑한 메서드도 변경해야 한다. 기존의 메서드 @GetMapping(\"create\") public String create() { return \"domain/question/question_form\"; } QuestionController.java @GetMapping(\"/create\") public String questionCreate(QuestionForm questionForm) { return \"domain/question/question_form\"; } @GetMapping으로 매핑한 questionCreate 메서드에 매개변수로 QuestionForm 객체를 추가 이렇게 하면 이제 GET 방식에서도 question_form 템플릿에 QuestionForm 객체가 전달된다. ⇒   QuestionForm과 같이 매개변수로 바인딩한 객체는 Model 객체로 전달하지 않아도 템플릿에서 사용할 수 있다. 즉, &lt;form th:object=\"${questionForm}\"&gt;가 사용된 경우, GET 요청으로 페이지를 렌더링할 때도 폼 객체(questionForm)가 필요하다. ⭐ th:object는 HTML 폼과 서버의 폼 객체를 매핑하기 때문이다. 또 다른 오류 : 알맞은 값도 오류 발생 시 값이 사라짐 제목을 입력하고 내용을 비워 둔 채로 [저장하기] 버튼을 누르면 오류 메시지가 나타남과 동시에 이미 입력한 제목도 사라진다 question_formhtml &lt;html layout:decorate=\"~{layout}\"&gt; &lt;div layout:fragment=\"content\" class=\"container\"&gt; &lt;h5 class=\"my-3 border-bottom pb-2\"&gt;질문등록&lt;/h5&gt; &lt;form th:action=\"@{/question/create}\" th:object=\"${questionForm}\" method=\"post\"&gt; &lt;div class=\"alert alert-danger\" role=\"alert\" th:if=\"${#fields.hasAnyErrors()}\"&gt; &lt;div th:each=\"err : ${#fields.allErrors()}\" th:text=\"${err}\" /&gt; &lt;/div&gt; &lt;div class=\"mb-3\"&gt; &lt;label for=\"subject\" class=\"form-label\"&gt;제목&lt;/label&gt; &lt;input type=\"text\" th:field=\"*{subject}\" class=\"form-control\"&gt; &lt;/div&gt; &lt;div class=\"mb-3\"&gt; &lt;label for=\"content\" class=\"form-label\"&gt;내용&lt;/label&gt; &lt;textarea th:field=\"*{content}\" class=\"form-control\" rows=\"10\"&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;input type=\"submit\" value=\"저장하기\" class=\"btn btn-primary my-2\"&gt; &lt;/form&gt; &lt;/div&gt; &lt;/html&gt; *name*=\"subject\"과 *id*=\"subject\"를 제외하고 th:field=\"*{subject}\"를 설정 이미 입력한 값이 유지되도록 설정한 것 이렇게 하면 해당 태그의 id, name, value 속성이 모두 자동으로 생성되고 타임리프가 value 속성에 기존에 입력된 값을 채워 넣어 오류가 발생하더라도 기존에 입력한 값이 유지 답변 등록 기능에 폼 적용 AnswerForm.java @Getter @Setter public class AnswerForm { @NotEmpty(message=\"내용은 필수항목입니다.\") private String content; } AnswerController.java @Controller @RequiredArgsConstructor @RequestMapping(\"/answer\") public class AnswerController { private final QuestionService questionService; private final AnswerService answerService; @PostMapping(\"create/{id}\") public String createAnswer( @PathVariable Integer id, @Valid AnswerForm answerForm, BindingResult bindingResult, Model model) { Question question = questionService.getQuestion(id); if (bindingResult.hasErrors()) { model.addAttribute(\"question\", question); return \"domain/question/question_detail\"; } answerService.create(question, answerForm.getContent()); return String.format(\"redirect:/question/detail/%s\", id); } question_detail.html &lt;html layout:decorate=\"~{layout}\"&gt; &lt;div layout:fragment=\"content\" class=\"container my-3\"&gt; &lt;!-- 질문 --&gt; ..... &lt;!-- 답변 반복 끝 --&gt; &lt;!-- 답변 작성 --&gt; &lt;form th:action=\"@{|/answer/create/${question.id}|}\" th:object=\"${answerForm}\" method=\"post\" class=\"my-3\"&gt; &lt;div class=\"alert alert-danger\" role=\"alert\" th:if=\"${#fields.hasAnyErrors()}\"&gt; &lt;div th:each=\"err : ${#fields.allErrors()}\" th:text=\"${err}\" /&gt; &lt;/div&gt; &lt;textarea th:field=\"*{content}\" rows=\"10\" class=\"form-control\"&gt;&lt;/textarea&gt; &lt;input type=\"submit\" value=\"답변등록\" class=\"btn btn-primary my-2\"&gt; &lt;/form&gt; &lt;/div&gt; &lt;/html&gt; QuestionController.java @GetMapping(\"detail/{id}\") public String detail(@PathVariable Integer id, Model model, AnswerForm answerForm) { Question question = questionService.getQuestion(id); model.addAttribute(\"question\", question); return \"domain/question/question_detail\"; } 공통 템플릿 만들기 오류 메시지를 출력하는 코드가 반복되어 사용되고 있다. &lt;div class=\"alert alert-danger\" role=\"alert\" th:if=\"${#fields.hasAnyErrors()}\"&gt; &lt;div th:each=\"err : ${#fields.allErrors()}\" th:text=\"${err}\" /&gt; &lt;/div&gt; 오류 전용 템플릿 생성 /templates/form_errors.html &lt;div th:fragment=\"formErrorsFragment\" class=\"alert alert-danger\" role=\"alert\" th:if=\"${#fields.hasAnyErrors()}\"&gt; &lt;div th:each=\"err : ${#fields.allErrors()}\" th:text=\"${err}\" /&gt; &lt;/div&gt; th:fragment=\"formErrorsFragment\"가 추가되었다. ⇒   다른 템플릿에서 이 div 태그의 영역을 사용할 수 있도록 이름을 설정한 것 기존 템플릿에 적용하기 question_form.html &lt;html layout:decorate=\"~{layout}\"&gt; &lt;div layout:fragment=\"content\" class=\"container\"&gt; &lt;h5 class=\"my-3 border-bottom pb-2\"&gt;질문등록&lt;/h5&gt; &lt;form th:action=\"@{/question/create}\" th:object=\"${questionForm}\" method=\"post\"&gt; &lt;div th:replace=\"~{form_errors :: formErrorsFragment}\"&gt;&lt;/div&gt; &lt;div class=\"mb-3\"&gt; &lt;label for=\"subject\" class=\"form-label\"&gt;제목&lt;/label&gt; &lt;input type=\"text\" th:field=\"*{subject}\" class=\"form-control\"&gt; &lt;/div&gt; &lt;div class=\"mb-3\"&gt; &lt;label for=\"content\" class=\"form-label\"&gt;내용&lt;/label&gt; &lt;textarea th:field=\"*{content}\" class=\"form-control\" rows=\"10\"&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;input type=\"submit\" value=\"저장하기\" class=\"btn btn-primary my-2\"&gt; &lt;/form&gt; &lt;/div&gt; &lt;/html&gt; th:replace 속성을 사용하면 템플릿 내에 공통 템플릿을 삽입할 수 있다. &lt;div th:replace=\"~{form_errors :: formErrorsFragment}\"&gt;&lt;/div&gt;는 th:replace 속성에 의해 div 요소의 내용을 form_errors 템플릿으로 대체하라는 의미이다. 여기서 formErrorsFragment는 앞서 form_errors 템플릿에서 작성한 내용 일부를 가리키는 것이다. question_detail.html도 마찬가지로 수정 &lt;html layout:decorate=\"~{layout}\"&gt; &lt;div layout:fragment=\"content\" class=\"container my-3\"&gt; (... 생략 ...) &lt;!-- 답변 작성 --&gt; &lt;form th:action=\"@{|/answer/create/${question.id}|}\" th:object=\"${answerForm}\" method=\"post\" class=\"my-3\"&gt; &lt;div th:replace=\"~{form_errors :: formErrorsFragment}\"&gt;&lt;/div&gt; &lt;textarea th:field=\"*{content}\" rows=\"10\" class=\"form-control\"&gt;&lt;/textarea&gt; &lt;input type=\"submit\" value=\"답변등록\" class=\"btn btn-primary my-2\"&gt; &lt;/form&gt; &lt;/div&gt; &lt;/html&gt; " }, { "title": "App 21. Stack과 Queue", "url": "/posts/app-21/", "categories": "개인 공부, myapp 혼자 다시해보기, 1단계-Java기초", "tags": "Stack, Queue, breadcrumb 방식", "date": "2024-12-30 22:00:00 +0900", "snippet": "App 21. 스택과 큐 다루기1. 학습목표 스택과 큐의 구동 원리를 이해하고 구현할 수 있다. 스택과 큐를 활용할 수 있다.2. 요구사항 프롬프트에서 메뉴 경로를 breadcrumb 방식으로 다루기 사용자가 입력한 명령어 내역을 다루기3. 작업 LinkedList를 상속 받아 스택을 구현한다. Stack 클래스 추가 ...", "content": "App 21. 스택과 큐 다루기1. 학습목표 스택과 큐의 구동 원리를 이해하고 구현할 수 있다. 스택과 큐를 활용할 수 있다.2. 요구사항 프롬프트에서 메뉴 경로를 breadcrumb 방식으로 다루기 사용자가 입력한 명령어 내역을 다루기3. 작업 LinkedList를 상속 받아 스택을 구현한다. Stack 클래스 추가 push(), pop(), isEmpty() 생성 package bitcamp.myapp.util; public class Stack extends LinkedList { public void push(Object value) { add(value); } public Object pop() { return remove(size() - 1); } public boolean isEmpty() { return size() == 0; } } LinkedList를 상속 받아 큐를 구현한다. Queue 클래스 추가 offer(), poll(), isEmpty() 생성 package bitcamp.myapp.util; public class Queue extends LinkedList { public void offer(Object value) { add(value); } public Object poll() { return remove(0); } public boolean isEmpty() { return size() == 0; } } 프롬프트 메뉴 경로를 출력할 때 스택을 적용한다. App 클래스 변경 메뉴 경로를 저장하는 스택 객체 준비 메인 메뉴 이름을 스택에 저장 서브 메뉴을 실행(execute())시킬 때 menuPath를 넘겨서 저장하게 한다. Stack menuPath = new Stack(); void execute() { menuPath.push(\"메인\"); printMenu(); ... void processMenu(String menuTitle) { Command command = commandMap.get(menuTitle); if (command == null) { System.out.printf(\"%s 메뉴의 명령을 처리할 수 없습니다.\\n\", menuTitle); return; } command.execute(menuPath); } Command 클래스 변경 package bitcamp.myapp.command; import bitcamp.myapp.util.Stack; public interface Command { void execute(Stack menuPath); } AbstractCommand 클래스 변경 서브 메뉴 이름을 스택에 보관 및 꺼내기 메뉴 경로를 리턴하는 메서드 추가   (getMenuPath()) StringBuilder 이용 메뉴 경로 사이에 / 를 입력 execute()에서 String.format 빼기   (input() 메서드에 들어 있음) @Override public void execute(Stack menuPath) { menuPath.push(menuTitle); printMenus(); while (true) { String command = Prompt.input(String.format(\"메인/%s&gt;\", menuTitle)); if (command.equals(\"menu\")) { printMenus(); continue; } else if (command.equals(\"9\")) { return; } try { int menuNo = Integer.parseInt(command); String menuName = getMenuTitle(menuNo); if (menuName == null) { System.out.println(\"올바른 메뉴 번호가 아닙니다.\"); continue; } processMenu(menuName); } catch (NumberFormatException e) { System.out.println(\"숫자로 메뉴 번호를 입력하세요.\"); } } } private String getMenuPathTitle(Stack menuPath) { StringBuilder strBuilder = new StringBuilder(); for (int i = 0; i &lt; menuPath.size(); i++) { if (!strBuilder.isEmpty()) { strBuilder.append(\"/\"); } strBuilder.append(menuPath.get(i)); } return strBuilder.toString(); } 사용자가 입력한 내역을 큐&lt;/span&gt;를 이용하여 저장한다. Prompt 클래스 변경 사용자가 입력한 내용을 큐에 순서대로 저장 필드 생성   (Queue inputQueue) input() 수정 입력한 내역을 출력   (printHistory() 생성) Prompt package bitcamp.myapp.util; import java.util.Scanner; public class Prompt { public static Scanner sc = new Scanner(System.in); static Queue inputQueue = new Queue(); public static String input(String format, Object... args) { String promptTitle = String.format(format, args); System.out.printf(promptTitle); String input = sc.nextLine(); if (format.endsWith(\"&gt;\")) { inputQueue.offer(promptTitle + input); if (inputQueue.size() &gt; 20) { inputQueue.poll(); } } return input; } public static int inputInt(String title) { return Integer.parseInt(input(title)); } public static void close() { sc.close(); } public static void printHistory() { System.out.println(\"[명령 내역]----------------------\"); for (int i = 0; i &lt; inputQueue.size(); i++) { System.out.println(inputQueue.get(i)); } System.out.println(\"--------------------------- 끝\"); } } 사용자가 입력한 내역을 출력한다. HistoryCommand 클래스 추가 package bitcamp.myapp.command; import bitcamp.myapp.util.Prompt; import bitcamp.myapp.util.Stack; public class HistoryCommand implements Command { public void execute(Stack menuPath) { Prompt.printHistory(); } } App 클래스 변경 “명령내역” 메뉴 추가 App public class App { String[] mainMenus = {\"회원\", \"프로젝트\", \"게시판\", \"명령내역\", \"도움말\", \"종료\"}; Map&lt;String, Command&gt; commandMap = new HashMap&lt;&gt;(); Stack menuPath = new Stack(); public App() { List userList = new ArrayList(); List boardList = new LinkedList(); List projectList = new LinkedList(); UserCommand userCommand = new UserCommand(\"회원\", userList); commandMap.put(\"회원\", userCommand); commandMap.put(\"게시판\", new BoardCommand(\"게시판\", boardList)); commandMap.put(\"프로젝트\", new ProjectCommand(\"프로젝트\", projectList, userList)); commandMap.put(\"도움말\", new HelpCommand(\"도움말\")); commandMap.put(\"명령내역\", new HistoryCommand()); } 결과 변경 없음 🔆 21. 자료 구조 - Stack과 Queue Stack 넣을 때 push(), 꺼낼 때 pop() First In Last Out (FILO)   =   LIFO [Ex] 방문 페이지 저장 메서드 호출 (JVM Stack) 엘리베이터 만차일 때 Queue 넣을 때 offer(), 꺼낼 때 poll() First In First Out (FIFO) [Ex] 예약 시스템 단일 스레드에서 클라이언트 요청 처리 이벤트 처리 = Event Queue 🔆 프롬프트 제목을 스택으로 다루기 메뉴 경로를 breadcrumb 방식으로 다룬다. breadcrumb 방식 사용자 인터페이스 디자인에서 사용되는 네비게이션 패턴 사용자가 현재 웹사이트나 애플리케이션에서 어느 위치에 있는지 보여주고, 이전에 방문한 페이지로 쉽게 돌아갈 수 있도록 돕는다. 이는 웹사이트나 애플리케이션의 구조와 계층을 시각적으로 표시하여 사용자가 자신의 위치를 쉽게 파악하고, 탐색 경로를 제공함으로써 더 나은 사용자 경험을 제공하는 것을 목표로 합니다. Breadcrumb의 특징 위치 표시 현재 페이지가 사이트의 구조 내에서 어디에 위치하는지를 보여줍니다. 예를 들어, “Home &gt; Products &gt; Electronics &gt; Mobile Phones”와 같은 형태 탐색 경로 제공 사용자가 이전에 방문한 페이지로 쉽게 돌아갈 수 있는 링크 제공 각 단계는 클릭 가능한 링크로 표시되며, 사용자가 클릭하면 해당 페이지로 이동할 수 있다. 일관성 유지 Breadcrumb 네비게이션은 일관되게 사용되어야 하며, 웹사이트나 애플리케이션의 모든 페이지에 동일한 형식으로 적용되어야 한다. 🔆 문자열 연결 ⭐ 문자열을 연결하는 과정에서 새 String 객체가 생성되고 기존 String 객체가 가비지가 된다. ⇒   즉, 메모리 낭비가 심하다. String str = \"\"; str += \"aaa\"; \"\" + \"aaa\" = \"aaa\" =&gt; 새 String 객체 생성 (앞의 둘은 가비지가 된다) str += \"bbb\"; \"aaa\" + \"bbb\" = \"aaabbb\" =&gt; 새 String 객체 생성 (앞의 둘은 가비지가 된다) 해결책 기존의 String은 immutable 객체이기 때문에 내용 변경 불가!! mutable 객체인 StringBuffer나 StringBuilder를 사용하면 된다. 요즘 자바 컴파일러는 문자열 연결 코드를 StringBuffer 또는 StringBuilder 코드로 최적화한다. ★ ⇒   가비지를 생성하지 않는 코드로 변경한다. StringBuffer와 StringBuilder StringBuffer Thread-Safe(멀티스레드 동시 접근 차단 기능)을 보유한다. 단, Lock/unLock에 시간이 걸린다. StringBuilder Thread-Safe 보장 안 함   ⇒   멀티 스레드의 동시 접근 가능 다른 Thread의 값을 덮어 쓸 수 있다.   ⇒   Lock/Unlock 관리 안 함   ⇒   안정성이 떨어진다. 시간 소요가 적다. 즉, 단일 스레드라면 StringBuilder를 쓰는 것이 좋다. (인스턴스 변수로 쓸 때는 Buffer, 로컬에서만 쓸 거면 Builder) " }, { "title": "App 20. SOLID의 DIP", "url": "/posts/app-20/", "categories": "개인 공부, myapp 혼자 다시해보기, 1단계-Java기초", "tags": "SOLID, DIP, GRASP, Map", "date": "2024-12-28 16:00:00 +0900", "snippet": "App 20. 리팩토링 : Map 컬렉션과 의존성 주입1. 학습목표 GRASP 설계 지침에서 Low Coupling을 이해하고 적용할 수 있다. SOLID 설계 원칙&lt;/span&gt;에서 DIP(Dependency Inversion Principle)를 이해하고 적용할 수 있다. Map 컬렉션 객체를 사용하여 객체를 저장하고...", "content": "App 20. 리팩토링 : Map 컬렉션과 의존성 주입1. 학습목표 GRASP 설계 지침에서 Low Coupling을 이해하고 적용할 수 있다. SOLID 설계 원칙&lt;/span&gt;에서 DIP(Dependency Inversion Principle)를 이해하고 적용할 수 있다. Map 컬렉션 객체를 사용하여 객체를 저장하고 조회할 수 있다.2. 요구사항 의존 객체를 다룰 때 DIP 설계 원칙을 적용3. 작업 Command 구현체 저장 및 실행 Map 컬렉션 객체를 사용하여 Command 구현체를 저장 Map 컬렉션은 Key 객체를 통해 Value 값을 가져온다. App 클래스 Map&lt;String, Command&gt; commandMap을 생성하여 기존의 Command 구현체를 담는다. 생성자 추가 생성자로 Command 구현체 객체 생성 후 Map에 담는다. public class App { String[] mainMenus = {\"회원\", \"프로젝트\", \"게시판\", \"도움말\", \"종료\"}; Map&lt;String, Command&gt; commandMap = new HashMap&lt;&gt;(); public App() { UserCommand userCommand = new UserCommand(\"회원\"); commandMap.put(\"회원\", userCommand); commandMap.put(\"게시판\", new BoardCommand(\"게시판\")); commandMap.put(\"프로젝트\", new ProjectCommand(\"프로젝트\", userCommand.getUserList())); commandMap.put(\"도움말\", new HelpCommand(\"도움말\")); } 메뉴에 대한 Command 구현체를 찾아 실행 Command 인터페이스 구현체(Ex. UserCommand 등)을 Map에서 가져와서 execute() 실행 App 클래스 processMenu() 변경 void processMenu(String menuTitle) { Command command = commandMap.get(menuTitle); if (command == null) { System.out.printf(\"%s 메뉴의 명령을 처리할 수 없습니다.\\n\", menuTitle); return; } command.execute(); } 의존 객체를 외부에서 주입하기   (SOLID의 DIP 적용) UserCommand, ProjectCommand, BoardCommand 클래스의 의존 객체를 외부에서 주입 의존 객체(boardList 등)를 생성자를 통해 외부에서 Command 구현체에 주입한다. BoardCommand 생성자 및 필드 변경 public class BoardCommand extends AbstractCommand { List boardList; private String[] menus = {\"등록\", \"목록\", \"조회\", \"변경\", \"삭제\"}; public BoardCommand(String menuTitle, List boardList) { super(menuTitle); this.boardList = boardList; } ProjectCommand 생성자 및 필드 변경 public class ProjectCommand extends AbstractCommand { List projectList; List userList; private String[] menus = {\"등록\", \"목록\", \"조회\", \"변경\", \"삭제\"}; public ProjectCommand(String menuTitle, List projectList, List userList) { super(menuTitle); this.projectList = projectList; this.userList = userList; } UserCommand 생성자 및 필드 변경 getUserList() 제거 public class UserCommand extends AbstractCommand { List userList; private String[] menus = {\"등록\", \"목록\", \"조회\", \"변경\", \"삭제\"}; public UserCommand(String menuTitle, List userList) { super(menuTitle); this.userList = userList; } Command 객체가 사용할 List 객체 준비 의존 객체인 boardList 등을 App에서 생성하고 구현체의 생성자를 통해 넘겨준다 App 클래스 생성자 변경 public class App { String[] mainMenus = {\"회원\", \"프로젝트\", \"게시판\", \"도움말\", \"종료\"}; Map&lt;String, Command&gt; commandMap = new HashMap&lt;&gt;(); public App() { List userList = new ArrayList(); List boardList = new LinkedList(); List projectList = new LinkedList(); UserCommand userCommand = new UserCommand(\"회원\", userList); commandMap.put(\"userCommand\", userCommand); commandMap.put(\"boardCommand\", new BoardCommand(\"게시판\", boardList)); commandMap.put(\"projectCommand\", new ProjectCommand(\"프로젝트\", projectList, userList)); commandMap.put(\"helpCommand\", new HelpCommand(\"도움말\")); } 단, 이렇게 하려면 레퍼런스를 클래스가 아니라 인터페이스&lt;/span&gt;로 해서 먼저 유연하게 하는 것이 필요!! LinkedList boardList   ( X )   ⇒   List boardList   ( O ) 결과 변경 없음 🔆 20. SOLID의 DIP와 GRASP의 Low Coupling - (1) 상속 사용 전 ⭐class Switch { FlouLamp light;} Switch 클래스가 FluoLamp 객체를 제어 ⇒   Switch 클래스가 FluoLamp의 기능을 사용   ⇒   전등을 켜거나 끄는 것 Switch 클래스가 FluoLamp 객체에 의존 ⇒   Switch 클래스는 FluoLamp 객체가 없으면 정상적으로 동작할 수 없다. 문제점 FluoLamp를 LedLamp로 교체한다면 코드를 변경해야 한다. Switch 클래스가 FluoLamp 클래스만 사용하도록 되어 있다. “강한 연결 상태” 해결방법 FlouLamp와 LedLamp를 같은 타입으로 묶는다.   (같은 부모를 갖게 한다)   ⇒   Lamp 클래스 (super) 🔆 20. SOLID의 DIP와 GRASP의 Low Coupling - (2) 상속의 Generalizationclass Switch { Lamp light;} 두 클래스의 부모를 같게 하여 같은 타입으로 묶으면 다형적 변수(Lamp)를 활용하여 여러 종류의 조명을 제어할 수 있다. (즉, 연결이 조금 더 부드러워 졌다) 문제점 조명(Lamp)만 제어? Swtich로 다른 제품을 제어할 수 있어야 하는 것 아닌가? 해결방법 상위 클래스의 상위 클래스를 만든다. 🔆 20. SOLID의 DIP와 GRASP의 Low Coupling - (3) 상속 계층 구조class Switch { Device 장치;} 문제점 여러 장치를 스위치로 제어하려고 같은 타입으로 묶으면 상속관계가 너무 복잡해 진다. 또 모든 장치를 스위치로 제어할 수 있는 것도 아니다. (선풍기 처럼) 모든 디바이스를 스위치로 제어한다고 했는데 선풍기를 따로 제외할 수 없다. 상속은 “강결합”을 유지하기 때문에 유연성 부족 해결방법 상속이 아닌 인터페이스를 활용한다. 🔆 20. SOLID의 DIP와 GRASP의 Low Coupling - (4) 인터페이스class Switch { Switchable 장치;} Switchable이라는 인터페이스를 만든다. 나머지 기기들이 인터페이스의 규칙을 따르도록 한다. 상속보다 인터페이스를 사용하면 같은 타입이 아닌 장치들도 스위치로 제어할 수 있다. 어떤 타입이든 Switchable 규칙에 따라 만든 제품이라면 제어 가능 상속보다 더 유연하다. “약결합” 🔆 SOLID - Dependency Inversion Principle (DIP, 의존 역전) 레퍼런스를 클래스가 아니라 인터페이스로 해서 느슨한 결합으로 전환한 후 Switch 클래스가 의존 객체를 생성하는 것이 아니라 외부에서 주입 받는 방식으로 전환하면 더 유연해 진다. FlouLamp lgith1 = new FluoLamp(); Switch swtich = new Switch(light1); 교체가 쉽다. 테스트가 쉽다. ⇒   의존 객체를 간단히 만들어 주입한 후 스위치를 테스트 할 수 있다 의존 역전은 필요한 것을 직접 만들지 않고 외부에서 주입 받는 것이다. 이 방법이 나온 이유 ⇒   코드가 복잡해졌기 때문이다. ⇒   각각의 클래스가 복잡해지고 서로 강하게 연관되어 있으면 테스트가 너무 힘들다. ❓ 의존 객체 의존 객체는 특정 클래스가 정상적으로 동작하기 위해 필요한 외부 객체를 의미 어떤 객체가 다른 객체의 기능을 필요로 할 때, 그 다른 객체를 의존 객체라고 합니다. 예를 들어, 클래스 A가 클래스 B의 메서드를 호출해야 한다면, A는 B에 의존한다고 할 수 있습니다. [Ex] UserCommand 클래스에서 객체를 저장하는데 사용한 LinkedList 객체 요리사와 주방 도구 요리사에게 요리를 하기 위해 필요한 주방 도구가 의존 객체이다 주방 도구가 없으면 요리를 할 수 없다.   ⇒   필요로 한다. 요리사가 요리를 하기 위해 직접 주방 도구를 만들지 않고, 이미 만들어진 주방 도구를 사용하는 것 ⇒   의존성 주입 의존성 주입     (Dependency Injection) 의존 객체를 외부에서 주입(inject)하여 객체 간의 결합도를 낮추는 디자인 패턴입니다. DI를 사용하면 객체가 직접 다른 객체를 생성하지 않고, 외부에서 필요한 객체를 주입 받아 사용 이렇게 하면 객체 간의 결합도가 낮아져 코드의 유연성과 테스트 용이성이 증가합니다. 🔆 Dependency Injection (DI, 의존성 주입) ⭐ Inversion of Control     (IoC, 제어의 역전) IoC의 주요 구현 방법 Dependency Injection (의존성 주입)   =   Dependency Inversion Principle (의존성 역전 원칙) (장점   :   교체가 쉽고 테스트가 쉽다) Listener   =   event Handler 기술면접 DI(의존성 주입)을 사용하는 이유 SOLID과 GRASP 설명하기 " }, { "title": "App 17-19. ArrayList와 LinkedList", "url": "/posts/app-17-19/", "categories": "개인 공부, myapp 혼자 다시해보기, 1단계-Java기초", "tags": "인터페이스, 추상클래스, Template Method, GoF, GRASP", "date": "2024-12-25 10:00:00 +0900", "snippet": "App 17. 인터페이스를 이용한 객체 사용 규칙 정의 : 목록을 다루는 규칙1. 학습목표 인터페이스를 이용하여 객체 사용 규칙을 정의하고 사용할 수 있다. 패키지를 이용하여 클래스를 분류할 수 있다. equals()의 용도를 이해하고 재정의하여 사용할 수 있다.2. 요구사항 ArrayList와 LinkedList의 사용 규칙을 통일...", "content": "App 17. 인터페이스를 이용한 객체 사용 규칙 정의 : 목록을 다루는 규칙1. 학습목표 인터페이스를 이용하여 객체 사용 규칙을 정의하고 사용할 수 있다. 패키지를 이용하여 클래스를 분류할 수 있다. equals()의 용도를 이해하고 재정의하여 사용할 수 있다.2. 요구사항 ArrayList와 LinkedList의 사용 규칙을 통일하기 목록을 다루는 것과 관련된 클래스를 다른 프로젝트에서 재사용하기 쉽게 분류하기 UserList, ProjectList, BoardList 클래스를 제거하고 ArrayList, LinkedList를 직접 사용하기 메뉴를 처리하는 클래스의 사용 규칙을 통일하기3. 작업 목록을 다루는 객체 사용 규칙을 정의한다. List 인터페이스 추가 add(), remove(), get(), indexOf(), toArray(), size() 규칙 정의 규칙이기 때문에 메서드 시그너처만 정의한다. public, abstract 모두 생략 가능하므로 보통 생략한다. package bitcamp.myapp.command; public interface List { public abstract void add(Object value); public abstract Object remove(int index); public abstract Object get(int index); public abstract int indexOf(Object value); public abstract Object[] toArray(); public abstract int size(); } ArrayList와 LinkedList 클래스를 List 규칙에 따라 정의한다. ArrayList 변경 @Override는 재정의 또는 추상메서드 구현을 의미 ArrayList package bitcamp.myapp.command; import java.util.Arrays; public class ArrayList implements List { private static final int MAX_SIZE = 100; private Object[] list = new Object[MAX_SIZE]; private int size = 0; @Override public void add(Object obj) { list[size++] = obj; if (size == list.length) { int oldSize = list.length; int newSize = oldSize + (oldSize &gt;&gt; 1); list = Arrays.copyOf(list, newSize); } list[size++] = obj; } @Override public Object[] toArray() { Object[] arr = new Object[size]; for (int i = 0; i &lt; arr.length; i++) { arr[i] = list[i]; } return arr; } @Override public int indexOf(Object obj) { for (int i = 0; i &lt; size; i++) { if (list[i] == obj) { return i; } } return -1; } @Override public Object remove(int index) { if (index &lt; 0 || index &gt;= size) { return null; } Object deletedObj = list[index]; for (int i = index + 1; i &lt; size; i++) { list[i - 1] = list[i]; } list[--size] = null; return deletedObj; } @Override public int size() { return size; } @Override public Object get(int index) { if (index &lt; 0 || index &gt;= size) { return null; } return list[index]; } public boolean contains(Object obj) { return indexOf(obj) != -1; } } LinkedList 변경 규칙에 맞게 이름 변경 LinkedList package bitcamp.myapp.command; public class LinkedList implements List { Node first; Node last; int size; @Override public void add(Object value) { Node newNode = new Node(value); if (first == null) { first = newNode; } else { last.next = newNode; last = newNode; } size++; } @Override public Object get(int index) { if (index &lt; 0 || index &gt;= size) { return null; } Node cursor = first; int currentIndex = 0; while (cursor != null) { if (currentIndex == index) { return cursor.value; } cursor = cursor.next; currentIndex++; } return null; } @Override public Object remove(int index) { if (index &lt; 0 || index &gt;= size) { return null; } Node deletedNode = null; size--; if (index == 0) { deletedNode = first; first = first.next; if (first == null) { last = null; } return deletedNode.value; } Node cursor = first; int currentIndex = 0; while (cursor != null) { if (currentIndex == (index - 1)) { break; } cursor = cursor.next; currentIndex++; } deletedNode = cursor.next; cursor.next = cursor.next.next; if (cursor.next == null) { last = cursor; } return deletedNode.value; } @Override public int indexOf(Object value) { Node cursor = first; int currentIndex = 0; while (cursor != null) { if (cursor.value == value) { return currentIndex; } cursor = cursor.next; currentIndex++; } return -1; } @Override public Object[] toArray() { Object[] arr = new Object[size]; Node cursor = first; for (int i = 0; i &lt; size; i++) { arr[i] = cursor.value; cursor = cursor.next; } return arr; } @Override public int size() { return size; } } ArrayList와 LinkedList, List 클래스를 별도의 패키지로 분류한다. ArrayList, LinkedList, List, Node 클래스   ⇒   util 패키지 리팩토링   :   equals() 재정의 Board, Project, User 변경 equals(), hashCode() 오버라이드 한다.   (no 필드만) 기본 생성자, 생성자(no필드) User package bitcamp.myapp.vo; import java.util.Objects; public class User { private static int seqNo; private int no; private String name; private String email; private String password; private String tel; public static int getNextSeqNo() { return ++seqNo; } public User() { } public User(int no) { this.no = no; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; User user = (User) o; return no == user.no; } @Override public int hashCode() { return Objects.hashCode(no); } public int getNo() { return no; } public void setNo(int no) { this.no = no; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } public String getTel() { return tel; } public void setTel(String tel) { this.tel = tel; } } UserList, ProjectList, BoardList 에서 데이터를 찾는 기능을 equals()로 대체 findByNo()를 equals()로 대체한다. ArrayList의 indexOf() 수정 equals()를 오버라이딩하여 이것으로 비교 가능 @Override public int indexOf(Object obj) { for (int i = 0; i &lt; size; i++) { if (list[i].equals(obj)) { return i; } } return -1; } LinkedList의 indexOf() 수정 equals()를 이욯아여 비교한다. @Override public int indexOf(Object value) { Node cursor = first; int currentIndex = 0; while (cursor != null) { if (cursor.value.equals(value)) { return currentIndex; } cursor = cursor.next; currentIndex++; } return -1; } UserList, ProjectList, BoardList 제거 UserList, ProjectList, BoardList의 업무의 대부분을 ArrayList가 하고 있으므로 통합시킨다. UserCommand, BoardCommand, ProjectCommand 변경 기존에 findByNo()로 찾던 것을 indexOf()와 get()을 이용하여 객체를 찾는다. UserCommand package bitcamp.myapp.command; import bitcamp.myapp.util.ArrayList; import bitcamp.myapp.util.Prompt; import bitcamp.myapp.vo.User; import static bitcamp.myapp.util.Prompt.input; import static bitcamp.myapp.util.Prompt.inputInt; public class UserCommand { ArrayList userList = new ArrayList(); public void executeUserCommand(String command) { System.out.println(command); switch (command) { case \"등록\": addUser(); break; case \"목록\": listUser(); break; case \"조회\": viewUser(); break; case \"변경\": updateUser(); break; case \"삭제\": deleteUser(); break; } } private void addUser() { User user = new User(); user.setName(Prompt.input(\"이름?\")); user.setEmail(Prompt.input(\"이메일?\")); user.setPassword(Prompt.input(\"암호?\")); user.setTel(Prompt.input(\"연락처?\")); user.setNo(User.getNextSeqNo()); userList.add(user); } private void listUser() { System.out.println(\"번호 이름 이메일\"); for (Object obj : userList.toArray()) { User user = (User) obj; System.out.printf(\"%d %s %s\\n\", user.getNo(), user.getName(), user.getEmail()); } } private void viewUser() { int userNo = inputInt(\"회원번호?\"); User user = (User) userList.get(userList.indexOf(new User(userNo))); if (user == null) { System.out.println(\"없는 회원입니다.\"); return; } System.out.printf(\"이름: %s\\n\", user.getName()); System.out.printf(\"이메일: %s\\n\", user.getEmail()); System.out.printf(\"연락처: %s\\n\", user.getTel()); } private void updateUser() { int userNo = inputInt(\"회원번호?\"); User user = (User) userList.get(userList.indexOf(new User(userNo))); if (user == null) { System.out.println(\"없는 회원입니다.\"); return; } user.setName(input(String.format(\"이름(%s)?\", user.getName()))); user.setEmail(input(String.format(\"이메일(%s)?\", user.getEmail()))); user.setPassword(input(\"암호?\")); user.setTel(input(String.format(\"연락처(%s)?\", user.getTel()))); System.out.println(\"변경했습니다.\"); } private void deleteUser() { int userNo = inputInt(\"회원번호?\"); User deletedUser = (User) userList.get(userList.indexOf(new User(userNo))); if (deletedUser != null) { userList.remove(userList.indexOf(deletedUser)); System.out.printf(\"'%s' 회원을 삭제 했습니다.\", deletedUser.getName()); } else { System.out.println(\"없는 회원입니다.\"); } } public ArrayList getUserList() { return this.userList; } } ProjectCommand package bitcamp.myapp.command; import bitcamp.myapp.util.ArrayList; import bitcamp.myapp.util.Prompt; import bitcamp.myapp.vo.Project; import bitcamp.myapp.vo.User; import static bitcamp.myapp.util.Prompt.input; import static bitcamp.myapp.util.Prompt.inputInt; public class ProjectCommand { ArrayList projectList = new ArrayList(); ArrayList userList; public ProjectCommand(ArrayList userlist) { this.userList = userlist; } public void executeProjectCommand(String command) { System.out.println(command); switch (command) { case \"등록\": addProject(); break; case \"목록\": listProject(); break; case \"조회\": viewProject(); break; case \"변경\": updateProject(); break; case \"삭제\": deleteProject(); break; } } private void addProject() { Project project = new Project(); project.setTitle(Prompt.input(\"프로젝트명?\")); project.setDescription(Prompt.input(\"설명?\")); project.setStartDate(Prompt.input(\"시작일?\")); project.setEndDate(Prompt.input(\"종료일?\")); System.out.println(\"팀원:\"); addMembers(project); project.setNo(Project.getNextSeqNo()); projectList.add(project); System.out.println(\"등록했습니다.\"); } private void listProject() { System.out.println(\"번호 프로젝트 기간\"); for (Object obj : projectList.toArray()) { Project project = (Project) obj; System.out.printf(\"%d %s %s ~ %s\\n\", project.getNo(), project.getTitle(), project.getStartDate(), project.getEndDate()); } } private void viewProject() { int projectNo = inputInt(\"프로젝트 번호?\"); Project project = (Project) projectList.get(projectList.indexOf(new Project(projectNo))); if (project == null) { System.out.println(\"없는 프로젝트입니다.\"); return; } System.out.printf(\"프로젝트명: %s\\n\", project.getTitle()); System.out.printf(\"설명: %s\\n\", project.getDescription()); System.out.printf(\"기간: %s ~ %s\\n\", project.getStartDate(), project.getEndDate()); System.out.println(\"팀원:\"); for (int i = 0; i &lt; project.getMembers().size(); i++) { User user = (User) project.getMembers().get(i); System.out.printf(\"- %s\\n\", user.getName()); } } private void updateProject() { int projectNo = inputInt(\"프로젝트 번호?\"); Project project = (Project) projectList.get(projectList.indexOf(new Project(projectNo))); if (project == null) { System.out.println(\"없는 프로젝트입니다.\"); return; } project.setTitle(Prompt.input(String.format(\"프로젝트명(%s)?\", project.getTitle()))); project.setDescription(Prompt.input(String.format(\"설명(%s)?\", project.getDescription()))); project.setStartDate(Prompt.input(String.format(\"시작일(%s)?\", project.getStartDate()))); project.setEndDate(Prompt.input(String.format(\"종료일(%s)?\", project.getEndDate()))); System.out.println(\"팀원:\"); deleteMembers(project); addMembers(project); System.out.println(\"변경했습니다.\"); } private void deleteProject() { int projectNo = Prompt.inputInt(\"프로젝트 번호?\"); // 1부터 시작 Project deletedProject = (Project) projectList.get(projectList.indexOf(new Project(projectNo))); if (deletedProject != null) { projectList.remove(projectList.indexOf(deletedProject)); System.out.printf(\"%d번 프로젝트를 삭제 했습니다.\\n\", deletedProject.getNo()); } else { System.out.println(\"삭제 했습니다.\"); } } private void addMembers(Project project) { while (true) { int userNo = inputInt(\"추가할 팀원 번호?(종료: 0)\"); if (userNo == 0) { break; } User user = (User) userList.get(userList.indexOf(new User(userNo))); if (user == null) { System.out.println(\"없는 회원입니다.\"); continue; } if (project.getMembers().contains(user)) { System.out.printf(\"'%s'은 현재 팀원입니다.\\n\", user.getName()); continue; } project.getMembers().add(user); System.out.printf(\"'%s'을 추가했습니다.\\n\", user.getName()); } } private void deleteMembers(Project project) { for (int i = 0; i &lt; project.getMembers().size(); i++) { User member = (User) project.getMembers().get(i); String str = input(\"팀원(%s) 삭제?\", member.getName()); if (str.equalsIgnoreCase(\"y\")) { project.getMembers().remove(i); System.out.printf(\"'%s' 팀원을 삭제합니다.\\n\", member.getName()); } else { System.out.printf(\"'%s' 팀원을 유지합니다.\\n\", member.getName()); } } } } BoardCommand package bitcamp.myapp.command; import bitcamp.myapp.util.ArrayList; import bitcamp.myapp.util.Prompt; import bitcamp.myapp.vo.Board; import java.util.Date; import static bitcamp.myapp.util.Prompt.inputInt; public class BoardCommand { ArrayList boardList = new ArrayList(); public void executeBoardCommand(String command) { System.out.printf(\"[%s]\\n\", command); switch (command) { case \"등록\": addBoard(); break; case \"조회\": viewBoard(); break; case \"목록\": listBoard(); break; case \"변경\": updateBoard(); break; case \"삭제\": deleteBoard(); break; } } private void addBoard() { Board board = new Board(); board.setTitle(Prompt.input(\"제목?\")); board.setContent(Prompt.input(\"내용?\")); board.setCreatedDate(new Date()); board.setNo(Board.getNextSeqNo()); boardList.add(board); System.out.println(\"등록했습니다.\"); } private void listBoard() { System.out.println(\"번호 제목 작성일 조회수\"); for (Object obj : boardList.toArray()) { Board board = (Board) obj; System.out.printf(\"%d %s %tY-%3$tm-%3$td %d\\n\", board.getNo(), board.getTitle(), board.getCreatedDate(), board.getViewCount()); } } private void viewBoard() { int boardNo = inputInt(\"게시글 번호?\"); Board board = (Board) boardList.get(boardList.indexOf(new Board(boardNo))); if (board == null) { System.out.println(\"없는 게시글입니다.\"); return; } board.setViewCount(board.getViewCount() + 1); System.out.printf(\"제목: %s\\n\", board.getTitle()); System.out.printf(\"내용: %s\\n\", board.getContent()); System.out.printf(\"작성일: %1$tY-%1$tm-%1$td %1$tH:%1$tM:%1$tS\\n\", board.getCreatedDate()); System.out.printf(\"조회수: %d\\n\", board.getViewCount()); } private void updateBoard() { int boardNo = inputInt(\"게시글 번호?\"); Board board = (Board) boardList.get(boardList.indexOf(new Board(boardNo))); if (board == null) { System.out.println(\"없는 게시글입니다.\"); return; } board.setTitle(Prompt.input(\"제목(%s)?\", board.getTitle())); board.setContent(Prompt.input(\"내용(%s)?\", board.getContent())); System.out.println(\"변경했습니다.\"); } private void deleteBoard() { int boardNo = inputInt(\"게시글 번호?\"); Board deletedBoard = (Board) boardList.get(boardList.indexOf(new Board(boardNo))); if (deletedBoard != null) { boardList.remove(boardList.indexOf(deletedBoard)); System.out.printf(\"%d번 게시글을 삭제 했습니다.\\n\", deletedBoard.getNo()); } else { System.out.println(\"없는 게시글입니다.\"); } } } ArrayList 대신 LinkedList 로 전환 아주 쉽게 전환할 수 있다. 메뉴를 처리하는 객체 사용 규칙을 정의 Command 인터페이스 추가 execute() 규칙 정의 package bitcamp.myapp.command; public interface Command { void execute(String name); } UserCommand, ProjectCommand, BoardCommand 클래스에 인터페이스 적용 executeXXXCommand() 변경 UserCommand public class UserCommand implements Command { LinkedList userList = new LinkedList(); @Override public void execute(String name) { System.out.printf(\"[%s]\\n\", name); switch (name) { case \"등록\": addUser(); break; case \"목록\": listUser(); break; case \"조회\": viewUser(); break; case \"변경\": updateUser(); break; case \"삭제\": deleteUser(); break; } } ProjectCommand public class ProjectCommand implements Command { LinkedList projectList = new LinkedList(); LinkedList userList; public ProjectCommand(LinkedList userlist) { this.userList = userlist; } @Override public void execute(String name) { System.out.printf(\"[%s]\\n\", name); switch (name) { case \"등록\": addProject(); break; case \"목록\": listProject(); break; case \"조회\": viewProject(); break; case \"변경\": updateProject(); break; case \"삭제\": deleteProject(); break; } } BoardCommand public class BoardCommand implements Command { LinkedList boardList = new LinkedList(); public void execute(String name) { System.out.printf(\"[%s]\\n\", name); switch (name) { case \"등록\": addBoard(); break; case \"조회\": viewBoard(); break; case \"목록\": listBoard(); break; case \"변경\": updateBoard(); break; case \"삭제\": deleteBoard(); break; } } App 클래스에서 XxxCommand 클래스 호출 코드 변경 공지사항 제거 및 호출하는 메서드를 execute()로 바꿔주기 App /* * This source file was generated by the Gradle 'init' task */ package bitcamp.myapp; import bitcamp.myapp.command.BoardCommand; import bitcamp.myapp.command.ProjectCommand; import bitcamp.myapp.command.UserCommand; import bitcamp.myapp.util.Prompt; public class App { String[] mainMenus = {\"회원\", \"프로젝트\", \"게시판\", \"도움말\", \"종료\"}; String[][] subMenus = { {\"등록\", \"목록\", \"조회\", \"변경\", \"삭제\"}, {\"등록\", \"목록\", \"조회\", \"변경\", \"삭제\"}, {\"등록\", \"목록\", \"조회\", \"변경\", \"삭제\"}, {} }; UserCommand userCommand = new UserCommand(); BoardCommand boardCommand = new BoardCommand(); ProjectCommand projectCommand = new ProjectCommand(userCommand.getUserList()); public static void main(String[] args) { new App().executeApp(); } void executeApp() { printMenu(); String command; while (true) { try { command = Prompt.input(\"메인&gt;\"); if (command.equals(\"menu\")) { printMenu(); } else { int menuNo = Integer.parseInt(command); String menuTitle = getMenuTitle(menuNo, mainMenus); if (menuTitle == null) { System.out.println(\"올바른 메뉴 번호가 아닙니다.\"); } else if (menuTitle.equals(\"종료\")) { break; } else { if (menuNo &gt;= 1 &amp;&amp; menuNo &lt;= 4) { processMenu(menuTitle, subMenus[menuNo - 1]); } else { System.out.println(menuTitle); } } } } catch (NumberFormatException e) { System.out.println(\"메뉴를 숫자로 입력하세요.\"); } } System.out.println(\"종료합니다.\"); Prompt.close(); } void printMenu() { String bold = \"\\u001B[1m\"; String red = \"\\u001B[31m\"; String reset = \"\\u001B[0m\"; String appTitle = \"[팀 프로젝트 관리 시스템]\"; String line = \"--------------------------------------------\"; System.out.println(bold + line + reset); System.out.println(bold + appTitle + reset); for (int i = 0; i &lt; mainMenus.length; i++) { if (i == mainMenus.length - 1) { System.out.printf(\"%s%s%d. %s%s\\n\", bold, red, i + 1, mainMenus[i], reset); } else { System.out.printf(\"%d. %s\\n\", i + 1, mainMenus[i]); } } System.out.println(bold + line + reset); } void printSubMenu(String menuTitle, String[] menus) { System.out.printf(\"[%s]\\n\", menuTitle); for (int i = 0; i &lt; menus.length; i++) { System.out.printf(\"%d. %s\\n\", (i + 1), menus[i]); } System.out.println(\"9. 이전\"); } boolean isValidateMenu(int menuNo, String[] menus) { return menuNo &gt;= 1 &amp;&amp; menuNo &lt;= menus.length; } String getMenuTitle(int menuNo, String[] menus) { return isValidateMenu(menuNo, menus) ? menus[menuNo - 1] : null; } void processMenu(String menuTitle, String[] menus) { if (menuTitle.equals(\"도움말\")) { System.out.println(\"도움말입니다.\"); return; } printSubMenu(menuTitle, menus); while (true) { String command = Prompt.input(String.format(\"메인/%s&gt;\", menuTitle)); if (command.equals(\"menu\")) { printSubMenu(menuTitle, menus); } else if (command.equals(\"9\")) { break; } else { try { int menuNo = Integer.parseInt(command); String subMenuTitle = getMenuTitle(menuNo, menus); if (subMenuTitle == null) { System.out.println(\"올바른 메뉴 번호가 아닙니다.\"); } else { switch (menuTitle) { case \"회원\": userCommand.execute(subMenuTitle); break; case \"프로젝트\": projectCommand.execute(subMenuTitle); break; case \"게시판\": boardCommand.execute(subMenuTitle); break; default: System.out.printf(\"%s 메뉴의 명령을 처리할 수 없습니다.\\n\", menuTitle); break; } } } catch (NumberFormatException ex) { System.out.println(\"숫자로 메뉴 번호를 입력하세요.\"); } } } } } 결과 변경 없음 🔆 17. 인터페이스를 이용하여 객체의 사용 규칙 정의 구현     (implements) 규칙에 따라 ArrayList, LinkedList를 만들겠다. 속이 빈 화살표와 점선으로 표현 UML 표기법     (Unified Modeling Language) 어떤 생각하는 바를 글과 그림(모델)으로 표현 ( 모델링) 문법   :   Language 🔆 인터페이스 문법 데이터 목록을 다루는 일을 할 객체의 사용법     ( 객체 사용 규칙) ⇒   즉 ‘그 객체에게 일을 시킬 때 다음의 메서드를 호출하여 일을 시켜라.’라고 지정하는 문법 규칙 작성법 (public) abstract void add(Object value); 규칙이기 때문에 메서드의 시그너처만 정의한다. “아직 정해지지 않음”   ⇒   abstract   (생략 가능) 규칙이란 것은 공개(public)되어야 하는 것이다.   ( 반드시 public 이므로   ⇒   따라서 public 생략 가능) (즉, abstract와 public 둘 다 생략 가능) 규칙이기 때문에 메서드를 구현하지 않는다.   ( 메서드 바디가 없어야 한다) ⇒   추상 메서드 규칙 적용 방법 class ArrayList implements List { @Override public void add(Object obj) { if (size == list.length) { // grow(); int oldSize = list.length; int newSize = oldSize + (oldSize &gt;&gt; 1); list = Arrays.copyOf(list, newSize); } list[size++] = obj; } } @Override 재정의 또는 추상메서드 구현을 의미   ⇒   이름, 반환 값 등 잘못하면 에러 발생   ⇒   실수 방지 🔆 인터페이스 두 부류의 개발자가 있다. 개발자 1 인터페이스 규칙에 따르는 객체를 사용하는 클래스를 작성 개발자 2 인터페이스 규칙에 따라 동작하는 클래스를 작성 객체 사용 규칙을 정의해두면 프로그래밍을 일관성있게 관리할 수 있다. 교체가 쉽다. 🔆 instanceof 연산자와 getClass( ) 메서드 방법 1 String 클래스는 User 클래스는 다르므로   ⇒   false User 클래스는 User 클래스는 같으므로   ⇒   true Manager 클래스는 User 클래스는 다르므로   ⇒   false 방법 2 String 클래스는 User 클래스가 아니고 User의 Sub 클래스도 아니다.   ⇒   false User 클래스는 User 클래스가 맞다.   ⇒   true Manager 클래스는 User 클래스가 아니지만 User의 Sub 클래스이다.   ⇒   true 🔆 메뉴 처리 객체(클래스)의 사용 규칙 통일 상황에 따라 클래스를 가리킬 때도 객체라는 단어를 사용한다. (1) Before 각각의 메뉴 처리 클래스에 대해 사용 방법(매서드 호출)이 다르다. (2) after 객체 사용 규칙 을 통일시킨다.(execute( ))   ⇒   프로그래밍의 일관성 확보 ⇒   유지보수 가 쉬워진다(코드를 해석하기 쉽다)   ⇒   비용 절감 App 18. 리팩토링 : GRASP의 High Cohesion 적용1. 학습목표 GRASP 객체 지향 설계 지침 중에서 High Cohesion을 적용할 수 있다.2. 요구사항 서브 메뉴 처리를 각 Command 구현체에 이전하기3. 작업 Command 인터페이스 변경 execute() 메서드 변경 String name 파라미터 제거 package bitcamp.myapp.command; public interface Command { void execute(); } 회원 서브 메뉴 관련 코드 이전 UserCommand 클래스 변경 App의 printSubMenu()과 subMenus 배열 가져온 후 수정, 생성자 생성 App의 processMenu() 중 서브 메뉴 처리하는 부분 execute()로 가져와서 수정 getMenuTitle(), isValidateMenu() 가져와서 수정 App package bitcamp.myapp.command; import bitcamp.myapp.util.LinkedList; import bitcamp.myapp.util.Prompt; import bitcamp.myapp.vo.User; import static bitcamp.myapp.util.Prompt.input; import static bitcamp.myapp.util.Prompt.inputInt; public class UserCommand implements Command { String menuTitle; LinkedList userList = new LinkedList(); String[] menus = {\"등록\", \"목록\", \"조회\", \"변경\", \"삭제\"}; public UserCommand(String menuTitle) { this.menuTitle = menuTitle; } @Override public void execute() { printMenus(); while (true) { String command = Prompt.input(String.format(\"메인/%s&gt;\", menuTitle)); if (command.equals(\"menu\")) { printMenus(); continue; } else if (command.equals(\"9\")) { return; } try { int menuNo = Integer.parseInt(command); String menuName = getMenuTitle(menuNo); if (menuName == null) { System.out.println(\"올바른 메뉴 번호가 아닙니다.\"); continue; } System.out.printf(\"[%s]\\n\", menuName); switch (menuName) { case \"등록\": addUser(); break; case \"목록\": listUser(); break; case \"조회\": viewUser(); break; case \"변경\": updateUser(); break; case \"삭제\": deleteUser(); break; } } catch (NumberFormatException e) { System.out.println(\"숫자로 메뉴 번호를 입력하세요.\"); } } } private void addUser() { User user = new User(); user.setName(Prompt.input(\"이름?\")); user.setEmail(Prompt.input(\"이메일?\")); user.setPassword(Prompt.input(\"암호?\")); user.setTel(Prompt.input(\"연락처?\")); user.setNo(User.getNextSeqNo()); userList.add(user); } private void listUser() { System.out.println(\"번호 이름 이메일\"); for (Object obj : userList.toArray()) { User user = (User) obj; System.out.printf(\"%d %s %s\\n\", user.getNo(), user.getName(), user.getEmail()); } } private void viewUser() { int userNo = inputInt(\"회원번호?\"); User user = (User) userList.get(userList.indexOf(new User(userNo))); if (user == null) { System.out.println(\"없는 회원입니다.\"); return; } System.out.printf(\"이름: %s\\n\", user.getName()); System.out.printf(\"이메일: %s\\n\", user.getEmail()); System.out.printf(\"연락처: %s\\n\", user.getTel()); } private void updateUser() { int userNo = inputInt(\"회원번호?\"); User user = (User) userList.get(userList.indexOf(new User(userNo))); if (user == null) { System.out.println(\"없는 회원입니다.\"); return; } user.setName(input(String.format(\"이름(%s)?\", user.getName()))); user.setEmail(input(String.format(\"이메일(%s)?\", user.getEmail()))); user.setPassword(input(\"암호?\")); user.setTel(input(String.format(\"연락처(%s)?\", user.getTel()))); System.out.println(\"변경했습니다.\"); } private void deleteUser() { int userNo = inputInt(\"회원번호?\"); User deletedUser = (User) userList.get(userList.indexOf(new User(userNo))); if (deletedUser != null) { userList.remove(userList.indexOf(deletedUser)); System.out.printf(\"'%s' 회원을 삭제 했습니다.\", deletedUser.getName()); } else { System.out.println(\"없는 회원입니다.\"); } } public LinkedList getUserList() { return this.userList; } void printMenus() { System.out.printf(\"[%s]\\n\", menuTitle); for (int i = 0; i &lt; menus.length; i++) { System.out.printf(\"%d. %s\\n\", (i + 1), menus[i]); } System.out.println(\"9. 이전\"); } String getMenuTitle(int menuNo) { return isValidateMenu(menuNo) ? menus[menuNo - 1] : null; } boolean isValidateMenu(int menuNo) { return menuNo &gt;= 1 &amp;&amp; menuNo &lt;= menus.length; } } execute() 메서드에서 메서드 추출하여 processMenu()로 만들기 @Override public void execute() { printMenus(); while (true) { String command = Prompt.input(String.format(\"메인/%s&gt;\", menuTitle)); if (command.equals(\"menu\")) { printMenus(); continue; } else if (command.equals(\"9\")) { return; } try { int menuNo = Integer.parseInt(command); String menuName = getMenuTitle(menuNo); if (menuName == null) { System.out.println(\"올바른 메뉴 번호가 아닙니다.\"); continue; } processMenu(menuName); } catch (NumberFormatException e) { System.out.println(\"숫자로 메뉴 번호를 입력하세요.\"); } } } private void processMenu(String menuName) { System.out.printf(\"[%s]\\n\", menuName); switch (menuName) { case \"등록\": addUser(); break; case \"목록\": listUser(); break; case \"조회\": viewUser(); break; case \"변경\": updateUser(); break; case \"삭제\": deleteUser(); break; } } 프로젝트 서브 메뉴 관련 코드 이전 ProjectCommand 클래스 변경 ProjectCommand package bitcamp.myapp.command; import bitcamp.myapp.util.LinkedList; import bitcamp.myapp.util.Prompt; import bitcamp.myapp.vo.Project; import bitcamp.myapp.vo.User; import static bitcamp.myapp.util.Prompt.input; import static bitcamp.myapp.util.Prompt.inputInt; public class ProjectCommand implements Command { String menuTitle; LinkedList projectList = new LinkedList(); LinkedList userList; String[] menus = {\"등록\", \"목록\", \"조회\", \"변경\", \"삭제\"}; public ProjectCommand(String menuTitle, LinkedList userlist) { this.menuTitle = menuTitle; this.userList = userlist; } @Override public void execute() { printMenus(); while (true) { String command = Prompt.input(String.format(\"메인/%s&gt;\", menuTitle)); if (command.equals(\"menu\")) { printMenus(); continue; } else if (command.equals(\"9\")) { return; } try { int menuNo = Integer.parseInt(command); String menuName = getMenuTitle(menuNo); if (menuName == null) { System.out.println(\"올바른 메뉴 번호가 아닙니다.\"); continue; } processMenu(menuName); } catch (NumberFormatException e) { System.out.println(\"숫자로 메뉴 번호를 입력하세요.\"); } } } private void processMenu(String name) { System.out.printf(\"[%s]\\n\", name); switch (name) { case \"등록\": addProject(); break; case \"목록\": listProject(); break; case \"조회\": viewProject(); break; case \"변경\": updateProject(); break; case \"삭제\": deleteProject(); break; } } private void addProject() { Project project = new Project(); project.setTitle(Prompt.input(\"프로젝트명?\")); project.setDescription(Prompt.input(\"설명?\")); project.setStartDate(Prompt.input(\"시작일?\")); project.setEndDate(Prompt.input(\"종료일?\")); System.out.println(\"팀원:\"); addMembers(project); project.setNo(Project.getNextSeqNo()); projectList.add(project); System.out.println(\"등록했습니다.\"); } private void listProject() { System.out.println(\"번호 프로젝트 기간\"); for (Object obj : projectList.toArray()) { Project project = (Project) obj; System.out.printf(\"%d %s %s ~ %s\\n\", project.getNo(), project.getTitle(), project.getStartDate(), project.getEndDate()); } } private void viewProject() { int projectNo = inputInt(\"프로젝트 번호?\"); Project project = (Project) projectList.get(projectList.indexOf(new Project(projectNo))); if (project == null) { System.out.println(\"없는 프로젝트입니다.\"); return; } System.out.printf(\"프로젝트명: %s\\n\", project.getTitle()); System.out.printf(\"설명: %s\\n\", project.getDescription()); System.out.printf(\"기간: %s ~ %s\\n\", project.getStartDate(), project.getEndDate()); System.out.println(\"팀원:\"); for (int i = 0; i &lt; project.getMembers().size(); i++) { User user = (User) project.getMembers().get(i); System.out.printf(\"- %s\\n\", user.getName()); } } private void updateProject() { int projectNo = inputInt(\"프로젝트 번호?\"); Project project = (Project) projectList.get(projectList.indexOf(new Project(projectNo))); if (project == null) { System.out.println(\"없는 프로젝트입니다.\"); return; } project.setTitle(Prompt.input(String.format(\"프로젝트명(%s)?\", project.getTitle()))); project.setDescription(Prompt.input(String.format(\"설명(%s)?\", project.getDescription()))); project.setStartDate(Prompt.input(String.format(\"시작일(%s)?\", project.getStartDate()))); project.setEndDate(Prompt.input(String.format(\"종료일(%s)?\", project.getEndDate()))); System.out.println(\"팀원:\"); deleteMembers(project); addMembers(project); System.out.println(\"변경했습니다.\"); } private void deleteProject() { int projectNo = Prompt.inputInt(\"프로젝트 번호?\"); // 1부터 시작 Project deletedProject = (Project) projectList.get(projectList.indexOf(new Project(projectNo))); if (deletedProject != null) { projectList.remove(projectList.indexOf(deletedProject)); System.out.printf(\"%d번 프로젝트를 삭제 했습니다.\\n\", deletedProject.getNo()); } else { System.out.println(\"삭제 했습니다.\"); } } private void addMembers(Project project) { while (true) { int userNo = inputInt(\"추가할 팀원 번호?(종료: 0)\"); if (userNo == 0) { break; } User user = (User) userList.get(userList.indexOf(new User(userNo))); if (user == null) { System.out.println(\"없는 회원입니다.\"); continue; } if (project.getMembers().contains(user)) { System.out.printf(\"'%s'은 현재 팀원입니다.\\n\", user.getName()); continue; } project.getMembers().add(user); System.out.printf(\"'%s'을 추가했습니다.\\n\", user.getName()); } } private void deleteMembers(Project project) { for (int i = 0; i &lt; project.getMembers().size(); i++) { User member = (User) project.getMembers().get(i); String str = input(\"팀원(%s) 삭제?\", member.getName()); if (str.equalsIgnoreCase(\"y\")) { project.getMembers().remove(i); System.out.printf(\"'%s' 팀원을 삭제합니다.\\n\", member.getName()); } else { System.out.printf(\"'%s' 팀원을 유지합니다.\\n\", member.getName()); } } } void printMenus() { System.out.printf(\"[%s]\\n\", menuTitle); for (int i = 0; i &lt; menus.length; i++) { System.out.printf(\"%d. %s\\n\", (i + 1), menus[i]); } System.out.println(\"9. 이전\"); } String getMenuTitle(int menuNo) { return isValidateMenu(menuNo) ? menus[menuNo - 1] : null; } boolean isValidateMenu(int menuNo) { return menuNo &gt;= 1 &amp;&amp; menuNo &lt;= menus.length; } } 게시판 서브 메뉴 관련 코드 이전 BoardCommand 클래스 변경 BoardCommand package bitcamp.myapp.command; import bitcamp.myapp.util.LinkedList; import bitcamp.myapp.util.Prompt; import bitcamp.myapp.vo.Board; import java.util.Date; import static bitcamp.myapp.util.Prompt.inputInt; public class BoardCommand implements Command { String menuTitle; LinkedList boardList = new LinkedList(); String[] menus = {\"등록\", \"목록\", \"조회\", \"변경\", \"삭제\"}; public BoardCommand(String menuTitle) { this.menuTitle = menuTitle; } @Override public void execute() { printMenus(); while (true) { String command = Prompt.input(String.format(\"메인/%s&gt;\", menuTitle)); if (command.equals(\"menu\")) { printMenus(); continue; } else if (command.equals(\"9\")) { return; } try { int menuNo = Integer.parseInt(command); String menuName = getMenuTitle(menuNo); if (menuName == null) { System.out.println(\"올바른 메뉴 번호가 아닙니다.\"); continue; } processMenu(menuName); } catch (NumberFormatException e) { System.out.println(\"숫자로 메뉴 번호를 입력하세요.\"); } } } private void processMenu(String menuName) { System.out.printf(\"[%s]\\n\", menuName); switch (menuName) { case \"등록\": addBoard(); break; case \"조회\": viewBoard(); break; case \"목록\": listBoard(); break; case \"변경\": updateBoard(); break; case \"삭제\": deleteBoard(); break; } } private void addBoard() { Board board = new Board(); board.setTitle(Prompt.input(\"제목?\")); board.setContent(Prompt.input(\"내용?\")); board.setCreatedDate(new Date()); board.setNo(Board.getNextSeqNo()); boardList.add(board); System.out.println(\"등록했습니다.\"); } private void listBoard() { System.out.println(\"번호 제목 작성일 조회수\"); for (Object obj : boardList.toArray()) { Board board = (Board) obj; System.out.printf(\"%d %s %tY-%3$tm-%3$td %d\\n\", board.getNo(), board.getTitle(), board.getCreatedDate(), board.getViewCount()); } } private void viewBoard() { int boardNo = inputInt(\"게시글 번호?\"); Board board = (Board) boardList.get(boardList.indexOf(new Board(boardNo))); if (board == null) { System.out.println(\"없는 게시글입니다.\"); return; } board.setViewCount(board.getViewCount() + 1); System.out.printf(\"제목: %s\\n\", board.getTitle()); System.out.printf(\"내용: %s\\n\", board.getContent()); System.out.printf(\"작성일: %1$tY-%1$tm-%1$td %1$tH:%1$tM:%1$tS\\n\", board.getCreatedDate()); System.out.printf(\"조회수: %d\\n\", board.getViewCount()); } private void updateBoard() { int boardNo = inputInt(\"게시글 번호?\"); Board board = (Board) boardList.get(boardList.indexOf(new Board(boardNo))); if (board == null) { System.out.println(\"없는 게시글입니다.\"); return; } board.setTitle(Prompt.input(\"제목(%s)?\", board.getTitle())); board.setContent(Prompt.input(\"내용(%s)?\", board.getContent())); System.out.println(\"변경했습니다.\"); } private void deleteBoard() { int boardNo = inputInt(\"게시글 번호?\"); Board deletedBoard = (Board) boardList.get(boardList.indexOf(new Board(boardNo))); if (deletedBoard != null) { boardList.remove(boardList.indexOf(deletedBoard)); System.out.printf(\"%d번 게시글을 삭제 했습니다.\\n\", deletedBoard.getNo()); } else { System.out.println(\"없는 게시글입니다.\"); } } void printMenus() { System.out.printf(\"[%s]\\n\", menuTitle); for (int i = 0; i &lt; menus.length; i++) { System.out.printf(\"%d. %s\\n\", (i + 1), menus[i]); } System.out.println(\"9. 이전\"); } String getMenuTitle(int menuNo) { return isValidateMenu(menuNo) ? menus[menuNo - 1] : null; } boolean isValidateMenu(int menuNo) { return menuNo &gt;= 1 &amp;&amp; menuNo &lt;= menus.length; } } App 클래스 변경 서브 메뉴 관련 코드 제거, execute(), processMenu() 정리 App package bitcamp.myapp; import bitcamp.myapp.command.BoardCommand;import bitcamp.myapp.command.ProjectCommand;import bitcamp.myapp.command.UserCommand;import bitcamp.myapp.util.Prompt; public class App { String[] mainMenus = {\"프로젝트\", \"게시판\", \"도움말\", \"종료\"}; UserCommand userCommand = new UserCommand(\"회원\"); BoardCommand boardCommand = new BoardCommand(\"게시판\"); ProjectCommand projectCommand = new ProjectCommand(\"프로젝트\", userCommand.getUserList()); public static void main(String[] args) { new App().execute(); } void execute() { printMenu(); String command; while (true) { try { command = Prompt.input(\"메인&gt;\"); if (command.equals(\"menu\")) { printMenu(); } else { int menuNo = Integer.parseInt(command); String menuTitle = getMenuTitle(menuNo, mainMenus); if (menuTitle == null) { System.out.println(\"올바른 메뉴 번호가 아닙니다.\"); } else if (menuTitle.equals(\"종료\")) { break; } else { processMenu(menuTitle); } } } catch (NumberFormatException e) { System.out.println(\"메뉴를 숫자로 입력하세요.\"); } } System.out.println(\"종료합니다.\"); Prompt.close(); } void printMenu() { String bold = \"\\u001B[1m\"; String red = \"\\u001B[31m\"; String reset = \"\\u001B[0m\"; String appTitle = \"[팀 프로젝트 관리 시스템]\"; String line = \"--------------------------------------------\"; System.out.println(bold + line + reset); System.out.println(bold + appTitle + reset); for (int i = 0; i &lt; mainMenus.length; i++) { if (i == mainMenus.length - 1) { System.out.printf(\"%s%s%d. %s%s\\n\", bold, red, i + 1, mainMenus[i], reset); } else { System.out.printf(\"%d. %s\\n\", i + 1, mainMenus[i]); } } System.out.println(bold + line + reset); } boolean isValidateMenu(int menuNo, String[] menus) { return menuNo &gt;= 1 &amp;&amp; menuNo &lt;= menus.length; } String getMenuTitle(int menuNo, String[] menus) { return isValidateMenu(menuNo, menus) ? menus[menuNo - 1] : null; } void processMenu(String menuTitle) { switch (menuTitle) { case \"회원\": userCommand.execute(); break; case \"프로젝트\": projectCommand.execute(); break; case \"게시판\": boardCommand.execute(); break; case \"도움말\": System.out.println(\"도움말입니다.\"); break; default: System.out.printf(\"%s 메뉴의 명령을 처리할 수 없습니다.\\n\", menuTitle); } } } 결과 변경 없음 🔆 18. 리펙토링 - (1) 문제점 서브 메뉴를 변경하면 서브 메뉴 처리를 다루는 것도 변경해야 한다. 메인 메뉴도 다루고 서브 메뉴도 다룬다.   ⇒   응집력이 좋지 않다 !!🔆 18. 리펙토링 - (2) 해결 : GRASP의 High Cohesion 적용 subMenus : Stirng[]을 Command 구현체로 이동시킨다. ⇒   서브 메뉴를 다루는 것은 Command 구현체에게 맡긴다. ⇒   응집력을 높힌다 !! App 19. 리팩토링 : 상속의 Generalization 적용1. 학습목표 상속의 Generalization을 이해하고 적용할 수 있다. 추상 클래스의 역할을 이해하고 적용할 수 있다. GoF의 Template Method 설계 패턴을 적용할 수 있다.2. 요구사항 ArrayList, LinkedList의 공통 코드를 분리하여 상속의 Generalization으로 처리 UserCommand, ProjectCommand, BoardCommand의 blue&gt;공통 코드&lt;/span&gt;를 분리하여 상속의 Generalization으로 처리3. 작업 ArrayList, LinkedList 일반화 하기 ArrayList와 LinkedList의 공통 분모를 추출한다. AbstractList 클래스 추가 두 클래스의 공통 분모인 int size, size()를 가지고 생성 단, 하위 클래스에서 사용할 수 있도록 접근 제한자를 protected로 설정 package bitcamp.myapp.util; public abstract class AbstractList implements List { protected int size = 0; @Override public int size() { return size; } } ArrayList, LinkedList는 AbstractList 를 상속한다. ArrayList 변경 public class ArrayList extends AbstractList { private static final int MAX_SIZE = 100; private Object[] list = new Object[MAX_SIZE]; ... LinkedList 변경 public class LinkedList extends AbstractList { Node first; Node last; ... XxxCommand 일반화 하기 “도움말” 메뉴를 처리할 코드를 별도의 클래스로 분리 HelpCommand 클래스 정의 package bitcamp.myapp.command; public class HelpCommand implements Command { String menuTitle; public HelpCommand(String menuTitle) { this.menuTitle = menuTitle; } public void execute() { System.out.println(\"도움말입니다.\"); } } App 클래스 public class App { String[] mainMenus = {\"프로젝트\", \"게시판\", \"도움말\", \"종료\"}; UserCommand userCommand = new UserCommand(\"회원\"); BoardCommand boardCommand = new BoardCommand(\"게시판\"); ProjectCommand projectCommand = new ProjectCommand(\"프로젝트\", userCommand.getUserList()); HelpCommand helpCommand = new HelpCommand(\"도움말\"); ... void processMenu(String menuTitle) { switch (menuTitle) { case \"회원\": userCommand.execute(); break; case \"프로젝트\": projectCommand.execute(); break; case \"게시판\": boardCommand.execute(); break; case \"도움말\": helpCommand.execute(); break; default: System.out.printf(\"%s 메뉴의 명령을 처리할 수 없습니다.\\n\", menuTitle); } } XxxCommand의 공통 코드를 추출하여 수퍼 클래스로 정의 AbstractCommand 추상 클래스 정의 protected String menuTitle를 가져오고 생성자를 생성한다. 추상 클래스는 공통 코드를 두는 곳이다. String[] menus = {\"등록\", \"목록\", \"조회\", \"변경\", \"삭제\"};를 가져오면 메뉴마다 menus의 내용이 달라질 수 있다는 문제가 있다. ⇒   템플릿 메서드를 이용하여 해결 ⭐ GoF 템플릿 메서드 설계 패턴 적용 ⭐ printMenus()를 가져와서 수정한다. getMenus()를 추상 메서드로 하여 구체적인 동작은 서브 클래스에서 정의한다 protected String menuTitle; public AbstractCommand(String menuTitle) { this.menuTitle = menuTitle; } private void printMenus() { String[] menus = getMenus(); System.out.printf(\"[%s]\\n\", menuTitle); for (int i = 0; i &lt; menus.length; i++) { System.out.printf(\"%d. %s\\n\", (i + 1), menus[i]); } System.out.println(\"9. 이전\"); } protected abstract String[] getMenus(); ⭐ GoF 템플릿 메서드 설계 패턴 적용 ⭐ execute()를 가져와서 수정한다. processMenu() 추상메서드를 미리 만들어 놓고 사용한다. 구현은 하위 클래스에서 하도록 강제한다. @Override public void execute() { printMenus(); while (true) { String command = Prompt.input(String.format(\"메인/%s&gt;\", menuTitle)); if (command.equals(\"menu\")) { printMenus(); continue; } else if (command.equals(\"9\")) { return; } try { int menuNo = Integer.parseInt(command); String menuName = getMenuTitle(menuNo); if (menuName == null) { System.out.println(\"올바른 메뉴 번호가 아닙니다.\"); continue; } processMenu(menuName); } catch (NumberFormatException e) { System.out.println(\"숫자로 메뉴 번호를 입력하세요.\"); } } } protected abstract void processMenu(String menuName); getMenuTitle(), isValidateMenu()를 추상클래스로 가져와서 수정 private String getMenuTitle(int menuNo) { String[] menus = getMenus(); return isValidateMenu(menuNo) ? menus[menuNo - 1] : null; } private boolean isValidateMenu(int menuNo) { String[] menus = getMenus(); return menuNo &gt;= 1 &amp;&amp; menuNo &lt;= menus.length; } AbstractCommand package bitcamp.myapp.command; import bitcamp.myapp.util.Prompt; public abstract class AbstractCommand implements Command { protected String menuTitle; public AbstractCommand(String menuTitle) { this.menuTitle = menuTitle; } private void printMenus() { String[] menus = getMenus(); System.out.printf(\"[%s]\\n\", menuTitle); for (int i = 0; i &lt; menus.length; i++) { System.out.printf(\"%d. %s\\n\", (i + 1), menus[i]); } System.out.println(\"9. 이전\"); } protected abstract String[] getMenus(); @Override public void execute() { printMenus(); while (true) { String command = Prompt.input(String.format(\"메인/%s&gt;\", menuTitle)); if (command.equals(\"menu\")) { printMenus(); continue; } else if (command.equals(\"9\")) { return; } try { int menuNo = Integer.parseInt(command); String menuName = getMenuTitle(menuNo); if (menuName == null) { System.out.println(\"올바른 메뉴 번호가 아닙니다.\"); continue; } processMenu(menuName); } catch (NumberFormatException e) { System.out.println(\"숫자로 메뉴 번호를 입력하세요.\"); } } } protected abstract void processMenu(String menuName); private String getMenuTitle(int menuNo) { String[] menus = getMenus(); return isValidateMenu(menuNo) ? menus[menuNo - 1] : null; } private boolean isValidateMenu(int menuNo) { String[] menus = getMenus(); return menuNo &gt;= 1 &amp;&amp; menuNo &lt;= menus.length; } } UserCommand, ProjectCommand, BoardCommand 클래스를 서브 클래스로 정의 App에서 생성자로 받은 파라미터를 super 클래스의 생성자를 호출하며 전달한다. 추상 메서드인 getMenus()를 menus 필드를 반환하도록 구현하고 menus 필드를 private으로 전환한다. 기존의 processMenus()를 @Override 처리하고 protected로 전환하면 구현 완료된다. UserCommand package bitcamp.myapp.command; import bitcamp.myapp.util.LinkedList; import bitcamp.myapp.util.Prompt; import bitcamp.myapp.vo.User; import static bitcamp.myapp.util.Prompt.input; import static bitcamp.myapp.util.Prompt.inputInt; public class UserCommand extends AbstractCommand { LinkedList userList = new LinkedList(); private String[] menus = {\"등록\", \"목록\", \"조회\", \"변경\", \"삭제\"}; public UserCommand(String menuTitle) { super(menuTitle); } @Override protected void processMenu(String menuName) { System.out.printf(\"[%s]\\n\", menuName); switch (menuName) { case \"등록\": addUser(); break; case \"목록\": listUser(); break; case \"조회\": viewUser(); break; case \"변경\": updateUser(); break; case \"삭제\": deleteUser(); break; } } private void addUser() { User user = new User(); user.setName(Prompt.input(\"이름?\")); user.setEmail(Prompt.input(\"이메일?\")); user.setPassword(Prompt.input(\"암호?\")); user.setTel(Prompt.input(\"연락처?\")); user.setNo(User.getNextSeqNo()); userList.add(user); } private void listUser() { System.out.println(\"번호 이름 이메일\"); for (Object obj : userList.toArray()) { User user = (User) obj; System.out.printf(\"%d %s %s\\n\", user.getNo(), user.getName(), user.getEmail()); } } private void viewUser() { int userNo = inputInt(\"회원번호?\"); User user = (User) userList.get(userList.indexOf(new User(userNo))); if (user == null) { System.out.println(\"없는 회원입니다.\"); return; } System.out.printf(\"이름: %s\\n\", user.getName()); System.out.printf(\"이메일: %s\\n\", user.getEmail()); System.out.printf(\"연락처: %s\\n\", user.getTel()); } private void updateUser() { int userNo = inputInt(\"회원번호?\"); User user = (User) userList.get(userList.indexOf(new User(userNo))); if (user == null) { System.out.println(\"없는 회원입니다.\"); return; } user.setName(input(String.format(\"이름(%s)?\", user.getName()))); user.setEmail(input(String.format(\"이메일(%s)?\", user.getEmail()))); user.setPassword(input(\"암호?\")); user.setTel(input(String.format(\"연락처(%s)?\", user.getTel()))); System.out.println(\"변경했습니다.\"); } private void deleteUser() { int userNo = inputInt(\"회원번호?\"); User deletedUser = (User) userList.get(userList.indexOf(new User(userNo))); if (deletedUser != null) { userList.remove(userList.indexOf(deletedUser)); System.out.printf(\"'%s' 회원을 삭제 했습니다.\", deletedUser.getName()); } else { System.out.println(\"없는 회원입니다.\"); } } public LinkedList getUserList() { return this.userList; } @Override protected String[] getMenus() { return menus; } } BoardCommand package bitcamp.myapp.command; import bitcamp.myapp.util.LinkedList; import bitcamp.myapp.util.Prompt; import bitcamp.myapp.vo.Board; import java.util.Date; import static bitcamp.myapp.util.Prompt.inputInt; public class BoardCommand extends AbstractCommand { LinkedList boardList = new LinkedList(); private String[] menus = {\"등록\", \"목록\", \"조회\", \"변경\", \"삭제\"}; public BoardCommand(String menuTitle) { super(menuTitle); } @Override protected void processMenu(String menuName) { System.out.printf(\"[%s]\\n\", menuName); switch (menuName) { case \"등록\": addBoard(); break; case \"조회\": viewBoard(); break; case \"목록\": listBoard(); break; case \"변경\": updateBoard(); break; case \"삭제\": deleteBoard(); break; } } private void addBoard() { Board board = new Board(); board.setTitle(Prompt.input(\"제목?\")); board.setContent(Prompt.input(\"내용?\")); board.setCreatedDate(new Date()); board.setNo(Board.getNextSeqNo()); boardList.add(board); System.out.println(\"등록했습니다.\"); } private void listBoard() { System.out.println(\"번호 제목 작성일 조회수\"); for (Object obj : boardList.toArray()) { Board board = (Board) obj; System.out.printf(\"%d %s %tY-%3$tm-%3$td %d\\n\", board.getNo(), board.getTitle(), board.getCreatedDate(), board.getViewCount()); } } private void viewBoard() { int boardNo = inputInt(\"게시글 번호?\"); Board board = (Board) boardList.get(boardList.indexOf(new Board(boardNo))); if (board == null) { System.out.println(\"없는 게시글입니다.\"); return; } board.setViewCount(board.getViewCount() + 1); System.out.printf(\"제목: %s\\n\", board.getTitle()); System.out.printf(\"내용: %s\\n\", board.getContent()); System.out.printf(\"작성일: %1$tY-%1$tm-%1$td %1$tH:%1$tM:%1$tS\\n\", board.getCreatedDate()); System.out.printf(\"조회수: %d\\n\", board.getViewCount()); } private void updateBoard() { int boardNo = inputInt(\"게시글 번호?\"); Board board = (Board) boardList.get(boardList.indexOf(new Board(boardNo))); if (board == null) { System.out.println(\"없는 게시글입니다.\"); return; } board.setTitle(Prompt.input(\"제목(%s)?\", board.getTitle())); board.setContent(Prompt.input(\"내용(%s)?\", board.getContent())); System.out.println(\"변경했습니다.\"); } private void deleteBoard() { int boardNo = inputInt(\"게시글 번호?\"); Board deletedBoard = (Board) boardList.get(boardList.indexOf(new Board(boardNo))); if (deletedBoard != null) { boardList.remove(boardList.indexOf(deletedBoard)); System.out.printf(\"%d번 게시글을 삭제 했습니다.\\n\", deletedBoard.getNo()); } else { System.out.println(\"없는 게시글입니다.\"); } } @Override protected String[] getMenus() { return menus; } } ProjectCommand package bitcamp.myapp.command; import bitcamp.myapp.util.LinkedList; import bitcamp.myapp.util.Prompt; import bitcamp.myapp.vo.Project; import bitcamp.myapp.vo.User; import static bitcamp.myapp.util.Prompt.input; import static bitcamp.myapp.util.Prompt.inputInt; public class ProjectCommand extends AbstractCommand { LinkedList projectList = new LinkedList(); LinkedList userList; private String[] menus = {\"등록\", \"목록\", \"조회\", \"변경\", \"삭제\"}; public ProjectCommand(String menuTitle, LinkedList userlist) { super(menuTitle); this.userList = userlist; } @Override protected void processMenu(String name) { System.out.printf(\"[%s]\\n\", name); switch (name) { case \"등록\": addProject(); break; case \"목록\": listProject(); break; case \"조회\": viewProject(); break; case \"변경\": updateProject(); break; case \"삭제\": deleteProject(); break; } } private void addProject() { Project project = new Project(); project.setTitle(Prompt.input(\"프로젝트명?\")); project.setDescription(Prompt.input(\"설명?\")); project.setStartDate(Prompt.input(\"시작일?\")); project.setEndDate(Prompt.input(\"종료일?\")); System.out.println(\"팀원:\"); addMembers(project); project.setNo(Project.getNextSeqNo()); projectList.add(project); System.out.println(\"등록했습니다.\"); } private void listProject() { System.out.println(\"번호 프로젝트 기간\"); for (Object obj : projectList.toArray()) { Project project = (Project) obj; System.out.printf(\"%d %s %s ~ %s\\n\", project.getNo(), project.getTitle(), project.getStartDate(), project.getEndDate()); } } private void viewProject() { int projectNo = inputInt(\"프로젝트 번호?\"); Project project = (Project) projectList.get(projectList.indexOf(new Project(projectNo))); if (project == null) { System.out.println(\"없는 프로젝트입니다.\"); return; } System.out.printf(\"프로젝트명: %s\\n\", project.getTitle()); System.out.printf(\"설명: %s\\n\", project.getDescription()); System.out.printf(\"기간: %s ~ %s\\n\", project.getStartDate(), project.getEndDate()); System.out.println(\"팀원:\"); for (int i = 0; i &lt; project.getMembers().size(); i++) { User user = (User) project.getMembers().get(i); System.out.printf(\"- %s\\n\", user.getName()); } } private void updateProject() { int projectNo = inputInt(\"프로젝트 번호?\"); Project project = (Project) projectList.get(projectList.indexOf(new Project(projectNo))); if (project == null) { System.out.println(\"없는 프로젝트입니다.\"); return; } project.setTitle(Prompt.input(String.format(\"프로젝트명(%s)?\", project.getTitle()))); project.setDescription(Prompt.input(String.format(\"설명(%s)?\", project.getDescription()))); project.setStartDate(Prompt.input(String.format(\"시작일(%s)?\", project.getStartDate()))); project.setEndDate(Prompt.input(String.format(\"종료일(%s)?\", project.getEndDate()))); System.out.println(\"팀원:\"); deleteMembers(project); addMembers(project); System.out.println(\"변경했습니다.\"); } private void deleteProject() { int projectNo = Prompt.inputInt(\"프로젝트 번호?\"); // 1부터 시작 Project deletedProject = (Project) projectList.get(projectList.indexOf(new Project(projectNo))); if (deletedProject != null) { projectList.remove(projectList.indexOf(deletedProject)); System.out.printf(\"%d번 프로젝트를 삭제 했습니다.\\n\", deletedProject.getNo()); } else { System.out.println(\"삭제 했습니다.\"); } } private void addMembers(Project project) { while (true) { int userNo = inputInt(\"추가할 팀원 번호?(종료: 0)\"); if (userNo == 0) { break; } User user = (User) userList.get(userList.indexOf(new User(userNo))); if (user == null) { System.out.println(\"없는 회원입니다.\"); continue; } if (project.getMembers().contains(user)) { System.out.printf(\"'%s'은 현재 팀원입니다.\\n\", user.getName()); continue; } project.getMembers().add(user); System.out.printf(\"'%s'을 추가했습니다.\\n\", user.getName()); } } private void deleteMembers(Project project) { for (int i = 0; i &lt; project.getMembers().size(); i++) { User member = (User) project.getMembers().get(i); String str = input(\"팀원(%s) 삭제?\", member.getName()); if (str.equalsIgnoreCase(\"y\")) { project.getMembers().remove(i); System.out.printf(\"'%s' 팀원을 삭제합니다.\\n\", member.getName()); } else { System.out.printf(\"'%s' 팀원을 유지합니다.\\n\", member.getName()); } } } @Override protected String[] getMenus() { return menus; } } 결과 변경 없음 🔆 상속의 Generalization - (1) before Before LinkedList와 ArrayList의 다른 메서드들은 구동 원리가 다르므로 공통 코드로 뽑을 수 없다. ArrayList의 add()와 LinkedList의 add() 처럼 두 클래스의 메서드는 내부 코드가 다르다. 그런데 1개 같은 것이 있다. size()이다. size() 메서드는 동일하므로 메서드를 뽑아서 추상클래스를 생성한다. &lt;&lt;concrete&gt;&gt;   :   일반적으로 인스턴스를 생성해서 쓸 수 있는 클래스🔆 상속의 Generalization - (1) after After 서브 클래스에게 공통 필드나 메서드를 상속해주는 역할을 하는 추상 클래스를 만든다. 추상 클래스는 인스턴스를 생성할 수 없어서 직접 사용 불가능하다. 이 추상 클래스를 상속 받은 클래스로 인스턴스를 생성하여 사용한다. 🔆 상속의 Generalization - (2) before Before 3개에는 공통 코드가 있으나 나머지 1개(Help)에는 공통 코드가 1개 뿐이다. 🔆 상속의 Generalization - (2) after After 공통 코드를 추출하여 상위 클래스를 생성하고 이 클래스를 추상클래스로 만든다. 이 추상클래스는 인터페이스의 규칙을 따른다. " }, { "title": "App 15-16. ArrayList와 LinkedList", "url": "/posts/app-15-16/", "categories": "개인 공부, myapp 혼자 다시해보기, 1단계-Java기초", "tags": "LinkedList, ArrayList, 배열", "date": "2024-12-22 10:00:00 +0900", "snippet": "App 15. 배열 크기 자동 증가시키기 : 배열 복제와 문제점1. 학습목표 배열의 크기를 증가시킬 수 있다. 배열로 데이터를 저장하는 방식의 장점과 단점을 설명할 수 있다.2. 요구사항 데이터의 저장 개수를 무제한으로 만들기3. 작업 배열 확장 하기 ArrayList 클래스 변경 add() 메서...", "content": "App 15. 배열 크기 자동 증가시키기 : 배열 복제와 문제점1. 학습목표 배열의 크기를 증가시킬 수 있다. 배열로 데이터를 저장하는 방식의 장점과 단점을 설명할 수 있다.2. 요구사항 데이터의 저장 개수를 무제한으로 만들기3. 작업 배열 확장 하기 ArrayList 클래스 변경 add() 메서드 변경 배열이 꽉 차면(size == list.length) 1.5배의 새로운 배열을 만들어 복제한다. 기존 레퍼런스에 새로운 배열의 주소를 담는다. public void add(Object obj) { list[size++] = obj; if (size == list.length) { int oldSize = list.length; int newSize = oldSize + (oldSize / 2); Object[] arr = new Object[newSize]; for (int i = 0; i &lt; list.length; i++) { arr[i] = list[i]; } list = arr; System.out.println(\"배열 크기 증가!\"); } list[size++] = obj; } add() 메서드의 배열 확장 부분을 grow() 메서드로 추출 public void add(Object obj) { list[size++] = obj; if (size == list.length) { grow(); } list[size++] = obj; } private void grow() { int oldSize = list.length; int newSize = oldSize + (oldSize / 2); Object[] arr = new Object[newSize]; for (int i = 0; i &lt; list.length; i++) { arr[i] = list[i]; } list = arr; System.out.println(\"배열 크기 증가!\"); } Java에서 제공하는 클래스로 배열 크기 증가하기 Arrays.copyOf( ) 활용 ⭐ 비트 연산자 &gt;&gt; 1가 결과는 동일하지만 / 2 연산보다 실행 속도가 빠르다. ⭐ copyOf(기존 배열, 새로운 크기) public void add(Object obj) { list[size++] = obj; if (size == list.length) { int oldSize = list.length; int newSize = oldSize + (oldSize &gt;&gt; 1); list = Arrays.copyOf(list, newSize); } list[size++] = obj; } 결과 변경 없음 🔆 15. 배열 크기를 자동으로 증가시키기 배열은 처음 생성할 때 크기로 고정된다.   (크기를 변경할 수 없다) 기존 배열보다 더 큰 배열 생성 후 기존 배열의 값을 복사해온다.App 16. LinkedList 자료 구조 구현하기 : 배열의 단점 극복1. 학습목표 LinkedList의 구동 원리를 설명하고 구현할 수 있다. 배열을 사용할 때 유리한 경우와 LinkedList를 사용할 때 유리한 경우를 설명할 수 있다.2. 요구사항 배열로 데이터 목록을 다루는 대신에 LinkedList 자료 구조를 이용하여 데이터 목록을 다루기3. 작업 값을 보관한 노드 역할을 할 클래스를 정의한다. Node 클래스 추가 package bitcamp.myapp.command; public class Node { Object value; Node next; public Node(Object value) { this.value = value; } } Linked List 자료구조를 구현한다. LinkedList 클래스 구현 apend(), delete(), getValue(), index(), getArray(), size() LinkedList package bitcamp.myapp.command; public class LinkedList { Node first; Node last; int size; public void append(Object value) { Node newNode = new Node(value); if (first == null) { first = newNode; } else { last.next = newNode; last = newNode; } size++; } public Object getValue(int index) { if (index &lt; 0 || index &gt;= size) { return null; } Node cursor = first; int currentIndex = 0; while (cursor != null) { if (currentIndex == index) { return cursor.value; } cursor = cursor.next; currentIndex++; } return null; } public Object delete(int index) { if (index &lt; 0 || index &gt;= size) { return null; } Node deletedNode = null; size--; if (index == 0) { deletedNode = first; first = first.next; if (first == null) { last = null; } return deletedNode.value; } Node cursor = first; int currentIndex = 0; while (cursor != null) { if (currentIndex == (index - 1)) { break; } cursor = cursor.next; currentIndex++; } deletedNode = cursor.next; cursor.next = cursor.next.next; if (cursor.next == null) { last = cursor; } return deletedNode.value; } public int index(Object value) { Node cursor = first; int currentIndex = 0; while (cursor != null) { if (cursor.value == value) { return currentIndex; } cursor = cursor.next; currentIndex++; } return -1; } public Object[] getArray() { Object[] arr = new Object[size]; Node cursor = first; for (int i = 0; i &lt; size; i++) { arr[i] = cursor.value; cursor = cursor.next; } return arr; } public int size() { return size; } } UserList 클래스의 수퍼 클래스를 ArrayList 대신 LinkedList로 교체한다. UserList 클래스 변경 package bitcamp.myapp.command; import bitcamp.myapp.vo.User; public class UserList extends LinkedList { public User findByNo(int userNo) { for (int i = 0; i &lt; size(); i++) { User user = (User) getValue(i); if (user.getNo() == userNo) { return user; } } return null; } } UserList 클래스 변경에 따라 UserCommand 클래스를 변경한다. UserCommand 클래스 변경 UserList 클래스에서 ArrayList에서 LinkedList로의 super 클래스 교체에 따라 사용법(메서드 규칙)이 달라졌기 때문에 코드 변경 발생한다. ... private void addUser() { User user = new User(); user.setName(Prompt.input(\"이름?\")); user.setEmail(Prompt.input(\"이메일?\")); user.setPassword(Prompt.input(\"암호?\")); user.setTel(Prompt.input(\"연락처?\")); user.setNo(User.getNextSeqNo()); userList.append(user); } private void listUser() { System.out.println(\"번호 이름 이메일\"); for (Object obj : userList.getArray()) { User user = (User) obj; System.out.printf(\"%d %s %s\\n\", user.getNo(), user.getName(), user.getEmail()); } } ... private void deleteUser() { int userNo = inputInt(\"회원번호?\"); User deletedUser = userList.findByNo(userNo); if (deletedUser != null) { userList.delete(userList.index(deletedUser)); System.out.printf(\"'%s' 회원을 삭제 했습니다.\", deletedUser.getName()); } else { System.out.println(\"없는 회원입니다.\"); } } 결과 변경 없음 🔆 16. LinkedList 자료 구조 구현하기 배열 방식 장점 메모리 크기 고정   ⇒   인덱스를 이용한 접근이 용이 단점 메모리 크기를 늘릴 수 없다(추가 저장 불가)   ⇒   새 배열을 만든 후 기존 배열 값 복제 ⇒   가비지가 많이 생성된다. 삽입, 삭제할 때 항목의 값을 밀고, 당기고 해야 하기 때문에 실행 속도가 떨어진다. 단점 극복   ⇒   Linked List 방식으로 데이터를 저장 메모리를 늘리기 쉽다. 삽입, 삭제가 쉽다. 단점   :   데이터 조회 시 시간이 많이 소요 데이터를 조회할 때는 배열이 linkedlist보다 빠르다. 대신 삽입, 삭제의 경우 반대이다.🔆 Linked List의 구동 원리 - (1) 입력 입력   :   append() 메서드   (add() 메서드) @Override public void add(Object value) { Node newNode = new Node(value); // if (first == null) { last = first = newNode; } else { last.next = newNode; last = newNode; // } size++; } 새 값을 파라미터로 넣으면 값을 받아 새로운 노드를 생성한다. 기존의 노드가 없다면 새로운 노드를 첫 노드와 끝노드로 설정한다. 기존의 노드가 있다면 기존의 마지막 노드의 next 필드 에 새로운 노드를 넣어 연결시킨다. 마지막 노드를 새로운 노드를 가리키도록 한다. size를 1 증가시킨다. 🔆 Linked List의 구동 원리 - (2) 조회 조회   :   getValue() 메서드   (get() 메서드) @Override public Object get(int index) { if (index &lt; 0 || index &gt;= size) { return null; } Node cursor = first; int currentIndex = 0; while (cursor != null) { if (currentIndex == index) { return cursor.value; } cursor = cursor.next; currentIndex++; } return null; } list.getValue(index)를 호출하면 먼저 index가 유효한지 평가한다. 유효하지 않다면 null을 반환한다. 현재 위치를 파악하기 위해 새로운 Node 객체(cursor)와 현재 인덱스(currentIndex)를 만든다. cursor가 null이 아닌 어떠한 노드를 가리킨다면 반복 시행한다. 반복하다가 currentIndex와 매개변수로 받은 index가 같은 경우 인덱스에 해당하는 노드의 값을 반환한다. index가 같지 않다면 cursor를 다음 노드로 이동시키고 현재 인덱스도 1증가시켜준다. 모두 돌아도 찾지 못한다면 null을 반환한다. 0번째 값을 가져오기 list.getValue(0) 현재 상태   :   first-[200], last-[400] cursor는 첫번째 노드로, currentIndex는 0으로 초기화된다. (cursor-[200], currentIndex-[0]) 꺼내려는 값 : 0번       currentIndex : 0번 ⇒   첫번째 노드의 값을 꺼낸다.   ⇒   즉 “홍길동”을 return한다. 1번째 값을 가져오기 list.getValue(1) 현재 상태   :   first-[200], last-[400] cursor-[200], currentIndex-[0] 꺼내려는 값 : 1번       currentIndex : 0번 ⇒   같지 않으므로 cursor를 다음으로 이동 (cursor.next) ⇒   꺼내려는 값 : 1번       currentIndex : 1번 ⇒   2번째 노드의 값을 꺼낸다.   ⇒   “임꺽정”을 return한다. 2번째 값을 가져오기 list.getValue(2) 현재 상태   :   first-[200], last-[400] cursor-[200], currentIndex-[0] 꺼내려는 값 : 2번       currentIndex : 0번 ⇒   같지 않으므로 cursor를 다음으로 이동 (cursor.next) ⇒   꺼내려는 값 : 2번       currentIndex : 1번 ⇒   같지 않으므로 cursor를 다음으로 이동 (cursor.next) ⇒   꺼내려는 값 : 2번       currentIndex : 2번 ⇒   3번째 노드의 값을 꺼낸다.   ⇒   “유관순”을 return한다. 🔆 Linked List의 구동 원리 : (3) 삭제 - ① 첫번째 노드⭐ 삭제   :   delete() 메서드   (remove() 메서드) 제거하는 방식은 경우의 수를 3가지로 나눠서 제거해야 한다. 첫번째 노드를 제거하는 경우 중간 노드를 제거하는 경우 마지막 노드를 제거하는 경우 첫번째 값을 제거하기   (0번째 값 제거) @Override public Object remove(int index) { if (index &lt; 0 || index &gt;= size) { **** return null; } Node deletedNode = null; size--; if (index == 0) { deletedNode = first; first = first.next; if (first == null) { last = null; } return deletedNode.value; } 제거를 원하는 값의 인덱스를 파라미터로 받는다. 해당 index를 유효성 검사한다. 유효하다면 제거 메서드를 실행하는 것이므로 우선 size--한다. (지역 변수이므로 찾아야 하는 노드 변수를 미리 선언하고 null로 초기화) 제거할 노드의 인덱스가 0일 때 제거할 노드 정보를 따로 저장하고 first가 2번째 노드(first.next)를 가리키도록 한다. 만약 바뀐 first가 null을 가리킨다면, 즉 다음 노드를 가리켰는데 그것이 null이라면 마지막 노드 역시 null로 해줘야 한다. 따로 저장한 노드의 값을 반환한다. first가 null일 때 last도 null이 되게 하는 조건을 추가해야 한다. ⭐ 마지막 노드를 삭제하면 주소가 400번지인 인스턴스를 참조하는 마지막 노드를 fisrt가 가리키지 않고 null을 가리킨다. 그러나 아직 last는 마지막 노드를 가리키고 있기 때문에 마지막 노드가 가비지가 되지 않는다 🔆 Linked List의 구동 원리 : (3) 삭제 - ② 중간 노드⭐ 중간 값을 제거하기 현재 인덱스를 나타내는 currentIndex을 만들고 현재 인덱스에 해당하는 노드를 가리키는 cursor라는 노드를 만든다. 현재 인덱스를 증가시키며 cursor 노드를 이동시켜서 원하는 노드를 찾고 제거하는 방식이다.   (조회와 동일) 단, cursor 노드를 제거를 원하는 노드 바로 전까지 이동시킨다. 제거를 원하는 노드의 바로 전 노드의 next 값을 바꿔서 연결을 차단하고 그 다음 것과 연결하여 제거한다. Node cursor = first; int currentIndex = 0; while (cursor != null) { if (currentIndex == (index - 1)) { break; } cursor = cursor.next; currentIndex++; } deletedNode = cursor.next; **cursor.next** = **cursor.next.next**; cursor라는 노드를 만들고 첫 노드를 가리키도록 한다. 현재 인덱스 정보(currentIndex)로 cursor와 같이 움직인다. 조회와 같은 방식으로 반복문을 통해 이동하며 cursor와 currentIndex를 지우려는 노드 바로 전까지만 이동시킨다. 바로 전의 노드에 도달하면 다음 노드(cursor.next)의 정보를 따로 저장해두고 다음 노드를 가리키던 것을 다다음 노드를 가리키도록 변경 예시   (4번째 노드 제거) cursor가 2번(400)에 도달했을때 2번의 next를 500에서 600으로 바꾸면 연결이 끊어지고 4번(600)이 뒤에 붙는다. 기존 cursor.next는 500번지로 삭제하려는 노드의 주소이고 cursor.next.next는 600번지이다. 🔆 Linked List의 구동 원리 : (3) 삭제 - ③ 마지막 노드⭐ 마지막 값을 제거하기 중간 값 제거와 과정은 동일하게 제거를 원하는 노드(마지막 노드) 바로 전까지 cursor 노드를 이동시킨 뒤 제거한다. 단, 마지막 노드를 제거하는 것이기 때문에 추가적인 코드가 필요하다. if (cursor.next == null) { last = cursor; } 중간 값 제거와 동일한 방식으로 마지막 노드를 제거한다면 현재 cursor가 가리키는 노드가 새로운 마지막 노드가 되고 cursor.next는 null을 나타낼 것이다. 그러나 last는 제거된 마지막 노드를 가리키고 있으므로 cursor 노드가 가리키는 노드로 바꿔준다. 그래야 가비지가 되어서 가비지 청소가 될 수 있다. 가비지 청소 문제   (과거) 이 방법은 가비지 청소 시 문제가 있다. 유관순 노드를 지워도 임꺽정 노드의 Next 값이 유관순 주소를 가지고 있어서 가비지가 안 된다.그 다음 임꺽정 노드를 지워도 임꺽정을 홍길동이 가리키기 때문에 가비지가 안 된다. 즉, 유관순, 임꺽정 노드를 지워도 이것들의 reference count가 1씩 있는 것이다. 마지막으로 홍길동을 지우면 이후 청소 시 가비지 컬렉터가 홍길동은 지우지만 레퍼런스 카운트가 있는 임꺽정과 유관순을 지우지 않는다.다음 청소할 때 임꺽정을 지워지고 그 다음 청소할 때 유관순이 지워진다. 가비지가 가리키는 것들 중 레퍼런스 카운트가 1인 애들은 가비지가 가리키는 것이다.first.value = null;, first.next = null;이렇게 해결할 수 있다. 그러나, 이 문제는 아주 예전에 있던 문제이다. 지금은 해결하는 기능이 들어 있다. 👁️‍🗨️[기술 면접] 손 코딩 테스트 시 LinkedList의 remove( ) 메서드를 구현하기 remove() @Override public Object remove(int index) { if (index &lt; 0 || index &gt;= size) { **** return null; } Node deletedNode = null; size--; if (index == 0) { deletedNode = first; first = first.next; if (first == null) { last = null; } return deletedNode.value; } Node cursor = first; int currentIndex = 0; while (cursor != null) { if (currentIndex == (index - 1)) { break; } cursor = cursor.next; currentIndex++; } deletedNode = cursor.next; **cursor.next** = **cursor.next.next**; if (cursor.next == null) { last = cursor; } return deletedNode.value; } 🔆 상속의 단점 : super 클래스 변경에 따른 코드 수정 기존의 UserList는 ArrayList를 상속 받았지만 LinkedList로 super 클래스를 전환하면 같은 기능이지만 이름이 달라서 코드를 변경해야 한다." }, { "title": "App 14. 상속의 일반화 기법", "url": "/posts/app-14/", "categories": "개인 공부, myapp 혼자 다시해보기, 1단계-Java기초", "tags": "상속, Generalization, Object, Complier, JVM", "date": "2024-12-20 10:00:00 +0900", "snippet": "App 14. 공통 코드 분리와 사용하기 : 상속의 일반화(generalization) 기법1. 학습목표 상속의 기법 중 일반화(generalization)를 수행할 수 있다.2. 요구사항 공통 코드를 분리하여 재사용 하기 쉽도록 리팩토링 하기3. 작업 UserList, ProjectList, BoardList 클래스에서 공통 코드를 분리하여 ...", "content": "App 14. 공통 코드 분리와 사용하기 : 상속의 일반화(generalization) 기법1. 학습목표 상속의 기법 중 일반화(generalization)를 수행할 수 있다.2. 요구사항 공통 코드를 분리하여 재사용 하기 쉽도록 리팩토링 하기3. 작업 UserList, ProjectList, BoardList 클래스에서 공통 코드를 분리하여 별도의 클래스로 정의한다. ArrayList 클래스 추가 메서드 이름 수정   (delete( )   →   remove( )) 기존의 delete( )는 번호를 매개변수로 받아서 해당하는 객체를 찾고(findByNo( )), 레퍼런스 배열에서의 그 객체의 index를 찾고(indexOf( )), 이 index로 배열에서 해당 객체를 제거했다. remove( )는 외부에서 findByNo( )와 indexOf( )로 index를 구해서 이 index를 매개변수로 받는다. index가 유효한지 size 필드를 이용하여 평가 후, 이 index로 배열에서 객체를 제거한다. size() 메서드 생성     ⇒     필드가 private 이므로 사용하려고 get() 메서드 생성 매개 변수로 받은 index의 유효성을 검사하고 유효하다면 레퍼런스 배열에서 해당 인덱스의 객체를 반환 ArrayList package bitcamp.myapp.command; public class ArrayList { private static final int MAX_SIZE = 100; private Object[] list = new Object[MAX_SIZE]; private int size = 0; public void add(Object obj) { list[size++] = obj; } public Object[] toArray() { Object[] arr = new Object[size]; for (int i = 0; i &lt; arr.length; i++) { arr[i] = list[i]; } return arr; } public int indexOf(Object obj) { for (int i = 0; i &lt; size; i++) { if (list[i] == obj) { return i; } } return -1; } public Object remove(int index) { if (index &lt; 0 || index &gt;= size) { return null; } Object deletedObj = list[index]; for (int i = index + 1; i &lt; size; i++) { list[i - 1] = list[i]; } list[--size] = null; return deletedObj; } public int size() { return size; } public Object get(int index) { if (index &lt; 0 || index &gt;= size) { return null; } return list[index]; } } UserList 클래스 변경 ArrayList를 상속받아서 공통 코드를 사용할 수 있게 하기 ArrayList의 size 필드를 사용하고 싶지만 상속이라도 private 필드는 그냥 사용할 수 없다. 명시적 형변환으로 Object 객체 리턴을 받기 (객체에 담는 것이 User 객체이므로 나오는 것도 User 객체) package bitcamp.myapp.command; import bitcamp.myapp.vo.User; public class UserList extends ArrayList { public User findByNo(int userNo) { for (int i = 0; i &lt; size(); i++) { User user = (User) get(i); if (user.getNo() == userNo) { return user; } } return null; } } UserCommand 클래스 변경 UserCommand .... private void listUser() { System.out.println(\"번호 이름 이메일\"); for (Object obj : userList.toArray()) { User user = (User) obj; System.out.printf(\"%d %s %s\\n\", user.getNo(), user.getName(), user.getEmail()); } } ... private void deleteUser() { int userNo = inputInt(\"회원번호?\"); User deletedUser = userList.findByNo(userNo); if (deletedUser != null) { userList.remove(userList.indexOf(deletedUser)); System.out.printf(\"'%s' 회원을 삭제 했습니다.\", deletedUser.getName()); } else { System.out.println(\"없는 회원입니다.\"); } } ProjectList 클래스 변경 package bitcamp.myapp.command; import bitcamp.myapp.vo.Project; public class ProjectList extends ArrayList { public Project findByNo(int projectNo) { for (int i = 0; i &lt; size(); i++) { Project project = (Project) get(i); if (project.getNo() == projectNo) { return project; } } return null; } } ProjectCommand 클래스 변경 ProjectCommand ... private void listProject() { System.out.println(\"번호 프로젝트 기간\"); for (Object obj : projectList.toArray()) { Project project = (Project) obj; System.out.printf(\"%d %s %s ~ %s\\n\", project.getNo(), project.getTitle(), project.getStartDate(), project.getEndDate()); } } ... private void deleteProject() { int projectNo = Prompt.inputInt(\"프로젝트 번호?\"); // 1부터 시작 Project deletedProject = projectList.findByNo(projectNo); if (deletedProject != null) { projectList.remove(projectList.indexOf(deletedProject)); System.out.printf(\"%d번 프로젝트를 삭제 했습니다.\\n\", deletedProject.getNo()); } else { System.out.println(\"삭제 했습니다.\"); } } BoardList 클래스 변경 package bitcamp.myapp.command; import bitcamp.myapp.vo.Board; public class BoardList extends ArrayList { public Board findByNo(int boardNo) { for (int i = 0; i &lt; size(); i++) { Board board = (Board) get(i); if (board.getNo() == boardNo) { return board; } } return null; } } BoardCommand 클래스 변경 BoardCommand ... private void listBoard() { System.out.println(\"번호 제목 작성일 조회수\"); for (Object obj : boardList.toArray()) { Board board = (Board) obj; System.out.printf(\"%d %s %tY-%3$tm-%3$td %d\\n\", board.getNo(), board.getTitle(), board.getCreatedDate(), board.getViewCount()); } } ... private void deleteBoard() { int boardNo = inputInt(\"게시글 번호?\"); Board deletedBoard = boardList.findByNo(boardNo); if (deletedBoard != null) { boardList.remove(boardList.indexOf(deletedBoard)); System.out.printf(\"%d번 게시글을 삭제 했습니다.\\n\", deletedBoard.getNo()); } else { System.out.println(\"없는 게시글입니다.\"); } } Project 클래스도 멤버 배열을ArrayList로 다루도록 한다. Project 클래스 변경 ArrayList로 바꾸면 더 이상 memberSize 필드가 필요 없다. 수정에 따라 addMember(), containsMember(), countMembers(), deleteMember()를 제거한다. 이 기능들은 ArrayList의 메서드로 처리한다. getMembers() 메서드를 추가한다. Project package bitcamp.myapp.vo; import bitcamp.myapp.command.ArrayList; public class Project { private static int seqNo; private int no; private String title; private String description; private String startDate; private String endDate; private ArrayList members = new ArrayList(); public static int getNextSeqNo() { return ++seqNo; } public int getNo() { return no; } public void setNo(int no) { this.no = no; } public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public String getDescription() { return description; } public void setDescription(String description) { this.description = description; } public String getStartDate() { return startDate; } public void setStartDate(String startDate) { this.startDate = startDate; } public String getEndDate() { return endDate; } public void setEndDate(String endDate) { this.endDate = endDate; } public ArrayList getMembers() { return members; } } indexOf()를 이용해서 존재 여부를 파악하고 있으면 true를 반환하도록 ArrayList 클래스에 contains() 메서드 추가 public boolean contains(Object obj) { return indexOf(obj) != -1; } ProjectCommand 클래스 변경 addMembers(), deleteMembers()는 매개변수로 받은 Project 객체의 주소를 주면서 그 인스턴스 한테 getMemebers() 하도록 한다. 즉 Project 객체가 쓰는 ArrayList 객체를 가져오라고 하는 것이다. 이 ArrayList에는 이 Project 객체에 속한 User 객체들이 저장되어 있으며, ArrayList 클래스에는 add, delete, 인덱스 찾기, 전체 배열 복제 등의 동작이 정의되어 있다. App ... private void viewProject() { int projectNo = inputInt(\"프로젝트 번호?\"); Project project = projectList.findByNo(projectNo); if (project == null) { System.out.println(\"없는 프로젝트입니다.\"); return; } System.out.printf(\"프로젝트명: %s\\n\", project.getTitle()); System.out.printf(\"설명: %s\\n\", project.getDescription()); System.out.printf(\"기간: %s ~ %s\\n\", project.getStartDate(), project.getEndDate()); System.out.println(\"팀원:\"); for (int i = 0; i &lt; project.getMembers().size(); i++) { User user = (User) project.getMembers().get(i); System.out.printf(\"- %s\\n\", user.getName()); } } ... private void addMembers(Project project) { while (true) { int userNo = inputInt(\"추가할 팀원 번호?(종료: 0)\"); if (userNo == 0) { break; } User user = userList.findByNo(userNo); if (user == null) { System.out.println(\"없는 회원입니다.\"); continue; } if (project.getMembers().contains(user)) { System.out.printf(\"'%s'은 현재 팀원입니다.\\n\", user.getName()); continue; } project.getMembers().add(user); System.out.printf(\"'%s'을 추가했습니다.\\n\", user.getName()); } } private void deleteMembers(Project project) { for (int i = 0; i &lt; project.getMembers().size(); i++) { User member = (User) project.getMembers().get(i); String str = input(\"팀원(%s) 삭제?\", member.getName()); if (str.equalsIgnoreCase(\"y\")) { project.getMembers().remove(i); System.out.printf(\"'%s' 팀원을 삭제합니다.\\n\", member.getName()); } else { System.out.printf(\"'%s' 팀원을 유지합니다.\\n\", member.getName()); } } } 결과 변경 없음 🔆 14. 공통 코드 분리 및 사용하기 : 상속의 일반화(Generalization) 기법 공통 코드 분리   ⇒   “재사용” 상속의 일반화 기법 여러 개의 하위 클래스에서 공통적으로 사용하는 속성이나 동작을 하나의 상위 클래스로 추출하는 기법 🔆 Object 클래스 Java의 어떤 객체라도 이러한 메서드들을 다 갖고 있다.🔆 Object 클래스와 상속 관계🔆 상속 관계 extends Object가 생략되어 있지만 Object 클래스를 상속하고 있다.🔆 상속 관계와 메서드 호출 A obj = new A(); obj.m1(); ---------&gt; A.m1() A 클래스 객체 생성 후 obj 레퍼런스에 할당 후 m1() 메서드 호출 시 A클래스에 있는 메서드이므로 바로 호출한다. obj.toString(); --------&gt; ~~A.toString()~~ ---------&gt; Object.toString() 클래스 A는 toString() 메서드가 없다. 그래서 상위인 Object로 따라 올라가서 찾고 toString() 호출한다. ⇒   그래서 객체지향은 실행 속도가 느리다. 🔆 상속 관계 II C obj = new C(); obj.toString(); 클래스 C는 B를 B는 A를 상속하고 있다. 클래스 C의 toString( ) 메서드 호출 시 클래스 C는 toString() 메서드가 없다. 그래서 상위인 B로 따라 올라가서 찾고 toString() 호출한다. 하지만 클래스 B도 toString() 메서드가 없다. 결국 이렇게 타고 올라가서 Object 클래스의 toString() 메서드를 호출한다. 🔆 상속의 의미 상속의 의미   ⇒   코드를 가져온다   ( X ) 상속의 의미   ⇒   코드를 공유한다   ( O ) A는 A이고 Object는 Object이다. 단지 A는 Object를 자기 것처럼 사용할 수 있는 것 뿐이다. (공유) 컴파일 후에도 Object 클래스는 필요하다. 공유해서 사용하는 것 뿐이니까public class Test05 { static class A {} static class B {} static class C {} static class X { void m1() {} } static class Y extends X { void m2() {} } static class Z extends Y { void m3() {} }} A, B, C 클래스에는 super class의 메서드는 존재하지 않는다. Y클래스에서 m2( )는 있어도 상속받은 m1( )은 없다. 즉 복사해서 가져오는 것이 아닌 공유이다. 🔆 분류 계층도와 호칭 치와와를 포유류라고 할 수 있다. 치와와는 개지만 포유류의 특징을 갖고 있기 때문이다. ⇒   이처럼 하위를 상위로 이야기 할 수 있다. 그러나 상위 분류를 하위 분류로 가르킬 수는 없다. 페르시안 객체 는 ‘생물’이라고 말할 수 있고, ‘동물’, ‘포유류’, ‘고양이’, ‘페르시안 고양이’라고 할 수 있다. 포유류 객체 는 ‘포유류’, ‘동물’, ‘생물’이라고 말할 수 있다. 그러나, ‘개’라고 말할 수 없다. 개의 특징을 가지고 있지 않기 때문이다. 마찬가지로, ‘치와와’라고 말할 수 없다. 🔆 Java의 클래스 계층도와 레퍼런스 계층도 UML 표현   :   하위에서 상위로 속이 빈 화살표 표시 상위 클래스의 레퍼런스는 하위 클래스의 인스턴스 주소를 담을 수 있다. 즉, 상위 분류명으로 하위 분류 객체를 가리킬 수 있다. MotorCycle m = new MotorCycle();m.engine = -;m.cc = -;m.chain = -; (상위의 것도 사용 가능)m.capacity = -; (상위의 것도 사용 가능)Bicycle bi = new MotoCycle(); 이것도 가능 (허용)bi.chain = -;bi.capacity = -; 자신의 특징(변수)뿐만 아니라 상위 개념들의 특징들(변수들)도 갖고 있다. 하위 분류 클래스의 인스턴스는 상위 분류 클래스의 필드도 생성한다.🔆 Object 클래스 II 결론   :   Java의 모든 클래스는 Object의 자손이다. Ojbect obj = all 인스턴스; ‘obj’라는 레퍼런스는 모든 것들을 다 가리킬 수 있다는 뜻 🔆 개발자의 의도 해석하기 void m1(Object obj) {} m1() 메서드를 만든 개발자의 의도는 “파라미터 값으로 어떤 클래스의 인스턴스라도 다 받겠다“는 의미 [ex] prinln() 메서드 … Object m2() {-} m2() 메서드를 만든 개발자의 의도는 이 메서드는 어떤 타입의 인스턴스 주소를 리턴할 것이다. 메서드를 호출하는 상황에 따라 어떤 클래스의 인스턴스를 리턴하는지 파악하고 리턴값을 사용해라. 🔆 상속 관계에서 인스턴스 생성 ⭐ obj.add(); ArrayList의 add()를 호출하면서 obj의 200번지 주소를 넘긴다. ⭐ Sub Class의 객체를 생성하면 Super Class의 필드도 생성한다. ⭐🔆 Complier와 JVM의 역할 구분 ⭐ 가능 private void listUser() { System.out.println(\"번호 이름 이메일\"); for (Object obj : userList.toArray()) { User user = (User) obj; System.out.printf(\"%d %s %s\\n\", user.getNo(), user.getName(), user.getEmail()); } } User user = (User) obj; 이렇게 레퍼런스 배열에 들어 있는 것이 User 객체라고 알려주면 컴파일러가 넘어간다. 컴파일러는 JVM에서 실행 오류가 뜨든 말든 상관하지 않는다. 문법만을 생각한다. private void listUser() { System.out.println(\"번호 이름 이메일\"); for (Object user : userList.toArray()) { System.out.printf(\"%d %s %s\\n\", ((User) user).getNo(), ((User) user).getName(), ((User) user).getEmail()); } } 이렇게도 가능하긴 하다. (User) user.getNo()는 안 된다. 리턴한 값을 User 클래스로 형변환 한다는 뜻이된다. 불가능 private void listUser() { System.out.println(\"번호 이름 이메일\"); for (Object user : userList.toArray()) { System.out.printf(\"%d %s %s\\n\", user.getNo(), user.getName(), user.getEmail()); } } 이건 오류이다. 컴파일러는 user라는 레퍼런스에 어떤 것이 들어있는지 확인하지 않는다. 컴파일러는 user가 Object 클래스이므로 getNo()도 Object 클래스에 있는지 확인하고 없으니까 에러를 표시한다. private void listUser() { System.out.println(\"번호 이름 이메일\"); for (User user : userList.toArray()) { System.out.printf(\"%d %s %s\\n\", user.getNo(), user.getName(), user.getEmail()); } } userList.toArray()는 속에는 User 객체가 들어있지만 Object 레퍼런스 배열이므로 그것을 담는 애도 Object여야 한다고 컴파일러가 생각하고 에러라고 한다. JVM과 컴파일러를 섞어서 생각하면 안 된다. 컴파일러는 문법만을 확인한다. 실행을 확인하지 않는다. 즉, 안에 뭐가 있는지는 중요하게 생각하지 않는다. " }, { "title": "App 13. 스테틱과 인스턴스", "url": "/posts/app-13/", "categories": "개인 공부, myapp 혼자 다시해보기, 1단계-Java기초", "tags": "Staic, Instance, method, call", "date": "2024-12-19 10:00:00 +0900", "snippet": "App 13. 스테틱 필드의 한계를 극복하기 : 인스턴스 필드 사용1. 학습목표 스태틱 필드의 한계를 이해하고 예를 들어 설명할 수 있다. 인스턴스 필드와 인스턴스 메서드를 활용할 수 있다.2. 요구사항 ‘게시판’과 동일하게 동작하는 ‘공지사항’을 구현하기’3. 작업 App 클래스에 공지사항 메뉴 추가 및 도움말 표시 추가 Ap...", "content": "App 13. 스테틱 필드의 한계를 극복하기 : 인스턴스 필드 사용1. 학습목표 스태틱 필드의 한계를 이해하고 예를 들어 설명할 수 있다. 인스턴스 필드와 인스턴스 메서드를 활용할 수 있다.2. 요구사항 ‘게시판’과 동일하게 동작하는 ‘공지사항’을 구현하기’3. 작업 App 클래스에 공지사항 메뉴 추가 및 도움말 표시 추가 App ... public class App { static String[] mainMenus = {\"회원\", \"프로젝트\", \"게시판\", \"공지사항\", \"도움말\", \"종료\"}; static String[][] subMenus = { {\"등록\", \"목록\", \"조회\", \"변경\", \"삭제\"}, {\"등록\", \"목록\", \"조회\", \"변경\", \"삭제\"}, {\"등록\", \"목록\", \"조회\", \"변경\", \"삭제\"}, {\"등록\", \"목록\", \"조회\", \"변경\", \"삭제\"}, {} }; ... public static void processMenu(String menuTitle, String[] menus) { if (menuTitle.equals(\"도움말\")) { System.out.println(\"도움말입니다.\"); return; } printSubMenu(menuTitle, menus); while (true) { String command = Prompt.input(String.format(\"메인/%s&gt;\", menuTitle)); if (command.equals(\"menu\")) { printSubMenu(menuTitle, menus); } else if (command.equals(\"9\")) { break; } else { try { int menuNo = Integer.parseInt(command); String subMenuTitle = getMenuTitle(menuNo, menus); if (subMenuTitle == null) { System.out.println(\"올바른 메뉴 번호가 아닙니다.\"); } else { switch (menuTitle) { case \"회원\": executeUserCommand(subMenuTitle); break; case \"프로젝트\": executeProjectCommand(subMenuTitle); break; case \"게시판\": executeBoardCommand(subMenuTitle); break; case \"공지사항\": System.out.println(\"공지사항입니다.\"); break; default: System.out.printf(\"%s 메뉴의 명령을 처리할 수 없습니다.\\n\", menuTitle); break; } } } catch (NumberFormatException ex) { System.out.println(\"숫자로 메뉴 번호를 입력하세요.\"); } } } } ... 게시판과 동일한 기능인 공지사항을 추가로 만들 때 게시판을 복사하여 만들 수 있다. ⇒   그러나, 이 방법은 나중에 유지 보수가 번거롭다. BoardList가 여러 개의 데이터 목록을 다룰 수 있도록 변경 BoardList 클래스 변경 스태틱 필드를 인스턴스 필드로 변경 스태틱 메서드를 인스턴스 메서드로 변경 BoardList package bitcamp.myapp.command; import bitcamp.myapp.vo.Board; public class BoardList { private final int MAX_SIZE = 100; private Board[] boards = new Board[MAX_SIZE]; private int boardLength = 0; public void add(Board board) { boards[boardLength++] = board; } public Board[] toArray() { Board[] arr = new Board[boardLength]; for (int i = 0; i &lt; arr.length; i++) { arr[i] = boards[i]; } return arr; } public Board delete(int boardNo) { Board deletedBoard = findByNo(boardNo); if (deletedBoard == null) { return null; } int index = indexOf(deletedBoard); for (int i = index + 1; i &lt; boardLength; i++) { boards[i - 1] = boards[i]; } boards[--boardLength] = null; return deletedBoard; } public Board findByNo(int boardNo) { for (int i = 0; i &lt; boardLength; i++) { Board board = boards[i]; if (board.getNo() == boardNo) { return board; } } return null; } public int indexOf(Board board) { for (int i = 0; i &lt; boardLength; i++) { if (boards[i] == board) { return i; } } return -1; } } BoardCommand가 자신만의 BoardList를 만들어 사용하도록 변경 BoardCommand 클래스 변경 스태틱 필드를 인스턴스 필드로 변경 스태틱 메서드를 인스턴스 메서드로 변경 BoardCommand package bitcamp.myapp.command; import bitcamp.myapp.util.Prompt; import bitcamp.myapp.vo.Board; import java.util.Date; import static bitcamp.myapp.util.Prompt.inputInt; public class BoardCommand { BoardList boardList = new BoardList(); public void executeBoardCommand(String command) { System.out.printf(\"[%s]\\n\", command); switch (command) { case \"등록\": addBoard(); break; case \"조회\": viewBoard(); break; case \"목록\": listBoard(); break; case \"변경\": updateBoard(); break; case \"삭제\": deleteBoard(); break; } } private void addBoard() { Board board = new Board(); board.setTitle(Prompt.input(\"제목?\")); board.setContent(Prompt.input(\"내용?\")); board.setCreatedDate(new Date()); board.setNo(Board.getNextSeqNo()); boardList.add(board); System.out.println(\"등록했습니다.\"); } private void listBoard() { System.out.println(\"번호 제목 작성일 조회수\"); for (Board board : boardList.toArray()) { System.out.printf(\"%d %s %tY-%3$tm-%3$td %d\\n\", board.getNo(), board.getTitle(), board.getCreatedDate(), board.getViewCount()); } } private void viewBoard() { int boardNo = inputInt(\"게시글 번호?\"); Board board = boardList.findByNo(boardNo); if (board == null) { System.out.println(\"없는 게시글입니다.\"); return; } board.setViewCount(board.getViewCount() + 1); System.out.printf(\"제목: %s\\n\", board.getTitle()); System.out.printf(\"내용: %s\\n\", board.getContent()); System.out.printf(\"작성일: %1$tY-%1$tm-%1$td %1$tH:%1$tM:%1$tS\\n\", board.getCreatedDate()); System.out.printf(\"조회수: %d\\n\", board.getViewCount()); } private void updateBoard() { int boardNo = inputInt(\"게시글 번호?\"); Board board = boardList.findByNo(boardNo); if (board == null) { System.out.println(\"없는 게시글입니다.\"); return; } board.setTitle(Prompt.input(\"제목(%s)?\", board.getTitle())); board.setContent(Prompt.input(\"내용(%s)?\", board.getContent())); System.out.println(\"변경했습니다.\"); } private void deleteBoard() { int boardNo = inputInt(\"게시글 번호?\"); Board deletedBoard = boardList.delete(boardNo); if (deletedBoard != null) { System.out.println(\"삭제했습니다.\"); } else { System.out.println(\"없는 게시글입니다.\"); } } } App 클래스 변경 게시판의 게시글을 저장할 BoardCommand 인스턴스를 생성한다. 공지사항 게시글을 저장할 BoardCommand 인스턴스를 생성한다. App public class App { static String[] mainMenus = {\"회원\", \"프로젝트\", \"게시판\", \"공지사항\", \"도움말\", \"종료\"}; static String[][] subMenus = { {\"등록\", \"목록\", \"조회\", \"변경\", \"삭제\"}, {\"등록\", \"목록\", \"조회\", \"변경\", \"삭제\"}, {\"등록\", \"목록\", \"조회\", \"변경\", \"삭제\"}, {\"등록\", \"목록\", \"조회\", \"변경\", \"삭제\"}, {} }; static BoardCommand boardCommand = new BoardCommand(); static BoardCommand noticeCommand = new BoardCommand(); ... public static void processMenu(String menuTitle, String[] menus) { if (menuTitle.equals(\"도움말\")) { System.out.println(\"도움말입니다.\"); return; } printSubMenu(menuTitle, menus); while (true) { String command = Prompt.input(String.format(\"메인/%s&gt;\", menuTitle)); if (command.equals(\"menu\")) { printSubMenu(menuTitle, menus); } else if (command.equals(\"9\")) { break; } else { try { int menuNo = Integer.parseInt(command); String subMenuTitle = getMenuTitle(menuNo, menus); if (subMenuTitle == null) { System.out.println(\"올바른 메뉴 번호가 아닙니다.\"); } else { switch (menuTitle) { case \"회원\": executeUserCommand(subMenuTitle); break; case \"프로젝트\": executeProjectCommand(subMenuTitle); break; case \"게시판\": boardCommand.executeBoardCommand(subMenuTitle); break; case \"공지사항\": noticeCommand.executeBoardCommand(subMenuTitle); break; default: System.out.printf(\"%s 메뉴의 명령을 처리할 수 없습니다.\\n\", menuTitle); break; } } } catch (NumberFormatException ex) { System.out.println(\"숫자로 메뉴 번호를 입력하세요.\"); } } } } ... 나머지 클래스들도 데이터를 목적에 따라 분리해서 관리할 수 있도록 BoardCommand와 BoardList처럼 변경 단, ProjectCommand는 UserList 인스턴스를 사용해야 한다. 생성자를 이용하여 사용하는 userList를 받아야 한다. public class ProjectCommand { ProjectList projectList = new ProjectList(); UserList userList; public ProjectCommand(UserList userlist) { this.userList = userlist; } ... ProjectCommand로 넘겨주는 UserList는 UserCommand에서 생성한 UserList여야 한다. 사용 중인 UserList를 가져오는 메서드를 생성   (getUserList()) public class UserCommand { UserList userList = new UserList(); .... **public UserList getUserList() { return this.userList; }** } App 클래스에서 UserCommand.getUserList()를 사용하여 ProjectCommand에 UserList를 넘겨준다. App 클래스도 인스턴스 메서드와 인스턴스 필드로 정리한다. main()의 코드를 executeApp() 메서드로 뽑아낸다. App package bitcamp.myapp; import bitcamp.myapp.command.BoardCommand; import bitcamp.myapp.command.ProjectCommand; import bitcamp.myapp.command.UserCommand; import bitcamp.myapp.util.Prompt; public class App { ... UserCommand userCommand = new UserCommand(); BoardCommand boardCommand = new BoardCommand(); BoardCommand noticeCommand = new BoardCommand(); ProjectCommand projectCommand = new ProjectCommand(userCommand.getUserList()); public static void main(String[] args) { new App().executeApp(); } void executeApp() { printMenu(); String command; while (true) { try { command = Prompt.input(\"메인&gt;\"); if (command.equals(\"menu\")) { printMenu(); } else { int menuNo = Integer.parseInt(command); String menuTitle = getMenuTitle(menuNo, mainMenus); if (menuTitle == null) { System.out.println(\"올바른 메뉴 번호가 아닙니다.\"); } else if (menuTitle.equals(\"종료\")) { break; } else { if (menuNo &gt;= 1 &amp;&amp; menuNo &lt;= 5) { processMenu(menuTitle, subMenus[menuNo - 1]); } else { System.out.println(menuTitle); } } } } catch (NumberFormatException e) { System.out.println(\"메뉴를 숫자로 입력하세요.\"); } } System.out.println(\"종료합니다.\"); Prompt.close(); } void printMenu() { String bold = \"\\u001B[1m\"; String red = \"\\u001B[31m\"; String reset = \"\\u001B[0m\"; String appTitle = \"[팀 프로젝트 관리 시스템]\"; String line = \"--------------------------------------------\"; System.out.println(bold + line + reset); System.out.println(bold + appTitle + reset); for (int i = 0; i &lt; mainMenus.length; i++) { if (i == mainMenus.length - 1) { System.out.printf(\"%s%s%d. %s%s\\n\", bold, red, i + 1, mainMenus[i], reset); } else { System.out.printf(\"%d. %s\\n\", i + 1, mainMenus[i]); } } System.out.println(bold + line + reset); } void printSubMenu(String menuTitle, String[] menus) { System.out.printf(\"[%s]\\n\", menuTitle); for (int i = 0; i &lt; menus.length; i++) { System.out.printf(\"%d. %s\\n\", (i + 1), menus[i]); } System.out.println(\"9. 이전\"); } boolean isValidateMenu(int menuNo, String[] menus) { return menuNo &gt;= 1 &amp;&amp; menuNo &lt;= menus.length; } String getMenuTitle(int menuNo, String[] menus) { return isValidateMenu(menuNo, menus) ? menus[menuNo - 1] : null; } void processMenu(String menuTitle, String[] menus) { if (menuTitle.equals(\"도움말\")) { System.out.println(\"도움말입니다.\"); return; } printSubMenu(menuTitle, menus); while (true) { String command = Prompt.input(String.format(\"메인/%s&gt;\", menuTitle)); if (command.equals(\"menu\")) { printSubMenu(menuTitle, menus); } else if (command.equals(\"9\")) { break; } else { try { int menuNo = Integer.parseInt(command); String subMenuTitle = getMenuTitle(menuNo, menus); if (subMenuTitle == null) { System.out.println(\"올바른 메뉴 번호가 아닙니다.\"); } else { switch (menuTitle) { case \"회원\": userCommand.executeUserCommand(subMenuTitle); break; case \"프로젝트\": projectCommand.executeProjectCommand(subMenuTitle); break; case \"게시판\": boardCommand.executeBoardCommand(subMenuTitle); break; case \"공지사항\": noticeCommand.executeBoardCommand(subMenuTitle); break; default: System.out.printf(\"%s 메뉴의 명령을 처리할 수 없습니다.\\n\", menuTitle); break; } } } catch (NumberFormatException ex) { System.out.println(\"숫자로 메뉴 번호를 입력하세요.\"); } } } } } 결과 🔆 13. 스테틱 필드의 한계를 극복하기 : 인스턴스 필드 사용 그래서 자바 개발자들은 기본적으로 인스턴스 필드로 만든다. (특별한 경우에만 스태틱 필드를 사용) 🔆 공지사항 메뉴 처리 공지사항이 BoardCommand를 쓰고 BoardCommand는 BoardList를 쓴다면? BoardList에는 static field인 Board[] boards와 int boardLength가 있다. static 필드는 클래스가 로딩될 때 1번만 만든다. 이것이 문제이다. 그렇다면 BoardCommand2와 BoardList2를 원본을 복사하여 만든다.   (클래스 복제 사용) Board 클래스에도 static 변수인 seqNo가 있지만 상관없다. 보통의 사이트에선 게시판과 공지사항의 seqNo가 연결되어 있다. 즉 게시판은 1개지만 카테고리에 따라 나눠둔 것이기 때문이다 🔆 클래스를 복제해서 사용할 때 문제점 A에 버그 발견   ⇒   버그 수정   ⇒   복제해서 만든 모든 클래스에 대해 수정 처리해야 한다. A에 기능 추가   ⇒   복제해서 만든 모든 클래스에 대해 기능 추가해야 한다. ⇒   이런 이유로 유지 보수가 힘들다. ⇒   코드 재사용이 힘들다. 🔆 해결책 : 같은 코드를 사용, 그러나 데이터는 분리 좌측처럼 복제하는 방식은 코드가 중복되는 문제가 있다. ⇒   재사용성 down, 유지 보수성 down 게시판과 공지사항이 하나의 코드(BoardCommand)를 사용한다. 이 BoardCommand는 BoardList를 사용한다. 그러나 BoardList가 다루는 데이터는 다르게 한다 Static   ⇒   Instatnce 전환 같은 코드로 다른 변수를 만드는 것이 좋다. new BoardCommand()를 하면 new BoardList()의 주소를 담을 변수를 만든다. this.boardList.add(board); this는 new BoardCommand()로 생성한 BoardCommand 클래스 객체의 주소를 가지고 있다. 이 주소를 타고 간 인스턴스에는 new BoardList()로 생성한 BoardList 클래스 객체의 주소가 존재한다. 이 객체의 주소를 BoardList 클래스의 add() 메서드에 넘기고 add() 메서드가 작동하게 한다. 🔆 인스턴스와 메서드 ⭐ A 클래스 레퍼런스로 사용할 수 있는 메서드도 A 클래스여야 한다. this 내장 변수는 메서드가 정의된 클래스의 인스턴스 주소를 받기 때문이다. 예를 들어, “데이터 타입에 따라 사용할 수 있는 연산자”가 있다. String s = \"hello\"; =&gt; println(s + \"ok\"); int i = 100; =&gt; println(i + 200); 문자열에 대해 사용되는 + 연산자   (문자열 연결) 정수에 대해 사용되는 + 연산자   (더하기) String s = \"hello\"; =&gt; s++; ( X )int i = 100; =&gt; i++; String 피연산자를 처리하는 ++ 연산자가 정의되어 있지 않다. addBoard()가 3400번지를 쓸때 addBoard()가 호출하는 add()는 200번지를 쓴다는 의미 addBoard()에 4000번지를 주면 add()는 그 주소에 담긴 700번지를 사용 BoardCommand가 addBoard()를 사용할 때 주소를 알려주고 이 주소에는 BoardList 인스턴스의 주소가 들어있다. add()는 주소가 필요하고 마침 그 주소를 가지고 있으므로 전달해준다. 객체지향 추상화 모델링 객체한테 ”사용자한테 게시글 입력 받아서 저장하라고” 메시지를 보내면 이 객체는 상자에게 “사용자로 받은 것들을 있으니까 저장해라”라고 메시지를 보낸다. 🔆 인스턴스 공유 의존 객체   (Dependency) 여러 객체가 공유할 인스턴스 UML 표기법   (인스턴스 표기) 인스턴스명 : 클래스명 ( list : UserList ) ⇒   표기하지 않아도 모델을 이해하는데 문제가 없다면 생략 가능 " }, { "title": "App 11-12. 식별 번호 및 GRASP의 High Cohesion", "url": "/posts/app-11-12/", "categories": "개인 공부, myapp 혼자 다시해보기, 1단계-Java기초", "tags": "Instance, Reference", "date": "2024-12-18 10:00:00 +0900", "snippet": "App 11. 데이터 식별 번호 부여하기1. 학습목표 데이터 식별 번호의 필요성을 설명할 수 있다. 스태틱 필드와 인스턴스 필드를 구분하여 다룰 수 있다. 특정 필드 값을 기준으로 인스턴스를 찾을 수 있다.2. 요구사항 회원 데이터에 식별 번호를 부여 프로젝트 데이터에 식별 번호를 부여 게시판 데이터에 식별 번호를 부여 식별 번호로 데이...", "content": "App 11. 데이터 식별 번호 부여하기1. 학습목표 데이터 식별 번호의 필요성을 설명할 수 있다. 스태틱 필드와 인스턴스 필드를 구분하여 다룰 수 있다. 특정 필드 값을 기준으로 인스턴스를 찾을 수 있다.2. 요구사항 회원 데이터에 식별 번호를 부여 프로젝트 데이터에 식별 번호를 부여 게시판 데이터에 식별 번호를 부여 식별 번호로 데이터를 다루기3. 작업   -   데이터에 식별 번호 부여 회원 데이터에 식별 번호 필드 추가 User 클래스 변경 seqNo 스태틱 필드 및 getNextSeqNo() 스태틱 메서드 추가 User instance를 만들 때마다 공통 사용하는 필드이다. 즉 하나의 변수를 계속 써야한다. ⇒   딱 1개만 사용     (그러나 함부러 바꾸면 안되므로 private) no 인스턴스 필드 및 getter/setter 추가 User package bitcamp.myapp.vo; public class User { private static int seqNo; private int no; private String name; private String email; private String password; private String tel; public static int getNextSeqNo() { return ++seqNo; } public int getNo() { return no; } public void setNo(int no) { this.no = no; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } public String getTel() { return tel; } public void setTel(String tel) { this.tel = tel; } } 식별 번호 자동 부여 및 식별 번호로 찾기 UserCommand 클래스 변경 addUser(), listUser(), viewUser(), findByNo(), updateUser(), deleteUser() 변경 기존의 회원을 찾는 로직을 findByNo()을 활용한다. 기존의 findByNo()는 파라미터로 받은 인덱스로 유효성 검사 후 바로 배열에서 꺼냈다면, 배열의 객체를 순회하며 해당 객체의 no와 파리미터로 받은 userNo가 일치하는 객체를 반환한다. UserCommand package bitcamp.myapp.command; import bitcamp.myapp.util.Prompt; import bitcamp.myapp.vo.User; import static bitcamp.myapp.util.Prompt.input; import static bitcamp.myapp.util.Prompt.inputInt; public class UserCommand { private static final int MAX_SIZE = 100; private static User[] users = new User[MAX_SIZE]; private static int userLength = 0; public static void executeUserCommand(String command) { System.out.println(command); switch (command) { case \"등록\": addUser(); break; case \"목록\": listUser(); break; case \"조회\": viewUser(); break; case \"변경\": updateUser(); break; case \"삭제\": deleteUser(); break; } } private static void addUser() { User user = new User(); user.setName(Prompt.input(\"이름?\")); user.setEmail(Prompt.input(\"이메일?\")); user.setPassword(Prompt.input(\"암호?\")); user.setTel(Prompt.input(\"연락처?\")); user.setNo(User.getNextSeqNo()); users[userLength++] = user; } private static void listUser() { System.out.println(\"번호 이름 이메일\"); for (int i = 0; i &lt; userLength; i++) { User user = users[i]; System.out.printf(\"%d %s %s\\n\", user.getNo(), user.getName(), user.getEmail()); } } private static void viewUser() { int userNo = inputInt(\"회원번호?\"); User user = findByNo(userNo); if (user == null) { System.out.println(\"없는 회원입니다.\"); return; } System.out.printf(\"이름: %s\\n\", user.getName()); System.out.printf(\"이메일: %s\\n\", user.getEmail()); System.out.printf(\"연락처: %s\\n\", user.getTel()); } private static void updateUser() { int userNo = inputInt(\"회원번호?\"); User user = findByNo(userNo); if (user == null) { System.out.println(\"없는 회원입니다.\"); return; } user.setName(input(String.format(\"이름(%s)?\", user.getName()))); user.setEmail(input(String.format(\"이메일(%s)?\", user.getEmail()))); user.setPassword(input(\"암호?\")); user.setTel(input(String.format(\"연락처(%s)?\", user.getTel()))); System.out.println(\"변경했습니다.\"); } private static void deleteUser() { int userNo = inputInt(\"회원번호?\"); User user = findByNo(userNo); if (user == null) { System.out.println(\"없는 회원입니다.\"); return; } int index = indexOf(user); for (int i = index + 1; i &lt; userLength; i++) { users[i - 1] = users[i]; } users[--userLength] = null; System.out.println(\"삭제했습니다.\"); } public static User findByNo(int userNo) { for (int i = 0; i &lt; userLength; i++) { User user = users[i]; if (user.getNo() == userNo) { return user; } } return null; } public static int indexOf(User user) { for (int i = 0; i &lt; userLength; i++) { if (users[i] == user) { return i; } } return -1; } } indexOf() 추가 파리미터로 User 객체를 받아서 배열에서 해당 User 객체의 인덱스를 찾아서 반환 public static int indexOf(User user) { for (int i = 0; i &lt; userLength; i++) { if (users[i] == user) { return i; } } return -1; } 게시판 데이터에 식별 번호 필드 추가 Board 클래스 변경 Board package bitcamp.myapp.vo; import java.util.Date; public class Board { private static int seqNo; private int no; private String title; private String content; private Date createdDate; private int viewCount; public static int getNextSeqNo() { return ++seqNo; } public int getNo() { return no; } public void setNo(int no) { this.no = no; } public Date getCreatedDate() { return createdDate; } public void setCreatedDate(Date createdDate) { this.createdDate = createdDate; } public int getViewCount() { return viewCount; } public void setViewCount(int viewCount) { this.viewCount = viewCount; } public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public String getContent() { return content; } public void setContent(String content) { this.content = content; } } 식별 번호 자동 부여 및 식별 번호로 찾기 BoardCommand 클래스 변경 BoardCommand package bitcamp.myapp.command; import bitcamp.myapp.util.Prompt; import bitcamp.myapp.vo.Board; import java.util.Date; import static bitcamp.myapp.util.Prompt.inputInt; public class BoardCommand { private static final int MAX_SIZE = 100; private static Board[] boards = new Board[MAX_SIZE]; private static int boardLength = 0; public static void executeBoardCommand(String command) { System.out.printf(\"[%s]\\n\", command); switch (command) { case \"등록\": addBoard(); break; case \"조회\": viewBoard(); break; case \"목록\": listBoard(); break; case \"변경\": updateBoard(); break; case \"삭제\": deleteBoard(); break; } } private static void addBoard() { Board board = new Board(); board.setTitle(Prompt.input(\"제목?\")); board.setContent(Prompt.input(\"내용?\")); board.setCreatedDate(new Date()); board.setNo(Board.getNextSeqNo()); boards[boardLength++] = board; System.out.println(\"등록했습니다.\"); } private static void listBoard() { System.out.println(\"번호 제목 작성일 조회수\"); for (int i = 0; i &lt; boardLength; i++) { Board board = boards[i]; System.out.printf(\"%d %s %tY-%3$tm-%3$td %d\\n\", board.getNo(), board.getTitle(), board.getCreatedDate(), board.getViewCount()); } } private static void viewBoard() { int boardNo = inputInt(\"게시글 번호?\"); Board board = findByNo(boardNo); if (board == null) { System.out.println(\"없는 게시글입니다.\"); return; } board.setViewCount(board.getViewCount() + 1); System.out.printf(\"제목: %s\\n\", board.getTitle()); System.out.printf(\"내용: %s\\n\", board.getContent()); System.out.printf(\"작성일: %1$tY-%1$tm-%1$td %1$tH:%1$tM:%1$tS\\n\", board.getCreatedDate()); System.out.printf(\"조회수: %d\\n\", board.getViewCount()); } private static void updateBoard() { int boardNo = inputInt(\"게시글 번호?\"); Board board = findByNo(boardNo); if (board == null) { System.out.println(\"없는 게시글입니다.\"); return; } board.setTitle(Prompt.input(\"제목(%s)?\", board.getTitle())); board.setContent(Prompt.input(\"내용(%s)?\", board.getContent())); System.out.println(\"변경했습니다.\"); } private static void deleteBoard() { int boardNo = inputInt(\"게시글 번호?\"); Board board = findByNo(boardNo); if (board == null) { System.out.println(\"없는 게시글입니다.\"); return; } int index = indexOf(board); for (int i = index + 1; i &lt; boardLength; i++) { boards[i - 1] = boards[i]; } boards[--boardLength] = null; System.out.println(\"삭제했습니다.\"); } public static Board findByNo(int boardNo) { for (int i = 0; i &lt; boardLength; i++) { Board board = boards[i]; if (board.getNo() == boardNo) { return board; } } return null; } public static int indexOf(Board board) { for (int i = 0; i &lt; boardLength; i++) { if (boards[i] == board) { return i; } } return -1; } } 프로젝트 데이터에 식별 번호 필드 추가 Project 클래스 변경 Project package bitcamp.myapp.vo; public class Project { private static int seqNo; private int no; private String title; private String description; private String startDate; private String endDate; private User[] members = new User[10]; private int memberSize; public static int getNextSeqNo() { return ++seqNo; } public int getNo() { return no; } public void setNo(int no) { this.no = no; } public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public String getDescription() { return description; } public void setDescription(String description) { this.description = description; } public String getStartDate() { return startDate; } public void setStartDate(String startDate) { this.startDate = startDate; } public String getEndDate() { return endDate; } public void setEndDate(String endDate) { this.endDate = endDate; } public void addMember(User user) { members[memberSize++] = user; } public boolean containsMember(User user) { for (int i = 0; i &lt; memberSize; i++) { if (members[i] == user) { return true; } } return false; } public int countMembers() { return this.memberSize; } public User getMember(int index) { return members[index]; } public void deleteMember(int index) { for (int i = index + 1; i &lt; memberSize; i++) { members[i - 1] = members[i]; } members[--memberSize] = null; } } containsMember() 메서드 변경 기존에는 사용자 이름으로 찾았지만 이제는 객체 참조를 비교한다. public boolean containsMember(User user) { for (int i = 0; i &lt; memberSize; i++) { if (members[i] == user) { return true; } } return false; } 문제 상황 이렇게 비교해도 같은 객체를 찾을 수 없다. 같은 데이터를 같더라도 객체의 주소가 다르므로 같지 않다고 판단하기 때문이다. ⇒   나중에 equals()와 hashCode()를 오버라이딩하여 no가 같으면 같은 객체로 판단하도록 처리해야 한다. 식별 번호 자동 부여 및 식별 번호로 찾기 ProjectCommand 클래스 변경 Project package bitcamp.myapp.command; import bitcamp.myapp.util.Prompt; import bitcamp.myapp.vo.Project; import bitcamp.myapp.vo.User; import static bitcamp.myapp.util.Prompt.input; import static bitcamp.myapp.util.Prompt.inputInt; public class ProjectCommand { private static final int MAX_SIZE = 100; private static Project[] projects = new Project[MAX_SIZE]; private static int projectLength = 0; public static void executeProjectCommand(String command) { System.out.println(command); switch (command) { case \"등록\": addProject(); break; case \"목록\": listProject(); break; case \"조회\": viewProject(); break; case \"변경\": updateProject(); break; case \"삭제\": deleteProject(); break; } } private static void addProject() { Project project = new Project(); project.setTitle(Prompt.input(\"프로젝트명?\")); project.setDescription(Prompt.input(\"설명?\")); project.setStartDate(Prompt.input(\"시작일?\")); project.setEndDate(Prompt.input(\"종료일?\")); System.out.println(\"팀원:\"); addMembers(project); project.setNo(Project.getNextSeqNo()); projects[projectLength++] = project; System.out.println(\"등록했습니다.\"); } private static void listProject() { System.out.println(\"번호 프로젝트 기간\"); for (int i = 0; i &lt; projectLength; i++) { Project project = projects[i]; System.out.printf(\"%d %s %s ~ %s\\n\", project.getNo(), project.getTitle(), project.getStartDate(), project.getEndDate()); } } private static void viewProject() { int projectNo = inputInt(\"프로젝트 번호?\"); Project project = findByNo(projectNo); if (project == null) { System.out.println(\"없는 프로젝트입니다.\"); return; } System.out.printf(\"프로젝트명: %s\\n\", project.getTitle()); System.out.printf(\"설명: %s\\n\", project.getDescription()); System.out.printf(\"기간: %s ~ %s\\n\", project.getStartDate(), project.getEndDate()); System.out.println(\"팀원:\"); for (int i = 0; i &lt; project.countMembers(); i++) { User user = project.getMember(i); System.out.printf(\"- %s\\n\", user.getName()); } } private static void updateProject() { int projectNo = inputInt(\"프로젝트 번호?\"); Project project = findByNo(projectNo); if (project == null) { System.out.println(\"없는 프로젝트입니다.\"); return; } project.setTitle(Prompt.input(String.format(\"프로젝트명(%s)?\", project.getTitle()))); project.setDescription(Prompt.input(String.format(\"설명(%s)?\", project.getDescription()))); project.setStartDate(Prompt.input(String.format(\"시작일(%s)?\", project.getStartDate()))); project.setEndDate(Prompt.input(String.format(\"종료일(%s)?\", project.getEndDate()))); System.out.println(\"팀원:\"); deleteMembers(project); addMembers(project); System.out.println(\"변경했습니다.\"); } private static void deleteProject() { int projectNo = inputInt(\"프로젝트 번호?\"); Project project = findByNo(projectNo); if (project == null) { System.out.println(\"없는 프로젝트입니다.\"); return; } int index = indexOf(project); for (int i = index + 1; i &lt; projectLength; i++) { projects[i - 1] = projects[i]; } projects[--projectLength] = null; System.out.println(\"삭제 했습니다.\"); } private static void addMembers(Project project) { while (true) { int userNo = inputInt(\"추가할 팀원 번호?(종료: 0)\"); if (userNo == 0) { break; } User user = UserCommand.findByNo(userNo); if (user == null) { System.out.println(\"없는 회원입니다.\"); continue; } if (project.containsMember(user)) { System.out.printf(\"'%s'은 현재 팀원입니다.\\n\", user.getName()); continue; } project.addMember(user); System.out.printf(\"'%s'을 추가했습니다.\\n\", user.getName()); } } private static void deleteMembers(Project project) { for (int i = 0; i &lt; project.countMembers(); i++) { User member = project.getMember(i); String str = input(\"팀원(%s) 삭제?\", member.getName()); if (str.equalsIgnoreCase(\"y\")) { project.deleteMember(i); System.out.printf(\"'%s' 팀원을 삭제합니다.\\n\", member.getName()); } else { System.out.printf(\"'%s' 팀원을 유지합니다.\\n\", member.getName()); } } } public static Project findByNo(int projectNo) { for (int i = 0; i &lt; projectLength; i++) { Project project = projects[i]; if (project.getNo() == projectNo) { return project; } } return null; } public static int indexOf(Project project) { for (int i = 0; i &lt; projectLength; i++) { if (projects[i] == project) { return i; } } return -1; } } 결과 🔆 변수 선언과 변수 변수 선언   :   변수를 생성시키는 명령문 변수   :   메모리 static int seqNo;   ⇒   클래스가 로딩될 때 한 번 실행 String name;   ⇒   new 명령을 만날 때마다 실행 클래스 로딩 시 Method Area에 작성한 코드가 그대로 올라간다. 클래스 로딩 과정 클래스가 로딩된다. **class A { int seqNo; }** 로딩된 명령문 중에서 static 필드 생성문(= 변수 선언)을 실행 즉, static 필드의 메모리는 Method Area에 존재한다. seqNo **[ 0 ]** : **변수(메모리)** =&gt; **Method Area** static 블록을 실행 🔆 변수 선언과 변수 2 Method Area 작성한 클래스가 이 영역으로 올라간다. static 필드의 메모리가 여기에 생성된다. User obj obj라는 인스턴스의 주소를 담을 local 변수를 JVM Stack만들라는 명령문 new User(); 인스턴스 변수 선언을 실행시키는 명령문 (인스턴스 변수에 대한 설계를 바탕으로 User 인스턴스를 Heap에 만들라는 명령) App 12. 인스턴스 목록을 다루는 코드를 분리하기   :   GRASP의 High Cohesion 설계 패턴1. 학습목표 GRASP 방법론의 High Cohesion 설계 패턴을 적용할 수 있다. 캡슐화(encapsulation)를 이해하고 설명할 수 있다.2. 요구사항 GRASP 방법론의 High Cohesion 설계 패턴에 따라 UserCommand 클래스의 역할을 나눈다. UserCommand 클래스는 UI를 처리하는 역할에 집중한다. ProjectCommand, BoardCommand 클래스도 UserCommand 클래스처럼 처리한다.3. 작업 UserCommand에서 인스턴스 목록을 다루는 역할을 다른 클래스로 분리한다. UserCommand 클래스 변경 UserList를 통해 데이터를 처리하고 UI 처리를 전담한다. UserCommand의 addUser(), deleteUser()에서 보면 배열에 추가/삭제하는 부분을 다른 메서드로 처리한다.   ⇒   정보 은닉 delete()는 해당 회원 삭제 후 그 회원 객체를 반환 (실무에서는 true/false를 return하기보다 삭제되는 객체를 return하는 경우가 있다) UserCommand package bitcamp.myapp.command; import bitcamp.myapp.util.Prompt; import bitcamp.myapp.vo.User; import static bitcamp.myapp.util.Prompt.input; import static bitcamp.myapp.util.Prompt.inputInt; public class UserCommand { public static void executeUserCommand(String command) { System.out.println(command); switch (command) { case \"등록\": addUser(); break; case \"목록\": listUser(); break; case \"조회\": viewUser(); break; case \"변경\": updateUser(); break; case \"삭제\": deleteUser(); break; } } private static void addUser() { User user = new User(); user.setName(Prompt.input(\"이름?\")); user.setEmail(Prompt.input(\"이메일?\")); user.setPassword(Prompt.input(\"암호?\")); user.setTel(Prompt.input(\"연락처?\")); user.setNo(User.getNextSeqNo()); UserList.add(user); } private static void listUser() { System.out.println(\"번호 이름 이메일\"); for (User user : UserList.toArray()) { System.out.printf(\"%d %s %s\\n\", user.getNo(), user.getName(), user.getEmail()); } } private static void viewUser() { int userNo = inputInt(\"회원번호?\"); User user = UserList.findByNo(userNo); if (user == null) { System.out.println(\"없는 회원입니다.\"); return; } System.out.printf(\"이름: %s\\n\", user.getName()); System.out.printf(\"이메일: %s\\n\", user.getEmail()); System.out.printf(\"연락처: %s\\n\", user.getTel()); } private static void updateUser() { int userNo = inputInt(\"회원번호?\"); User user = UserList.findByNo(userNo); if (user == null) { System.out.println(\"없는 회원입니다.\"); return; } user.setName(input(String.format(\"이름(%s)?\", user.getName()))); user.setEmail(input(String.format(\"이메일(%s)?\", user.getEmail()))); user.setPassword(input(\"암호?\")); user.setTel(input(String.format(\"연락처(%s)?\", user.getTel()))); System.out.println(\"변경했습니다.\"); } private static void deleteUser() { int userNo = inputInt(\"회원번호?\"); User deletedUser = UserList.delete(userNo); if (deletedUser != null) { System.out.printf(\"'%s' 회원을 삭제 했습니다.\", deletedUser.getName()); } else { System.out.println(\"없는 회원입니다.\"); } } } UserList 클래스 추가   :   User 인스턴스 목록에 인스턴스를 보관하는 일을 담당한다. toArray()는 현재 까지의 배열을 복사하여 반환한다. UserCommand에서 findByNo(), indexOf()를 가져온다     (리펙토링 이용) UserList package bitcamp.myapp.command; import bitcamp.myapp.vo.User; public class UserList { private static final int MAX_SIZE = 100; private static User[] users = new User[MAX_SIZE]; private static int userLength = 0; public static void add(User user) { users[userLength++] = user; } public static User[] toArray() { User[] arr = new User[userLength]; for (int i = 0; i &lt; arr.length; i++) { arr[i] = users[i]; } return arr; } public static User findByNo(int userNo) { for (int i = 0; i &lt; userLength; i++) { User user = users[i]; if (user.getNo() == userNo) { return user; } } return null; } public static int indexOf(User user) { for (int i = 0; i &lt; userLength; i++) { if (users[i] == user) { return i; } } return -1; } public static User delete(int userNo) { User deletedUser = findByNo(userNo); if (deletedUser == null) { return null; } int index = UserList.indexOf(deletedUser); for (int i = index + 1; i &lt; userLength; i++) { users[i - 1] = users[i]; } users[--userLength] = null; return deletedUser; } } ProjectCommand에서 인스턴스 목록을 다루는 역할을 다른 클래스로 분리한다. ProjectList 클래스 추가   :   Project 인스턴스 목록에 인스턴스를 보관하는 일을 담당한다. ProjectList package bitcamp.myapp.command; import bitcamp.myapp.vo.Project; public class ProjectList { private static final int MAX_SIZE = 100; private static Project[] projects = new Project[MAX_SIZE]; private static int projectLength = 0; public static void add(Project project) { projects[projectLength++] = project; } public static Project[] toArray() { Project[] arr = new Project[projectLength]; for (int i = 0; i &lt; arr.length; i++) { arr[i] = projects[i]; } return arr; } public static Project findByNo(int projectNo) { for (int i = 0; i &lt; projectLength; i++) { Project project = projects[i]; if (project.getNo() == projectNo) { return project; } } return null; } public static int indexOf(Project project) { for (int i = 0; i &lt; projectLength; i++) { if (projects[i] == project) { return i; } } return -1; } public static Project delete(int projectNo) { Project deletedProject = ProjectList.findByNo(projectNo); if (deletedProject == null) { return null; } int index = ProjectList.indexOf(deletedProject); for (int i = index + 1; i &lt; projectLength; i++) { projects[i - 1] = projects[i]; } projects[--projectLength] = null; return deletedProject; } } ProjectCommand 클래스 변경 ProjectList를 통해 데이터를 처리하고 UI 처리를 전담한다. ProjectCommand package bitcamp.myapp.command; import bitcamp.myapp.util.Prompt; import bitcamp.myapp.vo.Project; import bitcamp.myapp.vo.User; import static bitcamp.myapp.util.Prompt.input; import static bitcamp.myapp.util.Prompt.inputInt; public class ProjectCommand { public static void executeProjectCommand(String command) { System.out.println(command); switch (command) { case \"등록\": addProject(); break; case \"목록\": listProject(); break; case \"조회\": viewProject(); break; case \"변경\": updateProject(); break; case \"삭제\": deleteProject(); break; } } private static void addProject() { Project project = new Project(); project.setTitle(Prompt.input(\"프로젝트명?\")); project.setDescription(Prompt.input(\"설명?\")); project.setStartDate(Prompt.input(\"시작일?\")); project.setEndDate(Prompt.input(\"종료일?\")); System.out.println(\"팀원:\"); addMembers(project); project.setNo(Project.getNextSeqNo()); ProjectList.add(project); System.out.println(\"등록했습니다.\"); } private static void listProject() { System.out.println(\"번호 프로젝트 기간\"); for (Project project : ProjectList.toArray()) { System.out.printf(\"%d %s %s ~ %s\\n\", project.getNo(), project.getTitle(), project.getStartDate(), project.getEndDate()); } } private static void viewProject() { int projectNo = inputInt(\"프로젝트 번호?\"); Project project = ProjectList.findByNo(projectNo); if (project == null) { System.out.println(\"없는 프로젝트입니다.\"); return; } System.out.printf(\"프로젝트명: %s\\n\", project.getTitle()); System.out.printf(\"설명: %s\\n\", project.getDescription()); System.out.printf(\"기간: %s ~ %s\\n\", project.getStartDate(), project.getEndDate()); System.out.println(\"팀원:\"); for (int i = 0; i &lt; project.countMembers(); i++) { User user = project.getMember(i); System.out.printf(\"- %s\\n\", user.getName()); } } private static void updateProject() { int projectNo = inputInt(\"프로젝트 번호?\"); Project project = ProjectList.findByNo(projectNo); if (project == null) { System.out.println(\"없는 프로젝트입니다.\"); return; } project.setTitle(Prompt.input(String.format(\"프로젝트명(%s)?\", project.getTitle()))); project.setDescription(Prompt.input(String.format(\"설명(%s)?\", project.getDescription()))); project.setStartDate(Prompt.input(String.format(\"시작일(%s)?\", project.getStartDate()))); project.setEndDate(Prompt.input(String.format(\"종료일(%s)?\", project.getEndDate()))); System.out.println(\"팀원:\"); deleteMembers(project); addMembers(project); System.out.println(\"변경했습니다.\"); } private static void deleteProject() { int projectNo = Prompt.inputInt(\"프로젝트 번호?\"); // 1부터 시작 Project deletedProject = ProjectList.delete(projectNo); if (deletedProject != null) { System.out.printf(\"%d번 프로젝트를 삭제 했습니다.\\n\", deletedProject.getNo()); } else { System.out.println(\"삭제 했습니다.\"); } } private static void addMembers(Project project) { while (true) { int userNo = inputInt(\"추가할 팀원 번호?(종료: 0)\"); if (userNo == 0) { break; } User user = UserList.findByNo(userNo); if (user == null) { System.out.println(\"없는 회원입니다.\"); continue; } if (project.containsMember(user)) { System.out.printf(\"'%s'은 현재 팀원입니다.\\n\", user.getName()); continue; } project.addMember(user); System.out.printf(\"'%s'을 추가했습니다.\\n\", user.getName()); } } private static void deleteMembers(Project project) { for (int i = 0; i &lt; project.countMembers(); i++) { User member = project.getMember(i); String str = input(\"팀원(%s) 삭제?\", member.getName()); if (str.equalsIgnoreCase(\"y\")) { project.deleteMember(i); System.out.printf(\"'%s' 팀원을 삭제합니다.\\n\", member.getName()); } else { System.out.printf(\"'%s' 팀원을 유지합니다.\\n\", member.getName()); } } } } BoardCommand에서 인스턴스 목록을 다루는 역할을 다른 클래스로 분리한다. BoardCommand 클래스 변경 BoardList를 통해 데이터를 처리하고 UI 처리를 전담한다. BoardCommand package bitcamp.myapp.command; import bitcamp.myapp.util.Prompt; import bitcamp.myapp.vo.Board; import java.util.Date; import static bitcamp.myapp.util.Prompt.inputInt; public class BoardCommand { public static void executeBoardCommand(String command) { System.out.printf(\"[%s]\\n\", command); switch (command) { case \"등록\": addBoard(); break; case \"조회\": viewBoard(); break; case \"목록\": listBoard(); break; case \"변경\": updateBoard(); break; case \"삭제\": deleteBoard(); break; } } private static void addBoard() { Board board = new Board(); board.setTitle(Prompt.input(\"제목?\")); board.setContent(Prompt.input(\"내용?\")); board.setCreatedDate(new Date()); board.setNo(Board.getNextSeqNo()); BoardList.add(board); System.out.println(\"등록했습니다.\"); } private static void listBoard() { System.out.println(\"번호 제목 작성일 조회수\"); for (Board board : BoardList.toArray()) { System.out.printf(\"%d %s %tY-%3$tm-%3$td %d\\n\", board.getNo(), board.getTitle(), board.getCreatedDate(), board.getViewCount()); } } private static void viewBoard() { int boardNo = inputInt(\"게시글 번호?\"); Board board = BoardList.findByNo(boardNo); if (board == null) { System.out.println(\"없는 게시글입니다.\"); return; } board.setViewCount(board.getViewCount() + 1); System.out.printf(\"제목: %s\\n\", board.getTitle()); System.out.printf(\"내용: %s\\n\", board.getContent()); System.out.printf(\"작성일: %1$tY-%1$tm-%1$td %1$tH:%1$tM:%1$tS\\n\", board.getCreatedDate()); System.out.printf(\"조회수: %d\\n\", board.getViewCount()); } private static void updateBoard() { int boardNo = inputInt(\"게시글 번호?\"); Board board = BoardList.findByNo(boardNo); if (board == null) { System.out.println(\"없는 게시글입니다.\"); return; } board.setTitle(Prompt.input(\"제목(%s)?\", board.getTitle())); board.setContent(Prompt.input(\"내용(%s)?\", board.getContent())); System.out.println(\"변경했습니다.\"); } private static void deleteBoard() { int boardNo = inputInt(\"게시글 번호?\"); Board deletedBoard = BoardList.delete(boardNo); if (deletedBoard != null) { System.out.println(\"삭제했습니다.\"); } else { System.out.println(\"없는 게시글입니다.\"); } } } BoardList 클래스 추가   :   Board 인스턴스 목록에 인스턴스를 보관하는 일을 담당한다. BoardList package bitcamp.myapp.command; import bitcamp.myapp.vo.Board; public class BoardList { private static final int MAX_SIZE = 100; private static Board[] boards = new Board[MAX_SIZE]; private static int boardLength = 0; public static void add(Board board) { boards[boardLength++] = board; } public static Board[] toArray() { Board[] arr = new Board[boardLength]; for (int i = 0; i &lt; arr.length; i++) { arr[i] = boards[i]; } return arr; } public static Board delete(int boardNo) { Board deletedBoard = findByNo(boardNo); if (deletedBoard == null) { return null; } int index = indexOf(deletedBoard); for (int i = index + 1; i &lt; boardLength; i++) { boards[i - 1] = boards[i]; } boards[--boardLength] = null; return deletedBoard; } public static Board findByNo(int boardNo) { for (int i = 0; i &lt; boardLength; i++) { Board board = boards[i]; if (board.getNo() == boardNo) { return board; } } return null; } public static int indexOf(Board board) { for (int i = 0; i &lt; boardLength; i++) { if (boards[i] == board) { return i; } } return -1; } } 결과 ⇒   변경 없음 🔆 ★ 인스턴스 목록을 다루는 코드를 분리하기 ★ GRASP의 High Cohesion 하나의 클래스가 하나의 기능을 담당하게 해라 캡슐화   (Encapsulation) 데이터 은닉   →   데이터 무결성 유지 복잡한 로직을 감추기   →   가독성 Up, 변경을 용이하게 데이터 은닉   :   private, (default), protected, public   ⇒   Access Modifier 복잡한 로직을 감추기   :   getter, setter, method" }, { "title": "App 10-2. 프로젝트 및 게시판 CRUD 구현하기", "url": "/posts/app-10(2)/", "categories": "개인 공부, myapp 혼자 다시해보기, 1단계-Java기초", "tags": "배열, Date, 메모리, JVM", "date": "2024-12-16 16:00:00 +0900", "snippet": "App 10-2. 프로젝트 및 게시판 CRUD 구현하기3. 프로젝트 및 게시판 CRUD 작업 패키지 정리 util 패키지   :   Prompt 클래스 command 패키지   :   Usercommand 클래스 vo 패키지   :   User 클래스 ...", "content": "App 10-2. 프로젝트 및 게시판 CRUD 구현하기3. 프로젝트 및 게시판 CRUD 작업 패키지 정리 util 패키지   :   Prompt 클래스 command 패키지   :   Usercommand 클래스 vo 패키지   :   User 클래스 기존에는 모두 동일 패키지에 있었다.   ⇒   (default) static 메서드도 서로 사용 가능 이제 패키지가 서로 달라졌다. 접근 제한자를 (default)에서 public으로 변경한다. package bitcamp.myapp.util; import java.util.Scanner; public class Prompt { public static Scanner sc = new Scanner(System.in); public static String input(String title) { System.out.printf(\"%s \", title); return sc.nextLine(); } public static void close() { sc.close(); } } User 클래스 역시 패키지가 달라졌기 때문에 필드를 사용하기 위해서는 접근 제한자를 private으로 변경해야 한다. 외부에서 해당 필드를 직접 수정하거나 조회하지 못하도록 private으로 변경 필드에 접근할 때는getter/setter를 사용한다. User package bitcamp.myapp.vo; public class User { private String name; private String email; private String password; private String tel; public String getName() { return name; } public void setName(String name) { this.name = name; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } public String getTel() { return tel; } public void setTel(String tel) { this.tel = tel; } } getter/setter를 사용함에 따른 UserCommand 변경 UserCommand package bitcamp.myapp.command; import bitcamp.myapp.util.Prompt; import bitcamp.myapp.vo.User; import static bitcamp.myapp.util.Prompt.input; public class UserCommand { static final int MAX_SIZE = 100; static User[] users = new User[MAX_SIZE]; static int userLength = 0; public static void executeUserCommand(String command) { System.out.println(command); switch (command) { case \"등록\": addUser(); break; case \"목록\": listUser(); break; case \"조회\": viewUser(); break; case \"변경\": updateUser(); break; case \"삭제\": deleteUser(); break; } } static void addUser() { User user = new User(); user.setName(Prompt.input(\"이름?\")); user.setEmail(Prompt.input(\"이메일?\")); user.setPassword(Prompt.input(\"암호?\")); user.setTel(Prompt.input(\"연락처?\")); users[userLength++] = user; } static void listUser() { System.out.println(\"번호 이름 이메일\"); for (int i = 0; i &lt; userLength; i++) { User user = users[i]; System.out.printf(\"%d %s %s\\n\", (i + 1), user.getName(), user.getEmail()); } } static void viewUser() { int userNo = Integer.parseInt(input(\"회원번호?\")); if (userNo &lt; 1 || userNo &gt; userLength) { System.out.println(\"없는 회원입니다.\"); return; } User user = users[userNo - 1]; System.out.printf(\"이름: %s\\n\", user.getName()); System.out.printf(\"이메일: %s\\n\", user.getEmail()); System.out.printf(\"연락처: %s\\n\", user.getTel()); } static void updateUser() { int userNo = Integer.parseInt(input(\"회원번호?\")); if (userNo &lt; 1 || userNo &gt; userLength) { System.out.println(\"없는 회원입니다.\"); return; } User user = users[userNo - 1]; user.setName(input(String.format(\"이름(%s)?\", user.getName()))); user.setEmail(input(String.format(\"이메일(%s)?\", user.getEmail()))); user.setPassword(input(\"암호?\")); user.setTel(input(String.format(\"연락처(%s)?\", user.getTel()))); System.out.println(\"변경했습니다.\"); } static void deleteUser() { int userNo = Integer.parseInt(input(\"회원번호?\")); if (userNo &lt; 1 || userNo &gt; userLength) { System.out.println(\"없는 회원입니다.\"); return; } for (int i = userNo; i &lt; userLength; i++) { users[i - 1] = users[i]; } userLength--; users[userLength] = null; System.out.println(\"삭제했습니다.\"); } } 프로젝트 CRUD 명령을 처리할 클래스를 정의한다. 정보를 저장할 새 데이터 타입을 정의   :   Project 클래스 생성 Project package bitcamp.myapp.vo; public class Project { private String title; private String description; private String startDate; private String endDate; private User[] members = new User[10]; private int memberSize; public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public String getDescription() { return description; } public void setDescription(String description) { this.description = description; } public String getStartDate() { return startDate; } public void setStartDate(String startDate) { this.startDate = startDate; } public String getEndDate() { return endDate; } public void setEndDate(String endDate) { this.endDate = endDate; } } ProjectCommand 클래스 생성 addProject(), listProject(), viewProject(), updateProject(), deleteProject() 생성 ProjectCommand package bitcamp.myapp.command; import bitcamp.myapp.util.Prompt; import bitcamp.myapp.vo.Project; public class ProjectCommand { static final int MAX_SIZE = 100; static Project[] projects = new Project[MAX_SIZE]; static int projectLength = 0; public static void executeProjectCommand(String command) { System.out.println(command); switch (command) { case \"등록\": addProject(); break; case \"목록\": listProject(); break; case \"조회\": viewProject(); break; case \"변경\": updateProject(); break; case \"삭제\": deleteProject(); break; } } static void addProject() { Project project = new Project(); project.setTitle(Prompt.input(\"프로젝트명?\")); project.setDescription(Prompt.input(\"설명?\")); project.setStartDate(Prompt.input(\"시작일?\")); project.setEndDate(Prompt.input(\"종료일?\")); projects[projectLength++] = project; System.out.println(\"등록했습니다.\"); } static void listProject() { System.out.println(\"번호 프로젝트 기간\"); for (int i = 0; i &lt; projectLength; i++) { Project project = projects[i]; System.out.printf(\"%d %s %s ~ %s\\n\", (i + 1), project.getTitle(), project.getStartDate(), project.getEndDate()); } } static void viewProject() { int projectNo = Integer.parseInt(Prompt.input(\"프로젝트 번호?\")); // 1부터 시작 if (projectNo &lt; 1 || projectNo &gt; projectLength) { System.out.println(\"없는 프로젝트입니다.\"); return; } Project project = projects[projectNo - 1]; System.out.printf(\"프로젝트명: %s\\n\", project.getTitle()); // 인덱스는 0부터 System.out.printf(\"설명: %s\\n\", project.getDescription()); System.out.printf(\"기간: %s ~ %s\\n\", project.getStartDate(), project.getEndDate()); } static void updateProject() { int projectNo = Integer.parseInt(Prompt.input(\"프로젝트 번호?\")); if (projectNo &lt; 1 || projectNo &gt; projectLength) { System.out.println(\"없는 프로젝트입니다.\"); return; } Project project = projects[projectNo - 1]; project.setTitle(Prompt.input(String.format(\"프로젝트명(%s)?\", project.getTitle()))); project.setDescription(Prompt.input(String.format(\"설명(%s)?\", project.getDescription()))); project.setStartDate(Prompt.input(String.format(\"시작일(%s)?\", project.getStartDate()))); project.setEndDate(Prompt.input(String.format(\"종료일(%s)?\", project.getEndDate()))); System.out.println(\"변경했습니다.\"); } static void deleteProject() { int projectNo = Integer.parseInt(Prompt.input(\"프로젝트 번호?\")); if (projectNo &lt; 1 || projectNo &gt; projectLength) { System.out.println(\"없는 프로젝트입니다.\"); return; } for (int i = projectNo; i &lt; projectLength; i++) { projects[i - 1] = projects[i]; } projects[--projectLength] = null; // 가비지 처리 System.out.println(\"삭제 했습니다.\"); } } App 클래스 변경 팀 메뉴 제거 프로젝트 등록할 때 팀원을 등록하는 기능을 구현한다. Prompt 클래스 리팩토링 inputInt() 메서드 추가 public static int inputInt(String title) { return Integer.parseInt(input(title)); } 기존의 input()으로 받은 것을 Integer.parseInt()로 변환하는 것을 inputInt()로 바꿔준다. input() 메서드 변경   :   format 기능 추가 public static String input(String format, Object ... args) { System.out.printf(format + \" \", args); return sc.nextLine(); } ProjectCommand.addProject() 변경 추가할 팀원의 회원 번호를 받는다.   (0번 종료가 나올 때까지) UserCommand의 findByNo()로 회원번호로 해당 사용자를 찾는다. 회원 유효성 검사 후, containsMember()로 이미 추가한 회원 여부를 파악하고, addMember()로 팀원을 최종적으로 추가한다. static void addProject() { Project project = new Project(); project.setTitle(Prompt.input(\"프로젝트명?\")); project.setDescription(Prompt.input(\"설명?\")); project.setStartDate(Prompt.input(\"시작일?\")); project.setEndDate(Prompt.input(\"종료일?\")); System.out.println(\"팀원:\"); while (true) { int userNo = Prompt.inputInt(\"추가할 팀원 번호?(종료: 0)\"); if (userNo == 0) { break; } User user = UserCommand.findByNo(userNo); if (user == null) { System.out.println(\"없는 회원입니다.\"); continue; } if (project.containsMember(user)) { System.out.printf(\"'%s'은 현재 팀원입니다.\\n\", user.getName()); continue; } project.addMember(user); System.out.printf(\"'%s'을 추가했습니다.\\n\", user.getName()); } projects[projectLength++] = project; System.out.println(\"등록했습니다.\"); } UserCommand.findByNo() 추가 받은 회원 번호의 유효성 검사를 해준다. public static User findByNo(int userNo) { if (userNo &lt; 1 || userNo &gt; userLength) { return null; } return users[userNo - 1]; } Project.addMember() 추가 public void addMember(User user) { members[memberSize++] = user; } Project.containsMember() 추가 기존에 담긴 멤버의 이름들과 현재 추가하는 사용자의 이름을 비교한다. public boolean containsMember(User user) { for (int i = 0; i &lt; memberSize; i++) { User member = members[i]; if (member.getName().equals(user.getName())) { return true; } } return false; } 프로젝트 조회할 때 팀원을 출력하는 기능을 구현한다. ProjectCommand.viewProject() 변경 countMembers()로 팀원의 수를 파악하고 팀원의 수만큼 반복문을 돌며 getMember(index)로 멤버를 가져와서 이름을 꺼낸다. static void viewProject() { int projectNo = inputInt(\"프로젝트 번호?\"); // 1부터 시작 if (projectNo &lt; 1 || projectNo &gt; projectLength) { System.out.println(\"없는 프로젝트입니다.\"); return; } Project project = projects[projectNo - 1]; System.out.printf(\"프로젝트명: %s\\n\", project.getTitle()); // 인덱스는 0부터 System.out.printf(\"설명: %s\\n\", project.getDescription()); System.out.printf(\"기간: %s ~ %s\\n\", project.getStartDate(), project.getEndDate()); System.out.println(\"팀원:\"); for (int i = 0; i &lt; project.countMembers(); i++) { System.out.printf(\"- %s\\n\", project.getMemebrs(i).getName()); } } Project.countMembers() 추가 private이므로 다른 클래스에서 필드를 그대로 가져다 쓸 수 없다. public int countMembers() { return this.memberSize; } this는 생략 가능 Project.getMember() 추가 public User getMember(int index) { return members[index]; } 프로젝트 변경할 때 팀원을 삭제, 등록하는 기능을 구현한다. ProjectCommand.updateProject() 변경 팀원을 제거하는 메서드와 팀원을 등록하는 메서드를 미리 호출하고 나중에 정의한다. static void updateProject() { int projectNo = inputInt(\"프로젝트 번호?\"); if (projectNo &lt; 1 || projectNo &gt; projectLength) { System.out.println(\"없는 프로젝트입니다.\"); return; } Project project = projects[projectNo - 1]; project.setTitle(Prompt.input(String.format(\"프로젝트명(%s)?\", project.getTitle()))); project.setDescription(Prompt.input(String.format(\"설명(%s)?\", project.getDescription()))); project.setStartDate(Prompt.input(String.format(\"시작일(%s)?\", project.getStartDate()))); project.setEndDate(Prompt.input(String.format(\"종료일(%s)?\", project.getEndDate()))); System.out.println(\"팀원:\"); deleteMembers(project); addMembers(project); System.out.println(\"변경했습니다.\"); } ProjectCommand.addMembers() 추가 기존에 addProejct()의 코드를 그대로 사용할 수 있다. private static void addMembers(Project project) { while (true) { int userNo = inputInt(\"추가할 팀원 번호?(종료: 0)\"); if (userNo == 0) { break; } User user = UserCommand.findByNo(userNo); if (user == null) { System.out.println(\"없는 회원입니다.\"); continue; } if (project.containsMember(user)) { System.out.printf(\"'%s'은 현재 팀원입니다.\\n\", user.getName()); continue; } project.addMember(user); System.out.printf(\"'%s'을 추가했습니다.\\n\", user.getName()); } } 기존의 addProject()도 간결해진다. static void addProject() { Project project = new Project(); project.setTitle(Prompt.input(\"프로젝트명?\")); project.setDescription(Prompt.input(\"설명?\")); project.setStartDate(Prompt.input(\"시작일?\")); project.setEndDate(Prompt.input(\"종료일?\")); System.out.println(\"팀원:\"); addMembers(project); projects[projectLength++] = project; System.out.println(\"등록했습니다.\"); } ProjectCommand.deleteMembers() 추가 deleteMEmber(index)로 Project의 해당 멤버를 삭제한다. private static void deleteMembers(Project project) { for (int i = 0; i &lt; project.countMembers(); i++) { User member = project.getMember(i); String str = input(\"팀원(%s) 삭제?\", member.getName()); if (str.equalsIgnoreCase(\"y\")) { project.deleteMember(i); System.out.printf(\"'%s' 팀원을 삭제합니다.\\n\", member.getName()); } else { System.out.printf(\"'%s' 팀원을 유지합니다.\\n\", member.getName()); } } } equalsIgnoreCase()를 이용하여 대소문자 구분 없이 Y, y를 모두 처리하도록 한다. Project.deleteMember() 추가 public void deleteMember(int index) { for (int i = index + 1; i &lt; memberSize; i++) { members[i - 1] = members[i]; } members[--memberSize] = null; } 게시글 CRUD 명령을 처리할 클래스를 정의한다. 정보를 저장할 새 데이터 타입을 정의   :   Board 클래스 생성 Board package bitcamp.myapp.vo; public class Board { private String title; private String content; public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public String getContent() { return content; } public void setContent(String content) { this.content = content; } } BoardCommand 클래스 생성 BoardCommand public class BoardCommand { private static final int MAX_SIZE = 100; private static Board[] boards = new Board[MAX_SIZE]; private static int boardLength = 0; public static void executeBoardCommand(String command) { System.out.printf(\"[%s]\\n\", command); switch (command) { case \"등록\": addBoard(); break; case \"조회\": viewBoard(); break; case \"목록\": listBoard(); break; case \"변경\": updateBoard(); break; case \"삭제\": deleteBoard(); break; } } private static void addBoard() { System.out.println(\"게시판 등록\"); } private static void listBoard() { System.out.println(\"게시판 목록\"); } private static void viewBoard() { System.out.println(\"게시판 조회\"); } private static void updateBoard() { System.out.println(\"게시판 변경\"); } private static void deleteBoard() { System.out.println(\"게시판 삭제\"); } } 게시글 등록을 구현한다.   (addBoard()) createdDate는 java.util.Date를 사용 private static void addBoard() { Board board = new Board(); board.setTitle(Prompt.input(\"제목?\")); board.setContent(Prompt.input(\"내용?\")); board.setCreatedDate(new Date()); boards[boardLength++] = board; System.out.println(\"등록했습니다.\"); } 게시글 목록을 구현한다.   (listBoard()) createdDate는 java.util.Date를 사용하고 출력 형식을 지정해준다. %tY-%3$tm-%3$td   ⇒   2024-06-19 뒤의 항목을 2번 이상 사용할 때는 번호를 지정해줘야 한다. private static void listBoard() { System.out.println(\"번호 제목 작성일 조회수\"); for (int i = 0; i &lt; boardLength; i++) { Board board = boards[i]; System.out.printf(\"%d %s %tY-%3$tm-%3$td %d\\n\", (i + 1), board.getTitle(), board.getCreatedDate(), board.getViewCount()); } } 게시글 조회를 구현한다.   (viewBoard()) 게시글을 조회할 때 조회수를 1 증가시켜준다. 날짜 형식 (연월일 시분초)   ⇒   %1$tY-%1$tm-%1$td %1$tH:%1$tM:%1$tS ⇒   2024-06-19 12:09:16 private static void viewBoard() { int boardNo = inputInt(\"게시글 번호?\"); if (boardNo &lt; 1 || boardNo &gt; boardLength) { System.out.println(\"없는 게시글입니다.\"); return; } Board board = boards[boardNo - 1]; board.setViewCount(board.getViewCount() + 1); System.out.printf(\"제목: %s\\n\", board.getTitle()); System.out.printf(\"내용: %s\\n\", board.getContent()); System.out.printf(\"작성일: %1$tY-%1$tm-%1$td %1$tH:%1$tM:%1$tS\\n\", board.getCreatedDate()); System.out.printf(\"조회수: %d\\n\", board.getViewCount()); } 게시글 변경을 구현한다.   (updateBoard()) private static void updateBoard() { int boardNo = inputInt(\"게시글 번호?\"); if (boardNo &lt; 1 || boardNo &gt; boardLength) { System.out.println(\"없는 게시글입니다.\"); return; } Board board = boards[boardNo - 1]; board.setTitle(Prompt.input(\"제목(%s)?\", board.getTitle())); board.setContent(Prompt.input(\"내용(%s)?\", board.getContent())); System.out.println(\"변경했습니다.\"); } 게시글 삭제를 구현한다.   (deleteBoard()) private static void deleteBoard() { int boardNo = inputInt(\"게시글 번호?\"); if (boardNo &lt; 1 || boardNo &gt; boardLength) { System.out.println(\"없는 게시글입니다.\"); return; } for (int i = boardNo; i &lt; boardLength; i++) { boards[i - 1] = boards[i]; } boards[--boardLength] = null; System.out.println(\"삭제했습니다.\"); } 4. 알아 두기 개발자가 메서드를 생성하는 유형 2가지 먼저 메서드를 정의하는 방식 다른 코드에서 어떻게 사용할 지 호출을 먼저하고 이후에 정의하는 방식 equalsIgnoreCase() 대소문자 구분 안 하고 비교하는 메서드이다. 🔆 배열의 항목을 연속으로 삭제할 때 인덱스가 2일 때 C가 아니고 D이다. 0 1 2 =&gt; i = 2일 때 [A][C][D][][][][][][][] 🔆 게시글 입력과 메모리 JVM이 메모리를 관리할 때 사용하는 3가지 영역 Method Area 영역 ⇒   모든 클래스, 메서드 등의 코드들은 Method Area 영역에 존재한다. private static final int MAX_SIZE = 100; private static Board[] boards = new Board[MAX_SIZE]; private static int boardLength = 0; MAX_SIZE boards boardLength [ ][300번지][ ] ⇒   Method Area에 있는 boards에는 Heap 메모리에 있는 인스턴스의 주소가 담긴다. ⇒   이러한 static 변수 즉 클래스 변수는 이 Method Area에 생성된다. JVM Stack 영역 Method Area의 addProject()를 실행하는 순간 addProject()가 사용할 변수인 board(Board의 레퍼런스)라는 변수가 JVM Stack에 프레임(board : [200])으로 만들어진다. 다른 예시로 Prompt의 intput() 메서드를 호출하면 프레임(format : [ ], args : [ ]라는 파라미터들)이 생기고 호출이 끝나면 프레임은 제거된다. addProject()가 끝나면 board : [200]이 들어있는 프레임도 사라진다. Heap 영역 new Board(); 명령 시 title content 200-[ ][ ] Board의 인스턴스는 Heap 영역에 만들어진다. new Board[Max_SIZE]는 아래의 인스턴스를 Heap 영역에 생성한다. 0 99 300-[200번지][][....][] 🔆 변수 초기화 인스턴스 변수와 클래스 변수는 따로 초기화하지 않으면 자동으로 타입에 맞게 초기화된다. Method Area 영역 class A { static int v1; void m1() { Board b = new Board(); } } 이 코드는 Method Area에 있다. v1 : [0] v1이라는 변수는 A 클래스가 메모리에 로딩될 때 자동 생성되며 타입에 맞춰서 자동 초기화된다. JVM Stack 영역 즉, 지역 변수는 변수의 값을 사용하기 전에 반드시 직접 초기화시켜야 한다. Heap 영역 new Board();로 만들어지는 아래의 메모리 title content createdDate viewCount [null][ null ][ null ][ 0 ] 🔆 new Date( ) java.util.Date [ex] Wed Jun 19 11:58:07 KST 2024 날짜 삽입 Formatting 현재 날짜 및 시각 정보   :   java.util.Date   →   객체 생성   →   옵션 활용하여 원하는 정보 뽑아내기 한 개의 값을 여러 곳에 삽입할 수 있다. 3$   :   3번째 값   (지정 사용법) System.out.printf(\"%d %s %tY-%3$tm-%3$td\", (i + 1), board.getTitle(), board.getCreatedDate()); =&gt; 2024-06-19 3$ : 3번째 값 (지정 사용법) System.out.printf(\"작성일: %1$tY-%1$tm-%1$td %1$tH:%1$tM:%1$tS\\n\", board.getCreatedDate()); =&gt; 2024-06-19 12:09:16 print( ), println( ), printf( ) 사용법🔆 인스턴스 메서드 호출 board   :   레퍼런스   (200번지) 200-[title][content][createdDate][viewCount]   :   인스턴스 기술적 측면 getTitle() 메서드에게 인스턴스 주소(200번지)를 주고, 메서드가 값을 리턴한다. (메서드는 this라는 변수를 통해서 받고 접근한다) 기술적 측면을 추상적인 표현으로 바꾸면 개념적 측면이다. 객체지향 개념적 측면 board 객체에게 값을 꺼내라는 메시지를 보내는 것이다. 그럼 board 객체가 값을 리턴한다. " }, { "title": "App 10-1. 회원 CRUD 구현하기", "url": "/posts/app-10(1)/", "categories": "개인 공부, myapp 혼자 다시해보기, 1단계-Java기초", "tags": "Static Variables, Instance Variables, Local Variables, 레퍼런스 배열", "date": "2024-12-15 10:00:00 +0900", "snippet": "App 10-1. 회원 CRUD 구현하기1. 학습목표 데이터의 CRUD(create, retrieve/read, update, delete)를 구현할 수 있다. 클래스 문법을 이용하여 데이터 타입을 정의하고 메서드를 분류할 수 있다. 패키지 문법을 이용하여 클래스를 분류할 수 있다. import 문을 사용할 수 있다. 배열을 이용하여 인스턴...", "content": "App 10-1. 회원 CRUD 구현하기1. 학습목표 데이터의 CRUD(create, retrieve/read, update, delete)를 구현할 수 있다. 클래스 문법을 이용하여 데이터 타입을 정의하고 메서드를 분류할 수 있다. 패키지 문법을 이용하여 클래스를 분류할 수 있다. import 문을 사용할 수 있다. 배열을 이용하여 인스턴스 목록을 다룰 수 있다.2. 요구사항 회원 CRUD 구현 프로젝트 CRUD 구현 게시판 CRUD 구현3-1. 회원 CRUD 작업 각 서브 메뉴 마다 활동이 다르므로 메소드를 만들고 switch 문으로 분기해준다. 회원 서브 메뉴를 다룰 메서드를 정의한다.     (executeUserCommand()) 회원의 서브 메뉴를 선택하면 executeUserCommand()를 호출한다.     (processMenu() 변경) public static void processMenu(String menuTitle, String[] menus) { printSubMenu(menuTitle, menus); while (true) { String command = prompt(\"메인/\" + menuTitle); if (command.equals(\"menu\")) { printSubMenu(menuTitle, menus); } else if (command.equals(\"9\")) { break; } else { try { int menuNo = Integer.parseInt(command); String subMenuTitle = getMenuTitle(menuNo, menus); if (subMenuTitle == null) { System.out.println(\"올바른 메뉴 번호가 아닙니다.\"); } else { System.out.println(subMenuTitle); switch (menuTitle) { case \"회원\": executeUserCommand(subMenuTitle); break; case \"팀\": executeTeamCommand(subMenuTitle); break; case \"프로젝트\": executeProjectCommand(subMenuTitle); break; case \"게시판\": executeBoardCommand(subMenuTitle); break; default: System.out.printf(\"%s 메뉴의 명령을 처리할 수 없습니다.\\n\", menuTitle); break; } } } catch (NumberFormatException ex) { System.out.println(\"숫자로 메뉴 번호를 입력하세요.\"); } } } } static void executeBoardCommand(String command) { System.out.println(command); } static void executeProjectCommand(String command) { System.out.println(command); } static void executeTeamCommand(String command) { System.out.println(command); } static void executeUserCommand(String command) { System.out.println(command); } 회원 등록 기능을 구현한다.     (executeUserCommand() 변경) 메뉴 선택 시 회원 서브 메뉴의 ”등록” 부분을 추가한다.   (한 명의 회원 정보를 입력 받는다.) static void executeUserCommand(String command) { System.out.println(command); switch (command) { case \"등록\": String name = prompt(\"이름?\"); String email = prompt(\"이메일?\"); String password = prompt(\"암호?\"); String tel = prompt(\"연락처?\"); System.out.printf(\"%s %s %s %s\\n\", name, email, password, tel); break; case \"목록\": break; case \"조회\": break; case \"변경\": break; case \"삭제\": break; } } prompt() 변경 ’&gt;’ 문자 출력을 제거한다. 이에 맞춰 관련 코드를 변경한다. (prompt() 메서드에서 “&gt;” 기호 겹침 발생하기 때문에) String 클래스의 format() 메서드를 사용하면 printf 처럼 활용 가능 public static String prompt(String title) { System.out.printf(\"%s \", title); return sc.nextLine(); } ... command = prompt(\"메인&gt;\"); ... String command = prompt(String.format(\"메인/%s&gt;\", menuTitle)); 회원 목록, 조회 기능을 구현한다.     (executeUserCommand() 변경) 목록, 조회도 등록 기능을 구현 시 선언한 변수를 사용해야 한다. 그러나 등록에서 선언된 변수는 로컬 변수이므로 사용할 수 없다.   ⇒   상위 블록으로 이동시킨다. 그럼에도 불구하고 로컬 변수이므로 초기화를 시켜줘야 한다.   ⇒   클래스 변수로 전환 (클래스 변수는 자동 초기화) public class App { static Scanner sc = new Scanner(System.in); static String[] mainMenus = {\"회원\", \"팀\", \"프로젝트\", \"게시판\", \"도움말\", \"종료\"}; static String[][] subMenus = { {\"등록\", \"목록\", \"조회\", \"변경\", \"삭제\"}, {\"등록\", \"목록\", \"조회\", \"변경\", \"삭제\"}, {\"등록\", \"목록\", \"조회\", \"변경\", \"삭제\"}, {\"등록\", \"목록\", \"조회\", \"변경\", \"삭제\"} }; static String name; static String email; static String password; static String tel; static int memberLength = 0; .... static void executeUserCommand(String command) { System.out.println(command); switch (command) { case \"등록\": name = prompt(\"이름?\"); email = prompt(\"이메일?\"); password = prompt(\"암호?\"); tel = prompt(\"연락처?\"); System.out.printf(\"%s %s %s %s\\n\", name, email, password, tel); break; case \"목록\": .... 추가적으로 등록된 인원의 수를 나타내는 memberLength를 클래스 변수로 만들고 초기값을 0을 준다. 여러 명의 회원 정보를 입력하도록 변경한다.     (executeUserCommand() 변경) 회원 정보를 배열로 받는다. 여러 개의 값을 “등록” 하려면 배열을 활용해야 한다. 배열의 크기를 바꾸지 못하도록 상수로 초기화하고 name 등의 클래스 변수를 String[ ] 배열로 바꿔준다. (상수 변수는 보통 대문자로 작성) static final int MAX_SIZE = 100; static String[] name = new String[MAX_SIZE]; static String[] email = new String[MAX_SIZE]; static String[] password = new String[MAX_SIZE]; static String[] tel = new String[MAX_SIZE]; static int memberLength = 0; ... static void executeUserCommand(String command) { System.out.println(command); switch (command) { case \"등록\": name[memberLength] = prompt(\"이름?\"); email[memberLength] = prompt(\"이메일?\"); password[memberLength] = prompt(\"암호?\"); tel[memberLength] = prompt(\"연락처?\"); memberLength++; break; case \"목록\": System.out.println(\"번호 이름 이메일\"); for (int i = 0; i &lt; memberLength; i++) { System.out.printf(\"%d %s %s\\n\", (i + 1), name[i], email[i]); } break; case \"조회\": int userNo = Integer.parseInt(prompt(\"회원번호?\")); if (userNo &lt; 1 || userNo &gt; memberLength) { System.out.println(\"없는 회원입니다.\"); return; } System.out.printf(\"이름: %s\\n\", name[userNo - 1]); System.out.printf(\"이메일: %s\\n\", email[userNo - 1]); System.out.printf(\"연락처: %s\\n\", tel[userNo - 1]); break; 등록할 때마다 배열의 길이를 1씩 증가하도록 한다. 조회 시 입력 받는 회원 번호는 1부터지만, 배열의 경우 0부터이다. 회원 변경, 삭제를 구현한다.     (executeUserCommand() 변경) userNo 역시 공통 사용을 위해 상위 블록에서 선언하고 0으로 초기화해준다. static void executeUserCommand(String command) { System.out.println(command); int userNo = 0; switch (command) { .... case \"변경\": userNo = Integer.parseInt(prompt(\"회원번호?\")); if (userNo &lt; 1 || userNo &gt; memberLength) { System.out.println(\"없는 회원입니다.\"); return; } name[userNo - 1] = prompt(String.format(\"이름(%s)?\", name[userNo - 1])); email[userNo - 1] = prompt(String.format(\"이메일(%s)?\", email[userNo - 1])); password[userNo - 1] = prompt(\"암호?\"); tel[userNo - 1] = prompt(String.format(\"연락처(%s)?\", tel[userNo - 1])); System.out.println(\"변경했습니다.\"); break; ⭐삭제의 원리⭐ 예를 들어 만약 7명에 대해서 등록했다면, (memberLength = 7) 0 1 2 3 4 5 6 7 name 배열의 인스턴스 = 200-[ㅇ][ㅇ][ㅇ][ㅇ][ㅇ][ㅇ][ㅇ][ ]..... (ㅇ : 각 String의 주소값) 삭제의 방식은 해당 userNo 다음의 값들을 앞으로 1칸씩 땡겨와서 제거한다. userNo = 3일 때 (index(i) = 2)   ⇒   4번부터 7번까지 것들이 앞으로 땡겨진다. 이렇게 되면 6번과 7번이 같은 값을 갖게 된다.   (즉, 같은 String을 참조하고 있다) 그러므로 마지막을 null 처리해준다. 이 같은 방식은 맨 앞이나 맨 뒤 중간 어디든 삭제해도 결과는 동일하다. case \"삭제\": userNo = Integer.parseInt(prompt(\"회원번호?\")); if (userNo &lt; 1 || userNo &gt; memberLength) { System.out.println(\"없는 회원입니다.\"); return; } for (int i = userNo; i &lt; memberLength; i++) { name[i - 1] = name[i]; email[i - 1] = email[i]; password[i - 1] = password[i]; tel[i - 1] = tel[i]; } memberLength--; name[memberLength] = null; email[memberLength] = null; password[memberLength] = null; tel[memberLength] = null; break; 회원 등록, 목록, 조회, 변경, 삭제 코드를 별도의 메서드로 분리한다.     (executeUserCommand() 변경) addUser(), listUser(), viewUser(), updateUser(), deleteUser() 메서드 정의 static void executeUserCommand(String command) { System.out.println(command); switch (command) { case \"등록\": addUser(); break; case \"목록\": listUser(); break; case \"조회\": viewUser(); break; case \"변경\": updateUser(); break; case \"삭제\": deleteUser(); break; } } static void addUser() { name[memberLength] = prompt(\"이름?\"); email[memberLength] = prompt(\"이메일?\"); password[memberLength] = prompt(\"암호?\"); tel[memberLength] = prompt(\"연락처?\"); memberLength++; } static void listUser() { System.out.println(\"번호 이름 이메일\"); for (int i = 0; i &lt; memberLength; i++) { System.out.printf(\"%d %s %s\\n\", (i + 1), name[i], email[i]); } } static void viewUser() { int userNo = Integer.parseInt(prompt(\"회원번호?\")); if (userNo &lt; 1 || userNo &gt; memberLength) { System.out.println(\"없는 회원입니다.\"); return; } System.out.printf(\"이름: %s\\n\", name[userNo - 1]); System.out.printf(\"이메일: %s\\n\", email[userNo - 1]); System.out.printf(\"연락처: %s\\n\", tel[userNo - 1]); } static void updateUser() { int userNo = Integer.parseInt(prompt(\"회원번호?\")); if (userNo &lt; 1 || userNo &gt; memberLength) { System.out.println(\"없는 회원입니다.\"); return; } name[userNo - 1] = prompt(String.format(\"이름(%s)?\", name[userNo - 1])); email[userNo - 1] = prompt(String.format(\"이메일(%s)?\", email[userNo - 1])); password[userNo - 1] = prompt(\"암호?\"); tel[userNo - 1] = prompt(String.format(\"연락처(%s)?\", tel[userNo - 1])); System.out.println(\"변경했습니다.\"); } static void deleteUser() { int userNo = Integer.parseInt(prompt(\"회원번호?\")); if (userNo &lt; 1 || userNo &gt; memberLength) { System.out.println(\"없는 회원입니다.\"); return; } for (int i = userNo; i &lt; memberLength; i++) { name[i - 1] = name[i]; email[i - 1] = email[i]; password[i - 1] = password[i]; tel[i - 1] = tel[i]; } memberLength--; name[memberLength] = null; email[memberLength] = null; password[memberLength] = null; tel[memberLength] = null; } 상위 블록에 두었던 int userNo = 0;은 제거한다. 회원 메뉴 처리 메서드를 별도의 클래스로 분리한다. UserCommand 클래스를 정의한다. executeUserCommand(), addUser(), listUser(), viewUser(), updateUser(), deleteUser() 메서드를UserCommand로 옮긴다. 회원 데이터를 저장하는 배열 및 관련 변수를 UserCommand로 옮긴다. package bitcamp.myapp; import static bitcamp.myapp.App.prompt; public class UserCommand { static final int MAX_SIZE = 100; static String[] name = new String[MAX_SIZE]; static String[] email = new String[MAX_SIZE]; static String[] password = new String[MAX_SIZE]; static String[] tel = new String[MAX_SIZE]; static int memberLength = 0; static void executeUserCommand(String command) { System.out.println(command); switch (command) { case \"등록\": addUser(); break; case \"목록\": listUser(); break; case \"조회\": viewUser(); break; case \"변경\": updateUser(); break; case \"삭제\": deleteUser(); break; } } static void addUser() { name[memberLength] = prompt(\"이름?\"); email[memberLength] = prompt(\"이메일?\"); password[memberLength] = prompt(\"암호?\"); tel[memberLength] = prompt(\"연락처?\"); memberLength++; } static void listUser() { System.out.println(\"번호 이름 이메일\"); for (int i = 0; i &lt; memberLength; i++) { System.out.printf(\"%d %s %s\\n\", (i + 1), name[i], email[i]); } } static void viewUser() { int userNo = Integer.parseInt(prompt(\"회원번호?\")); if (userNo &lt; 1 || userNo &gt; memberLength) { System.out.println(\"없는 회원입니다.\"); return; } System.out.printf(\"이름: %s\\n\", name[userNo - 1]); System.out.printf(\"이메일: %s\\n\", email[userNo - 1]); System.out.printf(\"연락처: %s\\n\", tel[userNo - 1]); } static void updateUser() { int userNo = Integer.parseInt(prompt(\"회원번호?\")); if (userNo &lt; 1 || userNo &gt; memberLength) { System.out.println(\"없는 회원입니다.\"); return; } name[userNo - 1] = prompt(String.format(\"이름(%s)?\", name[userNo - 1])); email[userNo - 1] = prompt(String.format(\"이메일(%s)?\", email[userNo - 1])); password[userNo - 1] = prompt(\"암호?\"); tel[userNo - 1] = prompt(String.format(\"연락처(%s)?\", tel[userNo - 1])); System.out.println(\"변경했습니다.\"); } static void deleteUser() { int userNo = Integer.parseInt(prompt(\"회원번호?\")); if (userNo &lt; 1 || userNo &gt; memberLength) { System.out.println(\"없는 회원입니다.\"); return; } for (int i = userNo; i &lt; memberLength; i++) { name[i - 1] = name[i]; email[i - 1] = email[i]; password[i - 1] = password[i]; tel[i - 1] = tel[i]; } memberLength--; name[memberLength] = null; email[memberLength] = null; password[memberLength] = null; tel[memberLength] = null; } } App 클래스의 static 메서드인 prompt()를 import한다. 반대로 App 클래스도 UserCommand의 static 메서드인 executeUserCommand()를 import한다. 💥문제 상황💥 현재 App 클래스는 UserCommand의 executeUserCommand()를 사용하고 있고, 반대로 UserCommand는 App 클래스의 prompt()를 사용하고 있다. 이렇게 쌍방 참조 관계는 좋지 않다. 따라서 App 클래스에서 prompt()를 뽑아 새로운 클래스를 생성해야 한다. prompt() 메서드를 별도의 클래스로 분리한다. Prompt 클래스 정의 prompt() 메서드를 Prompt 클래스로 옮기고 이름을 input()으로 변경한다. (단, Prompt 클래스와 prompt() 메서드의 이름이 같으므로) ”변수 or 메서드”를 이동 시 IntelliJ의 리펙터링 기능을 이용하면 한번에 싹 바뀐다. 추가적으로 App 클래스가 직접 Scanner를 닫지 않도록 Prompt 클래스에 close() 메서드 생성 package bitcamp.myapp; import java.util.Scanner; public class Prompt { static Scanner sc = new Scanner(System.in); static String input(String title) { System.out.printf(\"%s \", title); return sc.nextLine(); } static void close() { sc.close(); } } 회원 정보를 클래스로 다룬다. User 클래스를 정의하여 회원 정보를 User 클래스로 다룬다. 배열은 같은 타입의 데이터를 쉽게 만들기 위한 것이고 클래스 다른 타입의 데이터를 쉽게 만들기 위한 것이다.   (이 경우 같은 타입이지만 클래스로 만든다.) 즉, 새로운 데이터 타입을 정의한다.     (메모리 설계도) package bitcamp.myapp; public class User { String name; String email; String password; String tel; } 이 때 필드는 Non-static 필드   =   인스턴스 필드로 만든다. ⇒   new 명령을 통해 Heap 메모리에 생성된다. 이후 UserCommand로 가서 User 클래스를 이용하여 가독성 좋게 만든다. ⇒   User 클래스들을 담는 배열   ⇒   레퍼런스 배열을 하나 만든다. ⇒   memberLength를 userLength로 변수 이름을 바꿔준다 package bitcamp.myapp; import static bitcamp.myapp.Prompt.input; public class UserCommand { static final int MAX_SIZE = 100; static User[] users = new User[MAX_SIZE]; static int userLength = 0; static void executeUserCommand(String command) { System.out.println(command); switch (command) { case \"등록\": addUser(); break; case \"목록\": listUser(); break; case \"조회\": viewUser(); break; case \"변경\": updateUser(); break; case \"삭제\": deleteUser(); break; } } static void addUser() { User user = new User(); user.name = Prompt.input(\"이름?\"); user.email = Prompt.input(\"이메일?\"); user.password = Prompt.input(\"암호?\"); user.tel = Prompt.input(\"연락처?\"); users[userLength++] = user; } static void listUser() { System.out.println(\"번호 이름 이메일\"); for (int i = 0; i &lt; userLength; i++) { User user = users[i]; System.out.printf(\"%d %s %s\\n\", (i + 1), user.name, user.email); } } static void viewUser() { int userNo = Integer.parseInt(input(\"회원번호?\")); if (userNo &lt; 1 || userNo &gt; userLength) { System.out.println(\"없는 회원입니다.\"); return; } User user = users[userNo - 1]; System.out.printf(\"이름: %s\\n\", user.name); System.out.printf(\"이메일: %s\\n\", user.email); System.out.printf(\"연락처: %s\\n\", user.tel); } static void updateUser() { int userNo = Integer.parseInt(input(\"회원번호?\")); if (userNo &lt; 1 || userNo &gt; userLength) { System.out.println(\"없는 회원입니다.\"); return; } User user = users[userNo - 1]; user.name = input(String.format(\"이름(%s)?\", user.name)); user.email = input(String.format(\"이메일(%s)?\", user.email)); user.password = input(\"암호?\"); user.tel = input(String.format(\"연락처(%s)?\", user.tel)); System.out.println(\"변경했습니다.\"); } static void deleteUser() { int userNo = Integer.parseInt(input(\"회원번호?\")); if (userNo &lt; 1 || userNo &gt; userLength) { System.out.println(\"없는 회원입니다.\"); return; } for (int i = userNo; i &lt; userLength; i++) { users[i - 1] = users[i]; } userLength--; users[userLength] = null; System.out.println(\"삭제했습니다.\"); } } users[userLength++] = user;은 먼저 할당 후 1을 더하는 것이다. 결과 🔆 로컬 변수, 클래스 변수, 필드 변수, 클래스 로딩 로컬 변수     (Local Variables) 메서드나 초기화 블록 안에서 선언되고, 블록 내에서만 유효하다. 메서드 실행 시 생성되고, 종료 시 스택 메모리에서 제거된다. 로컬 변수는 초기화시키지 않으면 자동 초기화되지 않는다. 클래스 변수     (Static Variables) 클래스 내에서 static으로 선언된 변수로 오로지 클래스 변수에만 static을 붙일 수 있다. 클래스의 모든 인스턴스가 공유하는 변수 클래스 로딩 시 Method Area에 만들어져 JVM을 종료하지 않는 이상 계속 남아있는다. 클래스 변수는 자동으로 초기화한다. 필드 변수     (Instatnce Variables) 클래스 내에서 static가 키워드 없는 변수로 각각의 인스턴스마다 별도로 할당된다. 객체가 생성될 때마다 생성된다. 객체의 상태를 나타내며, 객체마다 독립적인 값을 가질 수 있다. 객체의 메서드에서 this 키워드를 통해 접근할 수 있다. 클래스 로딩     (Java) 클래스 시작 시 JVM이 클래스 파일을 메모리에 로드하여 사용할 수 있는 형태로 변환하는 과정을 클래스 로딩이라 한다. 클래스 로딩은 JVM 내에서 한 번만 수행된다. 프로그램 실행 시 로딩 되는 시간에 Method Area에 수백 개의 클래스가 올라간다. 올라가는 클래스 해당 클래스에서 사용되거나 사용되는 클래스가 또 사용하는 클래스들 (Scanner, String, Integer………) c 언어 한 번에 컴파일 하지 않고 나눠서 컴파일하여 일부는 (*.dll)로 만들고 일부만 .exe파일로 된다. 해당 부분을 쓰는 시점에 .dll과 연결된다. ‼️ [주의] 클래스 관계 클래스들 간의 쌍방 참조를 하지마라. 유지 보수 하기 힘들다!! 클래스 관계를 쌍방에서 Association(연관)으로 만들어라.🔆 인스턴스 필드 필드 변수가 저장되는 위치가 인스턴스 필드이다.🔆 레퍼런스 배열 1 ★ 레퍼런스 배열 인스턴스의 주소를 저장하는 배열이다. 클래스 배열   (객체 배열) 해당 클래스의 객체의 주소를 저장하는 배열로 일종의 레퍼런스 배열이다. 각각 메모리에 User 클래스 객체의 주소가 들어간다. 클래스의 객체는 다른 타입의 데이터들을 저장한다. 이 경우, 각각의 필드 변수가 모두 String이므로 모두 주소값이 저장된다. 그림에서 볼 수 있듯이, 주소가 4100인 비어 있는 4개의 메모리가 생성되고 각각의 필드 변수가 해당 위치에 들어간다. (primitive 타입이라면 값이 들어가고 Reference 타입이라면 주소값이 들어간다) users[1]에는 아직 User 객체의 주소값이 없다.   (null인 상태이므로) 🔆 레퍼런스 배열 2 users[0].name = \"aaa\"; = user.name = \"aaa\";🔆 클래스 문법 우리가 클래스를 만든다면 이 2가지 중에 하나이다" }, { "title": "App 09. 자바 기본 문법 활용 연습", "url": "/posts/app-09/", "categories": "개인 공부, myapp 혼자 다시해보기, 1단계-Java기초", "tags": "이차원배열, String 배열", "date": "2024-12-14 15:00:00 +0900", "snippet": "App 09. 자바 기본 문법 활용 연습1. 학습목표 조건문, 반복문을 다룰 수 있다 메서드를 정의하고 사용할 수 있다. 사용자 입력을 다룰 수 있다. 출력문을 다룰 수 있다. 다차원 배열을 다룰 수 있다.2. 요구사항 각 메뉴에 대한 서브 메뉴 추가3. 작업 프롬프트를 출력할 때 메인 메뉴나 서브 메뉴 타이틀을 출력한다. ...", "content": "App 09. 자바 기본 문법 활용 연습1. 학습목표 조건문, 반복문을 다룰 수 있다 메서드를 정의하고 사용할 수 있다. 사용자 입력을 다룰 수 있다. 출력문을 다룰 수 있다. 다차원 배열을 다룰 수 있다.2. 요구사항 각 메뉴에 대한 서브 메뉴 추가3. 작업 프롬프트를 출력할 때 메인 메뉴나 서브 메뉴 타이틀을 출력한다. 프롬프트 타이틀을 출력하도록 prompt() 메서드를 변경한다. command = prompt(\"메인\"); ... public static String prompt(String menuTitle) { System.out.printf(\"%s&gt;\\n\", menuTitle); return sc.nextLine(); } ‘회원’ 메뉴에 대해 서브 메뉴를 처리한다. Refactoring 보다는 요구사항 달성을 목표로 코드를 간단히 작성한다. 기존의 코드를 너무 이용하려고 하지 마라. 나중에 Refactoring 할 때 더 잘 보인다. if (command.equals(\"menu\")) { printMenu(); } else { int menuNo = Integer.parseInt(command); String menuTitle = getMenuTitle(menuNo); // 설명하는 변수 if (menuTitle == null) { System.out.println(\"유효한 메뉴 번호가 아닙니다.\"); } else if (menuTitle.equals(\"종료\")) { break; } else { if (menuTitle.equals(\"회원\")) { System.out.println(\"[회원]\"); System.out.println(\"1. 등록\"); System.out.println(\"2. 목록\"); System.out.println(\"3. 조회\"); System.out.println(\"4. 변경\"); System.out.println(\"5. 삭제\"); System.out.println(\"9. 이전\"); } else { System.out.println(menuTitle); } } } 배열로 서브 메뉴를 저장한다. 회원 메뉴 창에서도 입력을 무한히 받도록 While 문을 활용한다.   (main 메뉴일 때와 비슷) 메뉴 번호 9를 입력 시 위치가 “메인/회원”에서 다시 “메인”로 돌아가게 된다. static String[] memberMenus = {\"등록\", \"목록\", \"조회\", \"변경\", \"삭제\"}; public static void main(String[] args) { .... if (menuTitle == null) { System.out.println(\"올바른 메뉴 번호가 아닙니다.\"); } else if (menuTitle.equals(\"종료\")) { break; } else { if (menuTitle.equals(\"회원\")) { for (int i = 0; i &lt; memberMenus.length; i++) { System.out.printf(\"%d. %s\\n\", (i + 1), memberMenus[i]); } System.out.println(\"9. 이전\"); while (true) { command = prompt(\"메인/회원\"); if (command.equals(\"menu\")) { System.out.println(\"[회원]\"); for (int i = 0; i &lt; memberMenus.length; i++) { System.out.printf(\"%d. %s\\n\", (i + 1), memberMenus[i]); } System.out.println(\"9. 이전\"); } else if (command.equals(\"9\")) { break; } else { menuNo = Integer.parseInt(command); String subMenuTitle = getSubMenuTitle(menuNo); printSubMenu()를 정의하여 서브 메뉴를 출력한다. “회원” 뿐만 아니라 다른 메뉴에도 활용할 수 있도록 Method로 추출 } else { if (menuTitle.equals(\"회원\")) { printSubMenu(menuTitle, memberMenus); while (true) { command = prompt(\"메인/회원\"); if (command.equals(\"menu\")) { printSubMenu(menuTitle, memberMenus); } else if (command.equals(\"9\")) { break; } else { menuNo = Integer.parseInt(command); String subMenuTitle = getSubMenuTitle(menuNo); ... public static void printSubMenu(String menuTitle, String[] menus) { System.out.printf(\"[%s]\\n\", menuTitle); for (int i = 0; i &lt; menus.length; i++) { System.out.printf(\"%d. %s\\n\", (i + 1), menus[i]); } System.out.println(\"9. 이전\"); } 메뉴 Title이 바뀌면 prompt도 자동으로 바뀌도록 설정 while (true) { command = prompt(\"메인/\" + menuTitle); if (command.equals(\"menu\")) { printSubMenu(menuTitle, memberMenus); ‘팀’ 메뉴도 ‘회원’ 메뉴와 동일하게 처리한다. static String[] teamMenus = {\"등록\", \"목록\", \"조회\", \"변경\", \"삭제\"}; ... } else { if (menuTitle.equals(\"회원\")) { printSubMenu(menuTitle, memberMenus); while (true) { command = prompt(\"메인/\" + menuTitle); if (command.equals(\"menu\")) { printSubMenu(menuTitle, memberMenus); } else if (command.equals(\"9\")) { break; } else { menuNo = Integer.parseInt(command); String subMenuTitle = getSubMenuTitle(menuNo); if (subMenuTitle == null) { System.out.println(\"올바른 메뉴 번호가 아닙니다.\"); } else { System.out.println(subMenuTitle); } } } } else if (menuTitle.equals(\"팀\")) { printSubMenu(menuTitle, teamMenus); while (true) { command = prompt(\"메인/\" + menuTitle); if (command.equals(\"menu\")) { printSubMenu(menuTitle, teamMenus); } else if (command.equals(\"9\")) { break; } else { menuNo = Integer.parseInt(command); String subMenuTitle = getSubMenuTitle(menuNo); if (subMenuTitle == null) { System.out.println(\"올바른 메뉴 번호가 아닙니다.\"); } else { System.out.println(subMenuTitle); } } } } else { System.out.println(menuTitle); } 서브 메뉴를 처리하는 코드를 공통으로 사용할 수 있도록 리팩토링 한다. 중복되는 코드 발견   →   processMenu() 메서드를 정의하여 사용한다. ‘프로젝트’, ’ 게시판’ 메뉴도 동일하게 처리 static String[] projectMenus = {\"등록\", \"목록\", \"조회\", \"변경\", \"삭제\"}; static String[] boardMenus = {\"등록\", \"목록\", \"조회\", \"변경\", \"삭제\"}; ... String command; while (true) { try { command = prompt(\"메인\"); if (command.equals(\"menu\")) { printMenu(); } else { int menuNo = Integer.parseInt(command); String menuTitle = getMenuTitle(menuNo); if (menuTitle == null) { System.out.println(\"올바른 메뉴 번호가 아닙니다.\"); } else if (menuTitle.equals(\"종료\")) { break; } else { if (menuTitle.equals(\"회원\")) { processMenu(menuTitle, memberMenus); } else if (menuTitle.equals(\"팀\")) { processMenu(menuTitle, teamMenus); } else if (menuTitle.equals(\"프로젝트\")) { processMenu(menuTitle, projectMenus); } else if (menuTitle.equals(\"게시판\")) { processMenu(menuTitle, boardMenus); } else { System.out.println(menuTitle); } } } } catch (NumberFormatException e) { System.out.println(\"메뉴를 숫자로 입력하세요.\"); } ... public static void processMenu(String menuTitle, String[] menus) { printSubMenu(menuTitle, menus); while (true) { String command = prompt(\"메인/\" + menuTitle); if (command.equals(\"menu\")) { printSubMenu(menuTitle, menus); } else if (command.equals(\"9\")) { break; } else { int menuNo = Integer.parseInt(command); String subMenuTitle = getSubMenuTitle(menuNo, menus); if (subMenuTitle == null) { System.out.println(\"올바른 메뉴 번호가 아닙니다.\"); } else { System.out.println(subMenuTitle); } } } } 반복적인 형태를 보인다.   ⇒  이를 줄이기 위해 이차원 배열을 활용한다. getSubmenuTitle()도 변경 static String[][] subMenus = { {\"등록\", \"목록\", \"조회\", \"변경\", \"삭제\"}, {\"등록\", \"목록\", \"조회\", \"변경\", \"삭제\"}, {\"등록\", \"목록\", \"조회\", \"변경\", \"삭제\"}, {\"등록\", \"목록\", \"조회\", \"변경\", \"삭제\"}, }; command = prompt(\"메인\"); if (command.equals(\"menu\")) { printMenu(); } else { int menuNo = Integer.parseInt(command); String menuTitle = getMenuTitle(menuNo); if (menuTitle == null) { System.out.println(\"올바른 메뉴 번호가 아닙니다.\"); } else if (menuTitle.equals(\"종료\")) { break; } else { if (menuNo &gt;= 1 &amp;&amp; menuNo &lt;= 4) { processMenu(menuTitle, subMenus[menuNo]); } else { System.out.println(menuTitle); } } } .... public static String getSubMenuTitle(int menuNo, String[] menus) { if (isValidateMenu(menuNo)) { return menus[menuNo - 1]; } return null; } isValidateMenu()의 경우 뒤에서 sub메뉴도 처리할 수 있게 할 예정이다. sub 메뉴에서도 유효하지 않는 값 처리를 위해 예외 처리를 추가한다. public static void processMenu(String menuTitle, String[] menus) { printSubMenu(menuTitle, menus); while (true) { String command = prompt(\"메인/\" + menuTitle); if (command.equals(\"menu\")) { printSubMenu(menuTitle, menus); } else if (command.equals(\"9\")) { break; } else { try { int menuNo = Integer.parseInt(command); String subMenuTitle = getSubMenuTitle(menuNo, menus); if (subMenuTitle == null) { System.out.println(\"올바른 메뉴 번호가 아닙니다.\"); } else { System.out.println(subMenuTitle); } } catch (NumberFormatException ex) { System.out.println(\"숫자로 메뉴 번호를 입력하세요.\"); } } } } 기능 완료 후 리팩토링 수행한다. 기존의 menus 배열을 mainMenus로 이름 변경 getMenuTitle()을 서브 메뉴를 다룰 때도 이용할 수 있도록 변경한다. getSubmenuTitle() 과 getMenuTitle()의 코드가 비슷하다.   ⇒   하나로 합친다. String command; while (true) { try { command = prompt(\"메인\"); if (command.equals(\"menu\")) { printMenu(); } else { int menuNo = Integer.parseInt(command); String menuTitle = getMenuTitle(menuNo, mainMenu); if (menuTitle == null) { System.out.println(\"올바른 메뉴 번호가 아닙니다.\"); } else if (menuTitle.equals(\"종료\")) { break; } else { if (menuNo &gt;= 1 &amp;&amp; menuNo &lt;= 4) { processMenu(menuTitle, subMenus[menuNo]); } else { System.out.println(menuTitle); } } } public static String getMenuTitle(int menuNo, String[] menus) { return isValidateMenu(menuNo, menus) ? menus[menuNo - 1] : null; } isValidateMenu()를 서브 메뉴를 다룰 때도 이용할 수 있도록 변경한다. public static boolean isValidateMenu(int menuNo, String[] menus) { return menuNo &gt;= 1 &amp;&amp; menuNo &lt;= menus.length; } 결과 4. 알아 두기 IntelliJ에서 변수 이름 한 번에 바꾸기 Menus 배열명을 클릭   →   오른쪽 마우스   →   리팩터링   →   Rename   →   사용된 모든 곳의 이름이 바뀐다. 🔆 다차원 배열 - 가변 크기 가변 크기 행의 개수만 지정한다.   (열의 개수가 뭐가 될지 모른다) int[][] arr = new int[3][]; System.out.println(arr.length); // 3 for (int i = 0; i &lt; arr.length; i++) { System.out.println(arr[i]); } // 결과 null null null 단 이때는 내부의 값들이 존재하지 않는 null 상태이다. int[][]은 int 배열의 주소를 담을 배열 arr[0] = new int[2]; arr[1] = new int[3]; arr[2] = new int[4]; for (int i = 0; i &lt; arr.length; i++) { System.out.println(arr[i]); } // 결과 [I@4517d9a3 [I@372f7a8d [I@2f92e0f4 내부 배열을 선언해줘야 내부의 값들이 0으로 초기화된다. 🔆 다차원 배열 - 크기 고정 크기 고정 먼저 1차원 배열을 담는 3개의 메모리가 생성된다. 각각의 메모리에 int 값 4개를 담을 메모리가 생성되고 그 주소값이 담긴다. int[][] arr = new int[3][4]; for (int i = 0; i &lt; arr2.length; i++) { for (int j = 0; j &lt; arr2[i].length; j++) { System.out.print(arr2[i][j] + \", \"); } System.out.println(); } 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, int 값이 담기므로 초기화 시 0으로 채워진다. 먼저 사이즈를 고정하여 만들고 밑에서 새로 만들면 사이즈를 고정했던 것들은 다 가비지가 되어버렸다. int[][] arr2 = new int[3][4]; arr2[0] = new int[] {11, 12}; arr2[1] = new int[] {21, 22, 23}; arr2[2] = new int[] {31, 32, 33, 34}; for (int i = 0; i &lt; arr2.length; i++) { for (int j = 0; j &lt; arr2[i].length; j++) { System.out.print(arr2[i][j] + \", \"); } System.out.println(); } 11, 12, 21, 22, 23, 31, 32, 33, 34, 고정 크기로 선언하는 것은 가변 크기로 선언하고 채워주는 것과 결과적으로 동일하다. int[][] arr2 = new int[3][4]; = int[][] arr2 = new int[3][]; arr2[0] = new int[4]; arr2[1] = new int[4]; arr2[2] = new int[4]; 그러나 고정 크기를 선언하고 다시 내부를 다른 것으로 바꾸면 이전 것은 다 가비지가 되어버린다. 프로젝트를 할 때는 이렇게 테스트 클래스로 헷갈리는 문법을 사용해보고 프로젝트에 적용해야 한다. 실습 package study.lang.variable; public class Test03 { public static void main(String[] args) { int[][] arr = new int[3][]; arr[0] = new int[] {11, 12}; arr[1] = new int[] {21, 22, 23}; arr[2] = new int[] {31, 32, 33, 34}; System.out.println(arr.length); // 3 for (int i = 0; i &lt; arr.length; i++) { for (int j = 0; j &lt; arr[i].length; j++) { System.out.print(arr[i][j] + \", \"); } System.out.println(); } int[][] arr2 = new int[3][4]; arr2[0] = new int[] {11, 12}; arr2[1] = new int[] {21, 22, 23}; arr2[2] = new int[] {31, 32, 33, 34}; System.out.println(arr2.length); // 3 for (int i = 0; i &lt; arr2.length; i++) { for (int j = 0; j &lt; arr2[i].length; j++) { System.out.print(arr2[i][j] + \", \"); } System.out.println(); } } } 🔆 String[ ][ ] 2차원 배열 생성 시 new 안에 새로운 new를 요소로 둘 수 있다. String[][] arr = new String[][] { new String[] {\"aaa\", \"bbb\"}, new String[] {\"ccc\", \"ddd\", \"eee\"}, }; 1. arr : [200번지] 200-[ ][ ] 2. 400-[\"aaa\"의 주소][\"bbb\"] 500-[\"ccc\"][\"ddd\"][\"eee\"] 3. 200-[ 400 ][ 500 ] new String[], new String[][] 생략 가능 String 배열일 경우 String[][] subMenus = new String[][] { new String[] {\"등록\", \"목록\"}, new String[] {\"등록\", \"목록\", \"조회\"}, new String[] {\"등록\", \"목록\", \"조회\", \"변경\"}, new String[] {\"등록\", \"목록\", \"조회\", \"변경\", \"삭제\"}, }; new String[] 생략 가능 String[][] subMenus = { {\"등록\", \"목록\"}, {\"등록\", \"목록\", \"조회\"}, {\"등록\", \"목록\", \"조회\", \"변경\"}, {\"등록\", \"목록\", \"조회\", \"변경\", \"삭제\"}, }; 바깥의 new String[] 생략 가능 " }, { "title": "App 06 - 08. Method", "url": "/posts/app-06-08/", "categories": "개인 공부, myapp 혼자 다시해보기, 1단계-Java기초", "tags": "예외처리, next()/nextLine(), Refactoring, Parameter and Argument, extract method", "date": "2024-12-09 10:00:00 +0900", "snippet": "App 06. 예외 처리하기1. 학습목표 명령문을 실행하는 중에 예외가 발생했을 때 처리할 수 있다. try ~ catch ~ 문을 사용할 수 있다. 예외처리 문법이 필요한 이유를 설명할 수 있다.2. 요구사항 메뉴 번호가 아닌 문자열을 입력할 때 발생하는 예외 처리3. 작업 메뉴 번호를 입력 받는 코드를 try ~ catch ~ 문으로 감...", "content": "App 06. 예외 처리하기1. 학습목표 명령문을 실행하는 중에 예외가 발생했을 때 처리할 수 있다. try ~ catch ~ 문을 사용할 수 있다. 예외처리 문법이 필요한 이유를 설명할 수 있다.2. 요구사항 메뉴 번호가 아닌 문자열을 입력할 때 발생하는 예외 처리3. 작업 메뉴 번호를 입력 받는 코드를 try ~ catch ~ 문으로 감싼다. 예외가 발생했을 때 처리하는 코드를 catch 블록에 둔다. int menuNo; while (true) { try { System.out.print(\"&gt;\"); menuNo = sc.nextInt(); // 문자 입력 시 예외 처리 if (menuNo &gt;= 1 &amp;&amp; menuNo &lt;= menus.length) { if (menus[menuNo - 1].equals(\"종료\")) { break; } System.out.println(menus[menuNo - 1] + \"입니다.\"); } else { System.out.println(\"올바른 메뉴 번호가 아닙니다.\"); } } catch (InputMismatchException e) { System.out.println(\"메뉴를 숫자로 입력하세요.\"); sc.next(); } } System.out.println(\"종료합니다.\"); sc.close(); 결과 App 07. 문자열 비교와 데이터 변환 다루기1. 학습목표 String.equals( ) 메서드를 활용할 수 있다. Integer.parseInt( ) 메서드를 활용할 수 있다. Scanner의 nextInt( ), next( ), nextLine( )을 구분하여 사용할 수 있다.2. 요구사항 ‘menu’ 명령을 입력하면 메뉴 목록을 출력3. 작업 사용자 입력을 nextLine()을 사용하여 줄 단위로 처리한다. “menu” 명령을 처리한다. 그 외 명령은 정수 값으로 변환하여 처리한다. 기존에는 1~6까지의 정수만을 유효하다고 보고 나머지 수나 다른 타입의 입력은 예외 및 조건 처리했다. 요구사항인 “menu”를 입력 받아서 처리하려면 nextInt()가 아닌 nextLine()을 받아야 한다. (기존의 결과를 최대한 살리는 방향으로 가기) 변형 전 [변형 전] int menuNo; while (true) { try { System.out.print(\"&gt; \"); menuNo = keyboardScanner.nextInt(); if (menuNo &gt;= 1 &amp;&amp; menuNo &lt;= menus.length) { if (menus[menuNo - 1] == \"종료\") { break; } System.out.println(menus[menuNo - 1]); } else { System.out.println(\"유효한 메뉴 번호가 아닙니다.\"); } } catch (InputMismatchException ex) { System.out.println(\"숫자로 메뉴 번호를 입력하세요.\"); keyboardScanner.next(); } } System.out.println(\"종료합니다.\"); 변형 후 String command; while (true) { try { System.out.print(\"&gt;\"); command = sc.nextLine(); if (command.equals(\"menu\")) { System.out.println(bold + line + reset); System.out.println(bold + appTitle + reset); System.out.println(); for (int i = 0; i &lt; menus.length; i++) { if (i == menus.length - 1) { System.out.printf(\"%s%s%d. %s%s\\n\", bold, red, i + 1, menus[i], reset); } else { System.out.printf(\"%d. %s\\n\", i + 1, menus[i]); } } System.out.println(bold + line + reset); } else { int menuNo = Integer.parseInt(command); // 문자의 경우 예외로 이동 if (menuNo &gt;= 1 &amp;&amp; menuNo &lt;= menus.length) { if (menus[menuNo - 1].equals(\"종료\")) { break; } System.out.println(menus[menuNo - 1] + \"입니다.\"); } else { System.out.println(\"올바른 메뉴 번호가 아닙니다.\"); } } } catch (InputMismatchException e) { System.out.println(\"메뉴를 숫자로 입력하세요.\"); sc.next(); } } System.out.println(\"종료합니다.\"); nextInt() 대신 nextLine() 사용에 맞춰 예외처리를 변경한다. nextLine()으로 입력을 받으므로 오류가 날 수 있는 부분은 Integer.parseInt() 부분이다. (”menu”를 제외한 다른 문자열을 int로 변환할 때 생기는 오류) 기존의 오류는 정수값이 아닌 경우의 오류 처리 (InputMismatchException)   ⇒   NumberFormatException catch 문에서 sc.next() 제거 } catch (NumberFormatException e) { System.out.println(\"메뉴를 숫자로 입력하세요.\"); } 결과 🌐 알아 두기 문자열 비교 문자열은 “==”로 비교할 수 없다. equals()로 비교해야 한다. 그렇지 않으면 “menu”를 입력해도 catch로 넘어간다. if (command == \"menu\")   ⇒   **if (command.equals(\"menu\"))** [주의] Java에서는 동일 여부를 비교할 때 equals()를 사용해야 한다. “==”으로 비교하는 경우 실제 값을 비교하는 것이 아니고 메모리 주소를 비교하는 것이다. ⭐중요⭐ nextLine()과 next() nextInt()의 경우 숫자만 읽어 들인다. 이때 white space(\\n, 공백, \\t)를 구분자로 한다. 단 white space를 읽지 않는다. 즉, 숫자 앞에 white space가 있는 경우 무시한다. \\n123   ⇒   123을 읽어들인다. 123\\n456   ⇒   123을 읽어들인다. next()의 경우 white space(\\n, 공백, \\t)를 구분자로 하고 나뉜 앞 부분을 읽는다. 단 white space를 읽지 않는다. 즉, 앞쪽 white space는 무시한다. hello world\\njava   ⇒   앞의 공백은 무시하고 hello를 읽고 반환 nextLine()의 경우 줄바꿈 문자(\\n) 까지의 모든 텍스트를 읽는다. 이후 뒤의 줄바꿈 문자(\\n) 를 제거한다. \\n 가 앞쪽에 있다면   ⇒   “” 빈문자열을 읽어들이고 줄바꿈 문자(\\n) 를 제거한다. hello world\\njava 1번째 읽기   :   hello world   ⇒   줄바꿈 문자(\\n) 제거 2번째 읽기   :   java 따라서 nextLine()을 사용하는 경우   ⇒   catch 문에서 next()를 사용하면 안 된다. nextLine()이 아닌 nextInt()일 때는 aaa\\n를 입력 받으면 오류를 발생시키고 예외를 발생시킨다. 이후 next()가 white space로 구분하여 aaa를 읽어들여서 없앤다. 그러나 nextLine()을 사용하면 aaa\\n를 입력 받으면 aaa를 읽고 \\n을 제거한다. 이후 parseInt()할 때 예외가 발생하고 next()를 호출하면 아무것도 없으므로 입력을 기다린다. 그리고 반복문이 넘어가서 다음 입력을 받을 때 제대로 숫자를 입력해도 nextLine()이 받지 못하고 next()가 먼저 읽는다. 따라서 그 뒤로 읽는 nextLine()은 빈문자열을 읽어들여서 결국 다시 예외로 이동하게 된다. 🔆 Parameter(매개변수)와 Argument(인자) 메서드 정의 int parseInt(String s) { xxxxx } s   =   Parameter   :   Argument를 담을 변수 메서드 호출 Integer.paseInt(\"100\"); ”100”   =   Argument   :   parameter에 전달하는 값 실무에서는 Parameter와 Argument를 구분하지 않고 호칭한다.App 08. 기능 단위로 명령문 묶기 : 메서드 사용법1. 학습목표 스태틱 메서드를 정의하고 사용할 수 있다. 스태틱 필드(변수)를 정의하고 사용할 수 있다. import 명령문을 사용할 수 있다.2. 요구사항 중복 코드를 메서드로 분리 효과   :   기능 변경이 쉽다. 기능 단위로 명령어를 묶어 메서드로 분리 효과   :   코드의 기능을 이해하기 쉽다.   =   가독성이 좋다. 이를 통해 코드의 재사용성을 강화 효과   :   재작성 없이 다른 프로젝트에서도 사용할 수 있다.   =   개발 비용 절감. 3. 작업 메뉴를 출력하는 코드를 printMenu() 메서드로 묶어 사용한다. 중복되는 코드를 메서드로 만들어서 재사용성을 높인다. 메뉴를 출력하는 부분은 동일한 코드가 반복된다. 수정 시 중복되는 부분이 달라지는 위험이 있다. 이렇게 중복되는 코드를 하나의 메서드로 묶어준다. 변수인 boldAnsi, appTitle 등은 “메뉴 출력” 기능에만 사용되므로 메서드에 넣어준다. 단, 메뉴 배열의 경우 main()에서도 사용하므로 static 클래스 변수로 만든다. public class App { static Scanner sc = new Scanner(System.in); static String[] menus = {\"회원\", \"팀\", \"프로젝트\", \"게시판\", \"도움말\", \"종료\"}; public static void main(String[] args) { printMenu(); // 메서드로 전환 String command; while (true) { try { System.out.print(\"&gt;\"); command = sc.nextLine(); if (command.equals(\"menu\")) { printMenu(); // 메서드로 전환 } else { .... } public static void printMenu() { String bold = \"\\u001B[1m\"; String red = \"\\u001B[31m\"; String reset = \"\\u001B[0m\"; String appTitle = \"[팀 프로젝트 관리 시스템]\"; String line = \"--------------------------------------------\"; System.out.println(bold + line + reset); System.out.println(bold + appTitle + reset); System.out.println(); for (int i = 0; i &lt; menus.length; i++) { if (i == menus.length - 1) { System.out.printf(\"%s%s%d. %s%s\\n\", bold, red, i + 1, menus[i], reset); } else { System.out.printf(\"%d. %s\\n\", i + 1, menus[i]); } } System.out.println(bold + line + reset); } } 사용자로부터 명령을 입력 받는 코드를 prompt() 메서드로 묶어 사용한다. public static void main(String[] args) { printMenu(); String command; while (true) { try { command = prompt(); if (command.equals(\"menu\")) { printMenu(); } else { .... } public static String prompt() { System.out.print(\"&gt;\"); return sc.nextLine(); } 메뉴 번호의 유효성을 검증하는 코드를 isValidateMenu() 메서드로 묶어 사용한다. .... String command; while (true) { try { command = prompt(); if (command.equals(\"menu\")) { printMenu(); } else { int menuNo = Integer.parseInt(command); // 문자의 경우 예외로 이동 if (isValidateMenu(menuNo)) { if (menus[menuNo - 1].equals(\"종료\")) { break; } System.out.println(menus[menuNo - 1] + \"입니다.\"); } else { System.out.println(\"올바른 메뉴 번호가 아닙니다.\"); } } .... public static boolean isValidateMenu(int menuNo) { return menuNo &gt;= 1 &amp;&amp; menuNo &lt;= menus.length; } 메뉴 타이틀을 알아내는 코드를 getMenuTitle() 메서드로 묶어 사용한다. .... command = prompt(); if (command.equals(\"menu\")) { printMenu(); } else { int menuNo = Integer.parseInt(command); // 문자의 경우 예외로 이동 if (isValidateMenu(menuNo)) { if (getMenuTitle(menuNo).equals(\"종료\")) { break; } System.out.println(getMenuTitle(menuNo) + \"입니다.\"); } else { System.out.println(\"올바른 메뉴 번호가 아닙니다.\"); } } .... public static String getMenuTitle(int menuNo) { return menus[menuNo - 1]; } 메뉴를 처리하는 조건문(유효한 번호, 유효하지 않은 번호, 종료)을 정리한다. public static void main(String[] args) { printMenu(); String command; while (true) { try { command = prompt(); if (command.equals(\"menu\")) { printMenu(); } else { int menuNo = Integer.parseInt(command); String menuTitle = getMenuTitle(menuNo); if (menuTitle == null) { System.out.println(\"올바른 메뉴 번호가 아닙니다.\"); } else if (menuTitle.equals(\"종료\")) { break; } else { System.out.println(menuTitle); } } } catch (NumberFormatException e) { System.out.println(\"메뉴를 숫자로 입력하세요.\"); } public static String getMenuTitle(int menuNo) { if (isValidateMenu(menuNo)) { return menus[menuNo - 1]; } return null; } 결과 ⇒ 변경 없음 🔆 메서드 (Method) 메서드   -   명령문 묶음 UML (Unified Modeling Language)를 사용해서 코드를 글과 그림으로 표현 클래스 다이어그램 refactoring 기법 중 extract method을 사용한다. Class Diagram 사이트   :   https://app.diagrams.net/ 코드 리펙토링&lt;/span&gt;을 하면 가독성이 좋아져 이해가 빨라지고 코드 재사용성이 높아지므로 개발 시간이 단축된다. 궁극적으로 개발 비용이 절감된다. 메서드 호출   *printMenu*(); 메서드에 묶인 코드를 실행하는 것을 “메서드를 호출한다”라고 부른다. " }, { "title": "실습 프로젝트 준비", "url": "/posts/project-preparation/", "categories": "개인 공부, bitcamp 수업, 기초", "tags": "Markdown, Hash Code, Package, Refactoring", "date": "2024-12-08 02:00:00 +0900", "snippet": "실습 프로젝트 준비🔆 프로젝트 생성 및 빌드, 실행 저장소(git/bitcamp-mystudy/)에 프로젝트 폴더(myapp) 생성 Gradle 빌드 도구를 이용해 프로젝트 폴더 구성하기 &gt;Exception in thread \"main\" java.util.NoSuchElementException at java.base/j...", "content": "실습 프로젝트 준비🔆 프로젝트 생성 및 빌드, 실행 저장소(git/bitcamp-mystudy/)에 프로젝트 폴더(myapp) 생성 Gradle 빌드 도구를 이용해 프로젝트 폴더 구성하기 &gt;Exception in thread \"main\" java.util.NoSuchElementException at java.base/java.util.Scanner.throwFor(Scanner.java:945) at java.base/java.util.Scanner.next(Scanner.java:1602) at java.base/java.util.Scanner.nextInt(Scanner.java:2267) at java.base/java.util.Scanner.nextInt(Scanner.java:2221) at bitcamp.myapp.App.main(App.java:39) 개….🔆 해시코드 해시코드   =   식별코드   (주민번호와 같은 것)" }, { "title": "App 01 - 05. Java 기본 문법", "url": "/posts/app-01-05/", "categories": "개인 공부, myapp 혼자 다시해보기, 1단계-Java기초", "tags": "Gradle, println(), ANSI, Scanner, 반복문, 조건문", "date": "2024-12-08 01:00:00 +0900", "snippet": "App 01. 자바 프로젝트 준비하기1. 학습 목표 Gradle 빌드 도구를 사용하여 자바 프로젝트 폴더를 구성할 수 있다. Gradle 빌드 스크립트 파일(build.gradle)에서 실행할 클래스를 설정할 수 있다. Gradle 빌드 도구를 사용하여 애플리케이션을 실행할 수 있다. 콘솔로 값을 출력할 수 있다. IntelliJ IDE에서 ...", "content": "App 01. 자바 프로젝트 준비하기1. 학습 목표 Gradle 빌드 도구를 사용하여 자바 프로젝트 폴더를 구성할 수 있다. Gradle 빌드 스크립트 파일(build.gradle)에서 실행할 클래스를 설정할 수 있다. Gradle 빌드 도구를 사용하여 애플리케이션을 실행할 수 있다. 콘솔로 값을 출력할 수 있다. IntelliJ IDE에서 Gradle 프로젝트를 실행할 수 있다.2. 요구사항 myapp 폴더를 만들고 자바 프로젝트 폴더로 구성 IntelliJ IDE로 프로젝트 가져온 후 실행3. 작업 Git Repo 생성   (bitcamp-myapp2) 명령 프롬프트   (~/git/bitcamp-myapp2) river@BOOK-VKBCE9E5R0 MINGW64 ~/git/bitcamp-myapp2 (main) $ gradle init Starting a Gradle Daemon, 2 incompatible and 1 stopped Daemons could not be reused, use --status for details Found existing files in the project directory: 'C:\\Users\\river\\git\\bitcamp-myapp2'. Directory will be modified and existing files may be overwritten. Continue? (default: no) [yes, no] yes Select type of build to generate: 1: Application 2: Library 3: Gradle plugin 4: Basic (build structure only) Enter selection (default: Application) [1..4] 1 Select implementation language: 1: Java 2: Kotlin 3: Groovy 4: Scala 5: C++ 6: Swift Enter selection (default: Java) [1..6] 1 Enter target Java version (min: 7, default: 21): Project name (default: bitcamp-myapp2): Select application structure: 1: Single application project 2: Application and library project Enter selection (default: Single application project) [1..2] 1 Select build script DSL: 1: Kotlin 2: Groovy Enter selection (default: Kotlin) [1..2] 2 Select test framework: 1: JUnit 4 2: TestNG 3: Spock 4: JUnit Jupiter Enter selection (default: JUnit Jupiter) [1..4] Generate build using new APIs and behavior (some features may change in the next minor release)? (default: no) [yes, no] &gt; Task :init Learn more about Gradle by exploring our Samples at https://docs.gradle.org/8.10.2/samples/sample_building_java_applications.html BUILD SUCCESSFUL in 1m 46s 1 actionable task: 1 executed Build 완료 테스트 river@BOOK-VKBCE9E5R0 MINGW64 ~/git/bitcamp-myapp2 (main) $ gradle run &gt; Task :app:run Hello World! BUILD SUCCESSFUL in 1s 2 actionable tasks: 2 executed build.gradle 수정 IntelliJ에서 패키지를 먼저 수정한 후   (기존 : org.example.App   ⇒   bitcamp.myapp.App) application { // Define the main class for the application. mainClass = 'bitcamp.myapp.App' } IntelliJ에서 gradle run 실행 &gt; Task :app:run Hello World! BUILD SUCCESSFUL in 178ms 3 actionable tasks: 1 executed, 2 up-to-date 오후 12:48:27: 실행이 완료되었습니다 'run'. App 02. 메뉴 만들기1. 학습목표 문자열 및 숫자 등을 리터럴로 표현할 수 있다. 변수를 사용하여 값을 다룰 수 있다. 출력문을 사용하여 값을 콘솔로 출력할 수 있다.2. 요구사항 애플리케이션의 제목과 기본 메뉴 출력3. 작업 제목을 저장할 변수 선언 및 초기화 구분선을 저장할 변수 선언 및 초기화 메뉴를 저장할 변수 선언 및 초기화 제목, 구분선, 메뉴를 출력할 문장 작성 package bitcamp.myapp; public class App { public static void main(String[] args) { String appTitle = \"[팀 프로젝트 관리 시스템]\"; String menu1 = \"1. 회원\"; String menu2 = \"2. 팀\"; String menu3 = \"3. 프로젝트\"; String menu4 = \"4. 게시판\"; String menu5 = \"5. 도움말\"; String menu6 = \"6. 종료\"; String line = \"--------------------------------------------\"; System.out.println(line); System.out.println(appTitle); System.out.println(); System.out.println(menu1); System.out.println(menu2); System.out.println(menu3); System.out.println(menu4); System.out.println(menu5); System.out.println(menu6); System.out.println(line); } } 🔆 Java 클래스명 관례 클래스 이름은 카멜 표기법 사용하는 것이 International Rule (클래스명이 여러 단어인 경우 단어 사이의 ‘_’는 관례상 사용 안함) 첫단어는 소문자로 시작, 다음 단어는 대문자로 시작 변수명 앞에 숫자로 시작 불가능 App 03. ANSI 이스케이프 코드를 사용하여 출력 문자열 꾸미기1️. 학습목표 ANSI 이스케이프 문자를 다룰 수 있다. Gradle 빌드 도구의 옵션을 이용하여 콘솔 출력을 제어할 수 있다. 코드 정리 기법 중 ‘설명하는 변수’를 활용할 수 있다.2. 요구사항 애플리케이션 제목을 볼드체로 출력 위, 아래 구분선을 볼드체로 출력 ‘6. 종료’ 메뉴를 빨강색 + 볼드체로 출력 Gradle 디버깅 출력은 제거3. 작업 구분선, 제목, 종료 메뉴에 ANSI 이스케이프 문자를 적용 코드 정리 기법 ‘설명하는 변수’를 적용하여 ANSI 이스케이프 문자를 변수를 사용하여 출력 제어 public class App { public static void main(String[] args) { String bold = \"\\u001B[1m\"; // 리펙토링 : 변수에 담아두기 String red = \"\\u001B[31m\"; // 좀 더 읽기 쉽게 변함 String reset = \"\\u001B[0m\"; String appTitle = \"[팀 프로젝트 관리 시스템]\"; String menu1 = \"1. 회원\"; String menu2 = \"2. 팀\"; String menu3 = \"3. 프로젝트\"; String menu4 = \"4. 게시판\"; String menu5 = \"5. 도움말\"; String menu6 = \"6. 종료\"; String line = \"--------------------------------------------\"; System.out.println(bold + line + reset); System.out.println(bold + appTitle + reset); System.out.println(); System.out.println(menu1); System.out.println(menu2); System.out.println(menu3); System.out.println(menu4); System.out.println(menu5); System.out.println(bold + red + menu6 + reset); System.out.println(bold + line + reset); } } Gradle 콘솔 출력 제어   :   실행   /   구성편집   /   실행 옵션 추가(--quiet) 콘솔 제어를 하여 run --quiet로 실행함. (gradle 콘솔 출력 제어 설명) 🔆 리펙토링   -   설명하는 변수 리펙토링 설명 아래의 코드는 요구사항을 만족하는 것이다. 이렇게 요구 사항 만족이 확인되면 System.out.println(\"\\u001B[31m안녕하세요\\u001B[0m\"); 아래 처럼 리펙토링(中 ’설명하는 변수’)을 하여 코드를 정리한다. String red = \"\\u001B[31m\"; // 빨강 String bold = \"\\u001B[1m\"; // 볼드체 String reset = \"\\u001B[0m\"; // 리셋 System.out.println(red + bold + (i+1) + \". \" + menu[i] + reset); 변수 선언 그 자체로 설명이 된다. App 04. 표준 입력 스트림(키보드 입력) 활용1. 학습목표 키보드 입력을 다룰 수 있다. 조건문을 사용하여 실행을 분기할 수 있다. 반복문을 사용하여 특정 명령문을 반복해서 실행할 수 있다. Gradle로 run 태스크를 실행할 때 키보드를 표준 입력으로 사용할 수 있게 설정할 수 있다.2. 요구사항 사용자로부터 메뉴 번호를 입력 받기 메뉴 번호에 해당하는 메뉴 이름을 출력 종료 메뉴 번호를 입력하면 실행을 종료3. 작업 프롬프트를 통해 입력 받는 기능을 구현 java.util.Scanner, System.in 사용     (import java.util.Scanner) import java.util.Scanner; public class App { public static void main(String[] args) { Scanner sc = new Scanner(System.in); 반복문(do ~ while 문)을 이용하여 메뉴 입력을 반복해서 처리 String bold = \"\\u001B[1m\"; // 리펙토링 : 변수에 담아두기 String red = \"\\u001B[31m\"; // 좀 더 읽기 쉽게 변함 String reset = \"\\u001B[0m\"; String appTitle = \"[팀 프로젝트 관리 시스템]\"; String line = \"--------------------------------------------\"; String[] menu = {\"회원\", \"팀\", \"프로젝트\", \"게시판\", \"도움말\", \"종료\"}; System.out.println(bold + line + reset); System.out.println(bold + appTitle + reset); System.out.println(); for (int i = 0; i &lt; menu.length; i++) { if (i == menu.length - 1) { System.out.printf(\"%s%s%d. %s%s\\n\", bold, red, i + 1, menu[i], reset); } else { System.out.printf(\"%d. %s\\n\", i + 1, menu[i]); } } 메뉴 번호에 따라 출력 문구를 변경하는 조건(switch 문)을 처리 int menuNo; do { System.out.print(\"&gt;\"); menuNo = sc.nextInt(); switch (menuNo) { case 1: System.out.println(menu[0] + \"입니다.\"); break; case 2 : System.out.println(menu[1] + \"입니다.\"); break; case 3 : System.out.println(menu[2] + \"입니다.\"); break; case 4 : System.out.println(menu[3] + \"입니다.\"); break; case 5 : System.out.println(menu[4] + \"입니다.\"); break; case 6 : System.out.println(menu[5] + \"입니다.\"); break; default: System.out.println(\"올바른 메뉴 번호가 아닙니다.\"); } } while (menuNo != menu.length); System.out.println(bold + line + reset); ⛔[오류 발생]⛔   -   java.util.NoSuchElementException Scanner 객체를 사용하여 입력을 받을 때 오류 발생 &gt;Exception in thread \"main\" java.util.NoSuchElementException at java.base/java.util.Scanner.throwFor(Scanner.java:945) at java.base/java.util.Scanner.next(Scanner.java:1602) at java.base/java.util.Scanner.nextInt(Scanner.java:2267) at java.base/java.util.Scanner.nextInt(Scanner.java:2221) at bitcamp.myapp.App.main(App.java:39) 표준 입력 스트림(System.in)을 활성해야 한다. build.gradle 수정하기 run { standardInput = System.in } 기본 값은 empty stream이다. 결과 🔆 import 문 코드에 직접 넣는 방법 1 java.io.InputStream keyboard = System.in; java.util.Scanner keyboardScanner = new java.util.Scanner(keyboard); 코드에 직접 넣는 방법 2 java.util.Scanner keyboardScanner = new java.util.Scanner(System.in); System.in은 Scanner와 함께 사용할 때 자동으로 인식된다. import 문을 사용한 간결한 방법 import java.util.Scanner; Scanner sc = new Scanner(System.in); Java 교재 - [ex99] 200번대 = 입력 처리 관련🔆 표준 입력을 키보드 입력으로 설정하는 방법 gradle로 실행할 때 gradle에서는 입출력이 없다. 그래서 추가해줘야 한다. build.gradle의 run 부분을 추가해줘야 한다. run { standardInput = System.in // 기본 값은 empty stream 이다. } 🔆 Gradle의 standardInput (표준 입력) gradle.org 사이트(http://gradle.org)에 가서 설정 매뉴얼 보기 docs 메뉴   →   user guide   →   reference   →   core plugins →   packaing and distribution 항목의 application 클릭 →   Tasks의 run   →   JavaExec의 클릭   →   Properties의 standardInput 항목 보기 standardInput   : The standard input stream for the process executing the command. The stream is closed after the process completes. Defaults to an empty stream. (표준 입력이 설정이 안 되어있는 것이 디폴트 값이다.) 🔆 Scanner의 close( ) Scanner는 사용을 다 한 경우 close() 해주는 것이 좋다. 우리는 프로그램을 사용하고 종료하지만, 서버에서는 계속해서 실행하므로 자원을 낭비하게 되어 자원 부족이 발생할 수 있다. 사용을 완료한 자원은 반환해야 다른 프로세스(프로그램)이 사용할 수 있다.단, JVM을 종료하면 JVM이 사용한 모든 자원은 강제 회수된다.   (OS가 강제 회수)App 05. 배열을 활용하여 메뉴 목록 다루기1. 학습목표 배열을 다룰 수 있다. for 반복문을 이용하여 배열을 다룰 수 있다. while 반복문과 break를 다룰 수 있다. printf()를 사용하여 문자열의 출력 포맷을 제어할 수 있다.2. 요구사항 메뉴를 배열에 저장하여 출력3. 작업 메뉴를 개별 변수에 저장하는 대신에 String[ ] 배열에 저장한다. for 반복문을 이용하여 메뉴를 출력한다. 메뉴를 처리할 때 switch ~ case 문 대신에 if ~ else 조건문을 이용한다. 반복적으로 사용자 입력을 처리할 때 do ~ while 대신에 while 과 break를 이용한다. 수정 전 int menuNo; do { System.out.print(\"&gt; \"); menuNo = sc.nextInt(); if (menuNo &gt;= 1 &amp;&amp; menuNo &lt;= menus.length) { if (menus[menuNo - 1] != \"종료\") { System.out.println(menus[menuNo - 1]); } } else { System.out.println(\"메뉴 번호가 옳지 않습니다.\"); } } while (menus[menuNo - 1] != \"종료\"); System.out.println(\"종료합니다.\"); do ~ while을 썼을 때 배열을 범위를 넘어서 오류가 발생함 menuNo를 배열의 크기 이상의 값으로 입력 시 에러 발생 while (menus[menuNo - 1] != \"종료\"); // 오류 발생 부분 만약 키보드 입력이 9인 경우, menus[9 - 1 = 8]을 참조해야 하는데 배열의 범위를 벗어난다. 수정 후 int menuNo; while (true) { System.out.print(\"&gt;\"); menuNo = sc.nextInt(); if (menuNo &gt;= 1 &amp;&amp; menuNo &lt;= menus.length) { if (menus[menuNo - 1] == \"종료\") { break; } System.out.println(menus[menuNo - 1] + \"입니다.\"); } else { System.out.println(\"올바른 메뉴 번호가 아닙니다.\"); } } System.out.println(\"종료합니다.\"); 결과 🌐 알아 두기 배열 초기화 배열을 초기화 하는 것도 하나 씩 넣을 수 있지만 한 번에 넣을 수 있다. String[] menus = new String[6]; menus[0] = \"회원\"; ... menus[5] = \"종료\"; String[] menus = {\"회원\", \"팀\", \"프로젝트\", \"게시판\", \"도움말\", \"종료\"}; If 조건 변경 if문의 조건을 menus[i] == “종료”로 바꾼다. ⇒   인덱스로 제어하는 것보다 메뉴를 추가할 때 자동으로 종료 메뉴만을 선택 가능 for (int i = 0; i &lt; menu.length; i++) { if (i == 5) { System.out.println(redAnsi + boldAnsi + (i + 1) + \". \" + menu[i] + resetAnsi); } else { System.out.println((i + 1) + \". \" + menu[i]); } } for (int i = 0; i &lt; menus.length; i++) { if (menus[i] == \"종료\") { System.out.printf(\"%s%d. %s%s\\n\", (redAnsi + boldAnsi), (i + 1), menus[i], resetAnsi); } else { System.out.printf(\"%d. %s\\n\", (i + 1), menus[i]); } } " }, { "title": "SpringBoot 계층 구조", "url": "/posts/oop-layeredarchitecture/", "categories": "코딩 지식, OOP, Layer", "tags": "Layer, Controller, Service, DAO, DataBasea", "date": "2024-12-05 11:00:00 +0900", "snippet": "계층 구조계층 구조(Layered Architecture)란 기본적으로 프레임워크를 사용해서 API 서버를 만들 때 ⇒   해당 프레임워크 구조를 지키며 만들어야 한다.   (협업의 문제) 계층 구조의 핵심   :   “관심사 분리” ⇒   즉, “내가 담당하는 업무만 신경 쓰고 다른 부분은 다른 계층...", "content": "계층 구조계층 구조(Layered Architecture)란 기본적으로 프레임워크를 사용해서 API 서버를 만들 때 ⇒   해당 프레임워크 구조를 지키며 만들어야 한다.   (협업의 문제) 계층 구조의 핵심   :   “관심사 분리” ⇒   즉, “내가 담당하는 업무만 신경 쓰고 다른 부분은 다른 계층이 담당한다” SpringBoot + Mybatis의 계층 구조     (MVC + Service + DAO 아키텍처) Controller Layer   (Controller) Service Layer   (Service) Persistence Layer   (DAO) Model   (VO) Database Layer   (ex. MySQL) 대표적인 계층 구조의 예시로 ⭐ MVC + Service + DAO 아키텍처 ⭐라 한다. ⭐나의 코드 ⭐ 위의 그림은 내가 구상한 벡엔드에서 Layer 구조이다. DTO와 VO를 혼용하였다. 비즈니스 로직이 복잡하다고 판단했고, DB 테이블을 VO로 반환하고 이를 서비스단에서 DTO로 전환시키는 방법을 사용하였다. 현재 VO는 비즈니스 로직이 없는 그냥 데이터 전달 용도로만 사용되고 있다. 따라서, 거의 DTO와 유사하게 사용되고 있으므로 VO 없이 DTO만 사용하도록 바꿀 예정이다. ⭐현업 ⭐ 이렇게 VO를 단순한 데이터 전달 용도로 사용하는 경우 DTO로 쓰이고 있다고 볼 수도 있다. 원래는 구분하여 사용하는 것이 이상적이지만, 대부분 그냥 사용한다. 많은 현업에서는 VO와 DTO를 혼용하지 않고 DTO만 사용하여 데이터를 처리한다. 각 계층의 역할 Controller Layer     (Web Layer, Presentation Layer) 클라이언트 요청 처리   (HTTP 요청 처리) 인증 로직 처리 Validation 라이브러리 Service Layer     (Business Layer) @Service 비즈니스 로직 처리 Presentation Layer에서 전달 받은 데이터를 유효성 검사 비즈니스 로직을 이곳에서 처리하지 않는다면 DDD 방식일 수 있다. 트랜잭션 적용 영역 (@Transactional) Controller와 Dao의 중간 영역 Persistence Layer     (지속성 계층) DAO (Mybatis)   /   Repository (JPA) Mybatis SQL 기반 ORM 프레임워크 데이터베이스와의 연결은 JDBC 드라이버를 통해 이루어지며, 사용하는 DBMS에 따라 Mapper 파일의 SQL 문법만 달라질 수 있다. DAO (@Mapper) MyBatis Mapper 파일 (.xml) Database와 같이 데이터 저장소에 접근하는 영역   (= Dao(Data Access Object) 영역) 데이터베이스에 대한 논리 모델을 나타낸다. 데이터베이스와 상호작용 비즈니스 로직에서 생성된 개체를 데이터베이스 개체로 변환 데이터 저장, 조회, 갱신, 삭제 Domain Layer 도메인 객체   :   VO, Entity Domain Layer은 비즈니스 로직을 가진 Domain 객체가 존재할 때 사용하는 개념 SpringBoot + Mybatis의 경우 VO는 단순히 데이터 전달 객체로 쓰이므로 Domain Layer는 없다고 볼 수 있다. 이 경우 VO는 Model이라 많이 한다. MVC 패턴에서는 Domain 객체라는 용어를 사용하지 않고 Model 이라는 용어로 다룬다. MVC에서의 Model은 비즈니스 로직을 포함할 수도 있고, 단순한 데이터를 표현하는 객체일 수도 있다 Domain 객체를 사용하고 있다면 Model이 곧 Domain 객체가 된다. 단, 비즈니스 로직이 서비스 계층에만 있고 Model이 단순 데이터 구조로만 사용된다면 Model은 더 이상 Domain 객체가 아니게 됩니다. Database Layer 실제 DBMS(ex. MySQL 서버)와 물리적인 데이터베이스 파일이 있는 외부 환경 DTO (Data Transfer Object) 특정 계층에 소속되지 않는다. 데이터 교환을 위한 객체   (계층 간 데이터를 주고 받을 때 사용) (그 외)   DDD 방식 Domain-Driven Design 방식 Domain 객체가 비즈니스 로직의 중심이 되어야 한다는 방식 서비스 계층(Service Layer)은 단순히 도메인 객체의 메서드를 호출하고 트랜잭션을 관리하는 역할 Service Layer에서 Persistence Layer를 호출하여 DB의 데이터를 Domain 객체로 받아오고 이 Domain 객체에서 비즈니스 로직 처리까지 하는 방법 비즈니스 로직을 도메인에 넣는 이유 기존에 Service로 비즈니스 로직을 처리하던 방식은 트랜잭션 스크립트라고 한다. 모든 로직이 서비스 클래스 내부에서 처리하면 서비스 계층이 무의미하며, 객체란 단순히 데이터 덩어리 역할만 하게 된다. 서비스 메소드는 트랜잭션과 도메인 간의 순서만 보장 (각각의 도메인이 본인의 이벤트 처리) 그러나, Domain 객체에 비즈니스 로직을 넣으면 복잡해질 수 있다.   (즉, 유지보수가 힘들어진다)VO과 Entity VO Mybatis 사용 시 VO를 사용한다. MyBatis에서는 VO를 주로 사용하며, 데이터를 DB 테이블의 컬럼과 매핑하고 그 값을 VO로 반환 VO는 DB 테이블에서 데이터를 가져오거나, 클라이언트에 반환할 데이터를 저장하는 객체로 사용 즉, MyBatis를 사용할 때는 VO를 데이터 전송 및 조회 용도로 사용 비즈니스 로직을 처리하려면 서비스 계층에서 로직을 처리하거나, 도메인 객체를 설계하여 해당 로직을 캡슐화하는 방식으로 설계할 수 있다. JPA에서는 Entity가 필요하지만, MyBatis에서는 Entity 대신 VO만 사용해도 된다. 그러나 비즈니스 로직이나 객체 간의 관계가 복잡한 경우, VO만으로 처리하는 것보다는 Entity와 Domain 모델을 함께 사용하는 것이 더 적합할 수 있다. Entity JPA 사용 시 Entity를 DB 테이블과 매핑시킨다. " }, { "title": "클래스 정의 방법론 (GRASP / SOLID)", "url": "/posts/oop-class/", "categories": "코딩 지식, OOP, Class", "tags": "GRASP, SOLID, Desgin Pattern", "date": "2024-12-03 16:00:00 +0900", "snippet": "클래스 정의 방법론클래스 정의와 방법론 방법론   :   클래스를 정의하는 기법들에 대한 조언 객체지향 프로그램에서 책임을 부여한다는 것은 그 클래스에게 메서드를 부여한다는 것이다. GRASP 방법론 클래스를 정의할 때 9가지 요소를 바탕으로 정의 여기서 더 들어간 것이 SOLID 패턴이다. GRASP 방법...", "content": "클래스 정의 방법론클래스 정의와 방법론 방법론   :   클래스를 정의하는 기법들에 대한 조언 객체지향 프로그램에서 책임을 부여한다는 것은 그 클래스에게 메서드를 부여한다는 것이다. GRASP 방법론 클래스를 정의할 때 9가지 요소를 바탕으로 정의 여기서 더 들어간 것이 SOLID 패턴이다. GRASP 방법론     (9가지) General Responsibility Assignment Software Patterns Information Expert     :     데이터를 잘 아는 객체가 책임을 가진다 Creator     :     객체 생성은 관련 있는 객체가 담당 Controller     :     외부 이벤트를 처리하고 내부로 전달 Low Coupling     :     객체 간 의존성 최소화 High Cohesion     :     객체의 책임은 논리적으로 관련 Polymorphism     :     동일 행위에 다른 구현 Pure Fabrication     :     설계를 위한 인위적인 객체 추가 Indirection     :     간접 연결로 결합도 낮춤 Protected Variations     :     변경 가능성 있는 부분을 추상화로 보호 1. Inforamtion Expert,   정보 전문가 “어떤 책임을 맡아야 할지 결정할 때, 해당 책임을 수행하는 데 필요한 정보를 가장 잘 알고 있는 객체에 할당하라” 2. Low Coupling 한 클래스가 하나의 일을 하도록 해라 “객체 간의 결합도를 낮춰, 객체 변경 시 다른 객체에 미치는 영향을 최소화하라.” 객체 간의 상호 의존성을 줄여 유연성과 재사용성을 높입니다. DIP(의존성 역전 원칙) 및 인터페이스 사용과 연관됩니다. 3. High Cohesion “하나의 객체가 맡은 책임이 논리적으로 관련되어 있도록 하여, 객체의 집중도를 높이고 명확하게 하라.” 객체가 지나치게 많은 책임을 가지면 응집도가 낮아지고 관리가 어려워집니다. SRP(단일 책임 원칙)와 유사합니다. 4. Creator “객체를 생성하는 책임을 적절한 다른 객체에 할당하라.” 어떤 객체가 다른 객체를 생성할 책임을 가지는지 결정하는 원칙 누가 누구를 만들어야 할까?의 답 Creator 패턴은 객체를 생성하는 책임을 적절한 다른 객체에 위임함으로써 코드의 응집도를 높이고 설계를 깔끔하게 만드는 데 도움을 줍 SpringBoot   :   @bean, @Component, @Service 등 5. Controller “시스템 외부에서 발생하는 이벤트를 처리할 책임을 가진 객체를 정의하라.” 사용자나 외부 시스템에서 발생하는 요청이나 이벤트(버튼 클릭, 데이터 전송 등)를 어떤 객체나 클래스가 책임지고 처리할지 결정하는 것 [ex] UserCommand, ProjectCommand, UserController, StoryController … SpringBoot   :   @RestController, @Controller 개발자들이 클래스들을 만들었는데 이것을 보다 보니 **Software 패턴**을 발견했다. 이것을 정리한 것이 GRASP 방법론이다. 1. Information Expert (정보 전문가)“어떤 책임을 맡아야 할지 결정할 때, 해당 책임을 수행하는 데 필요한 정보를 가장 잘 알고 있는 객체에 할당하라.” 객체가 필요한 데이터를 소유하거나 쉽게 접근할 수 있다면, 그 객체가 해당 작업을 수행하도록 해야 합니다. 이 원칙은 책임을 데이터와 가까이 유지하여 응집도를 높입니다.예: UserService가 사용자 정보(User)를 생성하거나 조회하는 책임을 가지는 것.2. Creator (생성자)“객체를 생성하는 책임을 적절한 다른 객체에 할당하라.”객체 생성 책임을 다음 중 하나에 해당하는 객체에 할당: 생성될 객체를 포함하거나 사용. 생성될 객체의 데이터를 알고 있음. 생성될 객체와 강하게 연관됨.예: Car 객체가 자신의 Wheel 객체들을 생성.3. Controller (컨트롤러)“시스템 외부에서 발생하는 이벤트를 처리할 책임을 가진 객체를 정의하라.” 사용자 요청이나 시스템 이벤트를 처리하는 중간 관리자 역할. 이벤트를 받아 적절한 객체로 전달하고 결과를 반환합니다.예: Spring Boot의 UserController가 HTTP 요청을 받아 UserService로 위임.4. Low Coupling (낮은 결합도)“객체 간의 결합도를 낮춰, 객체 변경 시 다른 객체에 미치는 영향을 최소화하라.” 객체 간의 상호 의존성을 줄여 유연성과 재사용성을 높입니다. DIP(의존성 역전 원칙) 및 인터페이스 사용과 연관됩니다.예: UserController가 UserService 인터페이스에 의존함으로써, 서비스 구현 변경에 영향을 받지 않음.5. High Cohesion (높은 응집도)“하나의 객체가 맡은 책임이 논리적으로 관련되어 있도록 하여, 객체의 집중도를 높이고 명확하게 하라.” 객체가 지나치게 많은 책임을 가지면 응집도가 낮아지고 관리가 어려워집니다. SRP(단일 책임 원칙)와 유사합니다.예: UserService는 사용자 관련 작업만 담당하며, 다른 책임은 다른 서비스로 분리.6. Polymorphism (다형성)“행위(메서드)를 기반으로 책임을 할당할 때, 동일한 행위가 여러 타입에서 다르게 동작하도록 하라.” 다형성을 활용하여 객체가 동일한 메시지에 대해 서로 다른 동작을 수행하도록 합니다.예: Payment 인터페이스를 구현한 CreditCardPayment와 PayPalPayment 클래스가 각각 다른 방식으로 결제를 처리.7. Pure Fabrication (순수 가공 객체)“시스템 설계에서, 현실 세계와 관련되지 않더라도 재사용성과 응집도를 위해 만들어진 객체를 사용하라.” 설계를 명확히 하고, 책임 분리를 위해 만든 인위적인 객체. 현실 도메인 모델에 없는 객체지만, 설계상의 필요로 추가됩니다.예: Logger, Repository, Service 등이 도메인 모델과는 별개로 설계에 추가된 객체.8. Indirection (간접화)“객체 간의 직접적인 의존을 줄이고, 중간 객체를 사용하여 유연성과 결합도를 낮추라.” *중재자(Mediator)나 **프록시(Proxy) 같은 패턴에서 자주 사용. 객체 간의 직접적인 연결 대신 중간 객체가 연결을 관리.예: Spring의 @Transactional이 데이터베이스 트랜잭션 처리 로직을 간접화하여, 비즈니스 로직과 DB 연결을 분리.9. Protected Variations (변경 보호)“변경될 가능성이 높은 부분을 식별하고, 이를 인터페이스나 추상화로 보호하라.” 변화하는 요구사항이 있을 경우, 설계가 이를 잘 흡수하도록 보호장치를 마련. 인터페이스나 추상 클래스를 통해 변화가 다른 객체에 영향을 미치지 않도록 함.예: PaymentService 인터페이스를 통해, 결제 방식(CreditCard, PayPal 등)을 변경하더라도 클라이언트 코드가 영향을 받지 않도록 설계.SOLID 방법론 객체지향 설계에 주요 원칙이다. 가장 중요한 것은 이 원칙들을 따르면 S/W는 더 모듈화되고 유지보수가 쉬워지고 확장이 쉬워진다. SRP     (Single Responsibility Principle,   단일 책임 원칙) “클래스는 단 하나의 책임만 가져야 하며, 하나의 변경 사유만 가져야 한다.” 하나의 클래스는 하나의 역할만 가져야 한다. 변경이 필요할 경우 그 클래스의 단일 책임에 대해서만 수정이 이루어져야 한다. 하나의 클래스가 하나의 책임만을 갖는다.   (GRASP의 High Cohesion )OCP     (Open Close Principle,   개방/폐쇄 원칙) “확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.” 인터페이스와 추상화를 통해 새로운 기능을 추가할 때 기존 코드에 영향을 미치지 않는다. 변경에는 개방적이지만 기존 코드는 손대지 마라. ⇒   즉, 기존 코드는 손 대지 말고 기능을 추가해야 한다.   (상속, 오버라이딩, 오버로딩) 향후 기존 코드를 손대지 않고 클래스를 추가할 수 있게 초기에 클래스를 잘 설계해야 한다. ⇒   디자인 패턴   (클래스 설계 비기) LSP     (Liskov Subistitution Principle,   리스코프 치환 원칙) “하위 클래스는 부모 클래스에서 정의된 행동을 완전히 대체할 수 있어야 한다.” 부모 클래스를 사용하는 클라이언트는 하위 클래스도 문제없이 사용할 수 있어야 한다. 프로그램을 짤 때 그것을 다른 것으로 대체하기 쉽게 프로그램을 설계해라. 즉, 다른 프로그램으로 교체하기 쉽도록 프로그램을 짜라. ⇒   인터페이스 SpringBoot   :   Service LayerISP     (Interface Segregation Principle,   인터페이스 분리 원칙) “인터페이스는 클라이언트가 사용하지 않는 메서드에 의존하지 않도록 설계해야 한다.” 하나의 거대한 인터페이스보다는 작은 인터페이스를 여러 개 만들어야 한다. 클라이언트는 자신이 사용하는 메서드에만 의존해야 한다. DIP     (Dependency Inversion Principle,   의존성 역전 원칙) “상위 모듈은 하위 모듈에 의존해서는 안 되고, 둘 다 추상화에 의존해야 한다.” ⇒   구체적인 구현체에 의존하지 않고, 인터페이스나 추상 클래스를 사용하여 유연한 설계를 가능하게 한다. 의존 객체를 직접 만들지 말고 외부에서 주입 받자 의존성 주입   (DI,   Dependency Injection) ⇒   Spring IOC 컨테이너 GoF의 디자인 패턴 GRASP와 SOLID 원칙에 따르는 설계 비법이 있다. ⇒   21가지의 디자인 패턴 (GoF) 항상 클래스를 만들 때 GRASP 방법론을 염두해 두어야 한다. 이런 유형들을 쉽게 정리해 놓은 것이 디자인 패턴이다. " }, { "title": "Jenkins 사용법 2 (React / Nginx)", "url": "/posts/jenkins-howtouse2/", "categories": "프로젝트, CICD, Jenkins", "tags": "Jenkins, Docker, 배포 자동화", "date": "2024-11-28 22:00:00 +0900", "snippet": "(6) Jenkins를 사용하여 React 자동 배포하기 Dockerfile 생성 # 1. Node.js 기반의 Alpine 이미지를 사용 FROM node:18-alpine # 2. 작업 디렉토리 설정 WORKDIR /app # 3. package.json과 package-lock.json을 먼저 복사 CO...", "content": "(6) Jenkins를 사용하여 React 자동 배포하기 Dockerfile 생성 # 1. Node.js 기반의 Alpine 이미지를 사용 FROM node:18-alpine # 2. 작업 디렉토리 설정 WORKDIR /app # 3. package.json과 package-lock.json을 먼저 복사 COPY package*.json ./ # 4. 의존성 설치 (npm 사용) RUN npm install # 5. 애플리케이션 소스 코드 복사 COPY . . # 6. 포트 설정 EXPOSE 3000 # 7. 앱 실행 (npm start) CMD [\"npm\", \"start\"] Jenkins 설정 docker build -t backtoback/bitcamp-final-front:1.0 . docker login -u backtoback -p 허브비번! docker.iodocker push backtoback/bitcamp-final-front:1.0docker login -u backtoback -p 허브비번! docker.iodocker pull backtoback/bitcamp-final-front:1.0 docker ps -aq --filter name=bitcamp-front-final | grep -q . &amp;&amp; docker rm -f $(docker ps -aq --filter name=bitcamp-front-final) || truedocker run -d --name bitcamp-front-final -p 3000:3000 backtoback/bitcamp-final-front:1.0 docker ps -aq –filter name=bitcamp-front-final grep -q . &amp;&amp; docker rm -f $(docker ps -aq –filter name=bitcamp-front-final)   true   true 컨테이너 제거에 실패할 경우 빌드 실패 방지 Dashboard ⇒ bitcamp-final-front 아이템 클릭 ⇒ 지금 빌드 클릭 빌드 전 상태 [student@bitcamp-svr-final ~]$ sudo docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 58f547cfe445 backtoback/bitcamp-final:1.0 \"java -jar bitcamp-f…\" 8 hours ago Up 8 hours 0.0.0.0:8080-&gt;8080/tcp bitcamp-final 5c1df2794973 bitcamp-final-front:first \"docker-entrypoint.s…\" 12 hours ago Up 12 hours 0.0.0.0:3000-&gt;3000/tcp bitcamp-front-final Jenkins UI의 console output Started by user admin Running as SYSTEM Building in workspace /var/jenkins_home/workspace/bitcamp-final-front The recommended git tool is: NONE using credential 57dd14ae-bac2-4556-87ee-f49e178304ae Cloning the remote Git repository Cloning repository https://github.com/backnback/bitcamp-final-front.git &gt; git init /var/jenkins_home/workspace/bitcamp-final-front # timeout=10 Fetching upstream changes from https://github.com/backnback/bitcamp-final-front.git &gt; git --version # timeout=10 &gt; git --version # 'git version 2.39.5' using GIT_ASKPASS to set credentials &gt; git fetch --tags --force --progress -- https://github.com/backnback/bitcamp-final-front.git +refs/heads/*:refs/remotes/origin/* # timeout=10 &gt; git config remote.origin.url https://github.com/backnback/bitcamp-final-front.git # timeout=10 &gt; git config --add remote.origin.fetch +refs/heads/*:refs/remotes/origin/* # timeout=10 Avoid second fetch &gt; git rev-parse refs/remotes/origin/main^{commit} # timeout=10 Checking out Revision c964ea65d34d9754deda02263d0fbff39fe91565 (refs/remotes/origin/main) &gt; git config core.sparsecheckout # timeout=10 &gt; git checkout -f c964ea65d34d9754deda02263d0fbff39fe91565 # timeout=10 Commit message: \"Merge pull request #42 from backnback/cute-kkiri\" First time build. Skipping changelog. [bitcamp-final-front] $ /bin/sh -xe /tmp/jenkins8977258763446046408.sh + docker build -t backtoback/bitcamp-final-front:1.0 . #0 building with \"default\" instance using docker driver #1 [internal] load build definition from Dockerfile #1 transferring dockerfile: 423B done #1 DONE 0.0s #2 [internal] load metadata for docker.io/library/node:18-alpine #2 ... #3 [auth] library/node:pull token for registry-1.docker.io #3 DONE 0.0s #2 [internal] load metadata for docker.io/library/node:18-alpine #2 DONE 2.7s #4 [internal] load .dockerignore #4 transferring context: 2B done #4 DONE 0.0s #5 [1/5] FROM docker.io/library/node:18-alpine@sha256:7e43a2d633d91e8655a6c0f45d2ed987aa4930f0792f6d9dd3bffc7496e44882 #5 resolve docker.io/library/node:18-alpine@sha256:7e43a2d633d91e8655a6c0f45d2ed987aa4930f0792f6d9dd3bffc7496e44882 0.0s done #5 sha256:7e43a2d633d91e8655a6c0f45d2ed987aa4930f0792f6d9dd3bffc7496e44882 7.67kB / 7.67kB done #5 sha256:7000d2e73f938c4f62fdda6d398d7dffd50e6c129409ae2b1a36ccebf9289ffe 1.72kB / 1.72kB done #5 sha256:870e987bd79332f29e9e21d7fa06ae028cfb507bb8bbca058f6eb60f7111cae9 6.20kB / 6.20kB done #5 sha256:da9db072f522755cbeb85be2b3f84059b70571b229512f1571d9217b77e1087f 0B / 3.62MB 0.1s #5 sha256:aa6f657bab0c137ad8a7930532dbd7c53338023e828890090a4070f47a2ed65d 0B / 40.09MB 0.1s #5 sha256:f477ea663f1c2a017b6f95e743b5ad72f8ff8bf861b0759a86ba1985f706308f 0B / 1.39MB 0.1s #5 ... #6 [internal] load build context #6 transferring context: 37.37MB 0.3s done #6 DONE 0.4s #5 [1/5] FROM docker.io/library/node:18-alpine@sha256:7e43a2d633d91e8655a6c0f45d2ed987aa4930f0792f6d9dd3bffc7496e44882 #5 sha256:da9db072f522755cbeb85be2b3f84059b70571b229512f1571d9217b77e1087f 1.05MB / 3.62MB 0.5s #5 sha256:da9db072f522755cbeb85be2b3f84059b70571b229512f1571d9217b77e1087f 3.62MB / 3.62MB 0.5s done #5 extracting sha256:da9db072f522755cbeb85be2b3f84059b70571b229512f1571d9217b77e1087f #5 sha256:43c47a581c29baa57713ee0da7af754f3994227b64949cb5e9e4dbbc2108c6cd 0B / 449B 0.6s #5 sha256:aa6f657bab0c137ad8a7930532dbd7c53338023e828890090a4070f47a2ed65d 8.39MB / 40.09MB 0.7s #5 extracting sha256:da9db072f522755cbeb85be2b3f84059b70571b229512f1571d9217b77e1087f 0.2s done #5 sha256:aa6f657bab0c137ad8a7930532dbd7c53338023e828890090a4070f47a2ed65d 23.07MB / 40.09MB 0.9s #5 sha256:aa6f657bab0c137ad8a7930532dbd7c53338023e828890090a4070f47a2ed65d 30.41MB / 40.09MB 1.0s #5 sha256:aa6f657bab0c137ad8a7930532dbd7c53338023e828890090a4070f47a2ed65d 37.75MB / 40.09MB 1.1s #5 sha256:f477ea663f1c2a017b6f95e743b5ad72f8ff8bf861b0759a86ba1985f706308f 1.39MB / 1.39MB 1.0s done #5 sha256:43c47a581c29baa57713ee0da7af754f3994227b64949cb5e9e4dbbc2108c6cd 449B / 449B 1.1s done #5 sha256:aa6f657bab0c137ad8a7930532dbd7c53338023e828890090a4070f47a2ed65d 40.09MB / 40.09MB 1.3s done #5 extracting sha256:aa6f657bab0c137ad8a7930532dbd7c53338023e828890090a4070f47a2ed65d 0.1s #5 extracting sha256:aa6f657bab0c137ad8a7930532dbd7c53338023e828890090a4070f47a2ed65d 2.0s done #5 extracting sha256:f477ea663f1c2a017b6f95e743b5ad72f8ff8bf861b0759a86ba1985f706308f 0.1s done #5 extracting sha256:43c47a581c29baa57713ee0da7af754f3994227b64949cb5e9e4dbbc2108c6cd 0.0s done #5 DONE 3.6s #7 [2/5] WORKDIR /app #7 DONE 0.7s #8 [3/5] COPY package*.json ./ #8 DONE 0.0s #9 [4/5] RUN npm install #9 6.899 npm warn deprecated w3c-hr-time@1.0.2: Use your platform's native performance.now() and performance.timeOrigin. #9 7.543 npm warn deprecated stable@0.1.8: Modern JS already guarantees Array#sort() is a stable sort, so this library is deprecated. See the compatibility table on MDN: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#browser_compatibility #9 7.582 npm warn deprecated workbox-cacheable-response@6.6.0: workbox-background-sync@6.6.0 #9 7.585 npm warn deprecated sourcemap-codec@1.4.8: Please use @jridgewell/sourcemap-codec instead #9 7.762 npm warn deprecated rimraf@3.0.2: Rimraf versions prior to v4 are no longer supported #9 7.809 npm warn deprecated workbox-google-analytics@6.6.0: It is not compatible with newer versions of GA starting with v4, as long as you are using GAv3 it should be ok, but the package is not longer being maintained #9 7.829 npm warn deprecated rollup-plugin-terser@7.0.2: This package has been deprecated and is no longer maintained. Please use @rollup/plugin-terser #9 8.209 npm warn deprecated q@1.5.1: You or someone you depend on is using Q, the JavaScript Promise library that gave JavaScript developers strong feelings about promises. They can almost certainly migrate to the native JavaScript promise now. Thank you literally everyone for joining me in this bet against the odds. Be excellent to each other. #9 8.209 npm warn deprecated #9 8.209 npm warn deprecated (For a CapTP with native promises, see @endo/eventual-send and @endo/captp) #9 9.931 npm warn deprecated inflight@1.0.6: This module is not supported, and leaks memory. Do not use it. Check out lru-cache if you want a good and tested way to coalesce async requests by a key value, which is much more comprehensive and powerful. #9 10.19 npm warn deprecated glob@7.2.3: Glob versions prior to v9 are no longer supported #9 10.76 npm warn deprecated domexception@2.0.1: Use your platform's native DOMException instead #9 11.62 npm warn deprecated abab@2.0.6: Use your platform's native atob() and btoa() methods instead #9 14.07 npm warn deprecated @humanwhocodes/config-array@0.13.0: Use @eslint/config-array instead #9 14.09 npm warn deprecated @humanwhocodes/object-schema@2.0.3: Use @eslint/object-schema instead #9 14.10 npm warn deprecated eslint@8.57.1: This version is no longer supported. Please see https://eslint.org/version-support for other options. #9 16.51 npm warn deprecated @babel/plugin-proposal-optional-chaining@7.21.0: This proposal has been merged to the ECMAScript standard and thus this plugin is no longer maintained. Please use @babel/plugin-transform-optional-chaining instead. #9 16.52 npm warn deprecated @babel/plugin-proposal-class-properties@7.18.6: This proposal has been merged to the ECMAScript standard and thus this plugin is no longer maintained. Please use @babel/plugin-transform-class-properties instead. #9 16.52 npm warn deprecated @babel/plugin-proposal-private-methods@7.18.6: This proposal has been merged to the ECMAScript standard and thus this plugin is no longer maintained. Please use @babel/plugin-transform-private-methods instead. #9 16.57 npm warn deprecated @babel/plugin-proposal-nullish-coalescing-operator@7.18.6: This proposal has been merged to the ECMAScript standard and thus this plugin is no longer maintained. Please use @babel/plugin-transform-nullish-coalescing-operator instead. #9 17.07 npm warn deprecated @babel/plugin-proposal-numeric-separator@7.18.6: This proposal has been merged to the ECMAScript standard and thus this plugin is no longer maintained. Please use @babel/plugin-transform-numeric-separator instead. #9 18.60 npm warn deprecated svgo@1.3.2: This SVGO version is no longer supported. Upgrade to v2.x.x. #9 22.63 #9 22.63 added 1616 packages, and audited 1617 packages in 22s #9 22.63 #9 22.63 288 packages are looking for funding #9 22.63 run `npm fund` for details #9 22.65 #9 22.65 10 vulnerabilities (1 low, 2 moderate, 7 high) #9 22.65 #9 22.65 To address issues that do not require attention, run: #9 22.65 npm audit fix #9 22.65 #9 22.65 To address all issues (including breaking changes), run: #9 22.65 npm audit fix --force #9 22.65 #9 22.65 Run `npm audit` for details. #9 22.65 npm notice #9 22.65 npm notice New minor version of npm available! 10.8.2 -&gt; 10.9.1 #9 22.65 npm notice Changelog: https://github.com/npm/cli/releases/tag/v10.9.1 #9 22.65 npm notice To update run: npm install -g npm@10.9.1 #9 22.65 npm notice #9 DONE 23.1s #10 [5/5] COPY . . #10 DONE 0.2s #11 exporting to image #11 exporting layers #11 exporting layers 10.5s done #11 writing image sha256:0199b008dcbb7e7110a8649496b384cc98df48311eb75feb69253ffe9e78e9a6 done #11 naming to docker.io/backtoback/bitcamp-final-front:1.0 done #11 DONE 10.5s + docker login -u backtoback -p 허브비번! docker.io WARNING! Using --password via the CLI is insecure. Use --password-stdin. WARNING! Your password will be stored unencrypted in /var/jenkins_home/.docker/config.json. Configure a credential helper to remove this warning. See https://docs.docker.com/engine/reference/commandline/login/#credential-stores Login Succeeded + docker push backtoback/bitcamp-final-front:1.0 The push refers to repository [docker.io/backtoback/bitcamp-final-front] a065f315c811: Preparing f0f82b32d205: Preparing 1b3d1b2d7fb5: Preparing 091187395501: Preparing aae2f82b308d: Preparing 5003e477a3c5: Preparing 83ada9b02fd6: Preparing 75654b8eeebd: Preparing 5003e477a3c5: Waiting 83ada9b02fd6: Waiting 75654b8eeebd: Waiting aae2f82b308d: Mounted from library/node 091187395501: Pushed 1b3d1b2d7fb5: Pushed 5003e477a3c5: Mounted from library/node 83ada9b02fd6: Mounted from library/node 75654b8eeebd: Mounted from library/node a065f315c811: Pushed f0f82b32d205: Pushed 1.0: digest: sha256:f1f19759f873c79a5488518efcb71f5be8f2dbd651a332e7315f45ed650f7e6f size: 2000 SSH: Connecting from host [a39e02fc8c88] SSH: Connecting with configuration [bitcamp-final-server] ... SSH: EXEC: completed after 21,020 ms SSH: Disconnecting configuration [bitcamp-final-server] ... SSH: Transferred 0 file(s) Finished: SUCCESS 빌드 후 상태 [student@bitcamp-svr-final ~]$ sudo docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES d684ad2e43f6 backtoback/bitcamp-final-front:1.0 \"docker-entrypoint.s…\" 23 seconds ago Up 22 seconds 0.0.0.0:3000-&gt;3000/tcp bitcamp-front-final 58f547cfe445 backtoback/bitcamp-final:1.0 \"java -jar bitcamp-f…\" 8 hours ago Up 8 hours 0.0.0.0:8080-&gt;8080/tcp bitcamp-final 빌드 시 새로운 컨테이너가 자동 생성된 것을 확인할 수 있다. 창을 열리는데 벡엔드 서버로의 요청이 제대로 가지 않는다. ⇒ 기존에는 react app의 .env 파일로 API 요청 URL을 조정해왔다. github에 아마 이것이 잘못된 상태로 가져와서 만들었기 때문에 그런듯하다. # REACT_APP_API_URL.env 파일 # 개발 환경 API URL REACT_APP_API_URL=http://localhost:8080 # 배포 환경 API URL #REACT_APP_API_URL=http://211.188.48.5:8080 #REACT_APP_API_URL=http://211.188.63.97:8080 예상한 대로 github에 localhost:8080으로 설정되어 있다. 이러한 개발 환경을 이렇게 .env 로 관리하는 것은 힘들다. jenkins의 환경 변수 설정 기능이 있다는 데 사용해보고자 한다. .env 파일보다 Jenkins에서 설정된 환경 변수가 더 높은 우선순위를 가진다. process.env에서 환경 변수를 읽을 때, Jenkins가 빌드 시 설정한 환경 변수가 .env 파일 값을 덮어쓴다. Jenkins 환경 변수 적용 방법 Dockerfile 변경 # 1. Node.js 기반의 Alpine 이미지를 사용 FROM node:18-alpine # 2. 작업 디렉토리 설정 WORKDIR /app # 3. 빌드 시점에 사용할 환경 변수 설정 # ARG는 빌드 시점에만 사용할 수 있는 변수입니다. ARG REACT_APP_API_URL # 4. 환경 변수 설정 (컨테이너 내에서 사용) # ENV는 애플리케이션이 실행되는 동안 사용할 수 있는 변수입니다. ENV REACT_APP_API_URL=${REACT_APP_API_URL} # 5. package.json과 package-lock.json을 먼저 복사 COPY package*.json ./ # 6. 의존성 설치 (npm 사용) RUN npm install # 7. 애플리케이션 소스 코드 복사 COPY . . # 8. 포트 설정 EXPOSE 3000 # 9. 앱 실행 (npm start) CMD [\"npm\", \"start\"] 환경변수를 설정하고 사용할 수 있게 설정한다. 현재 도메인을 신청하려고 했으나 React 앱 컨테이너의 접속 포트가 3000:3000으로 포트 포워딩 되어 있다. 그래서 컨테이너 생성 시 80:3000으로 생성했다. ⇒ WebSocket connection to ‘ws://211.188.48.5:3000/ws’ failed: ⇒ 이 오류는 Docker의 포트 매핑을 통해 외부에서 접근할 때는 80 포트로 요청을 받아 내부의 3000 포트로 전달합니다. 그런데 WebSocket 문제는 React 애플리케이션이 사용하는 WebSocket URL이 여전히 ws://211.188.48.5:3000/ws로 고정되어 있다는 점에서 발생. React 앱의 실행 포트(npm start로 설정된 포트)가 이미 3000번으로 고정되어 있기 때문에, 단순히 EXPOSE를 80으로 바꾼다고 해서 컨테이너 내부의 애플리케이션 포트가 변경되지는 않습니다 그래서 Nginx를 사용하여 배포해보기로 결정했다. Nginx는 기본 포트가 80으로 쉽게 설정 가능하고 React 앱을 실제 배포할 때는 Nginx를 많이 쓴다고 했기 때문에 결정했다. Nginx를 사용하면 정적 파일을 제공하는 속도도 빠르고 메모리도 적게 사용한다고 한다. (7) Nginx로 전환하기 기존 Dockerfile # 1. Node.js 기반의 Alpine 이미지를 사용 FROM node:18-alpine # 2. 작업 디렉토리 설정 WORKDIR /app # 3. 빌드 시점에 사용할 환경 변수 설정 # ARG는 빌드 시점에만 사용할 수 있는 변수입니다. ARG REACT_APP_API_URL # 4. 환경 변수 설정 (컨테이너 내에서 사용) # ENV는 애플리케이션이 실행되는 동안 사용할 수 있는 변수입니다. ENV REACT_APP_API_URL=${REACT_APP_API_URL} # 5. package.json과 package-lock.json을 먼저 복사 COPY package*.json ./ # 6. 의존성 설치 (npm 사용) RUN npm install # 7. 애플리케이션 소스 코드 복사 COPY . . # 8. 포트 설정 EXPOSE 3000 # 9. 앱 실행 (npm start) CMD [\"npm\", \"start\"] Dockerfile 수정 및 nginx.conf 파일 생성 Nginx로 전환하려면 Dockerfile을 수정하고 nginx.conf를 생성해야 한다고 한다. 프로젝트의 루트 디렉토리에 nignx.conf와 Dockerfile을 생성한다. Dockerfile # 1. Nginx 기반 이미지 사용 FROM nginx:alpine # 2. 앱 빌드 결과물 디렉토리 생성 WORKDIR /usr/share/nginx/html # 3. 빌드 결과물 복사 # `build` 폴더의 파일을 Nginx가 서빙할 `/usr/share/nginx/html`에 복사 COPY ./build/ . # 4. 기존 Nginx의 기본 설정 파일을 제거 RUN rm /etc/nginx/conf.d/default.conf # 5. Nginx 설정 파일을 복사 (이 후 설명할 nginx.conf 사용) COPY ./nginx.conf /etc/nginx/conf.d/ # 6. Nginx가 기본적으로 사용하는 80번 포트를 오픈 EXPOSE 80 # 7. Nginx 실행 명령 CMD [\"nginx\", \"-g\", \"daemon off;\"] ⇒ Jenkins 빌드 시 오류 발생 ! ⇒ 3번의 COPY ./build/. 에서 build 폴더를 복사해오는데 npm run build를 실행하지 않으므로 해당 폴더 자체가 존재하지 않는다. Dockerfile 수정 후 # 1. Node.js 기반 이미지 사용 FROM node:18-alpine AS build # 2. 앱 디렉토리 생성 WORKDIR /app # 3. 패키지 설치 COPY package*.json ./ RUN npm install # 4. 앱 빌드 COPY . ./ RUN npm run build # 5. Nginx 기반 이미지 사용 FROM nginx:alpine # 6. 앱 빌드 결과물 복사 COPY --from=build /app/build /usr/share/nginx/html # 7. 기존 Nginx 설정 제거 RUN rm /etc/nginx/conf.d/default.conf # 8. Nginx 설정 파일 복사 COPY ./nginx.conf /etc/nginx/conf.d/ # 9. Nginx 포트 오픈 EXPOSE 80 # 10. Nginx 실행 CMD [\"nginx\", \"-g\", \"daemon off;\"] npm run build를 하는 부분을 추가해줘야 한다. 그래야 build 폴더가 생긴다. nginx.conf server_name http://211.188.48.5/; 접속하는 주소 (도메인 설정 시 도메인 이름) location /api 이것을 설정 안 하면 Spring Boot API로 요청을 보낼 수 없다. server { listen 80; # HTTP만 처리 (443번 포트는 사용하지 않음) server_name http://211.188.48.5/; # 실제 도메인 이름 # React 앱을 서빙하는 위치 location / { root /usr/share/nginx/html; # React 앱 빌드 폴더 위치 index index.html; try_files $uri $uri/ /index.html; # SPA (Single Page Application) 설정 } # /api 경로로 시작하는 요청을 Spring Boot 서버로 프록시 location /api { proxy_pass http://211.188.48.5:8080; # Spring Boot API 서버 주소 proxy_set_header Host $host; # 원본 요청의 호스트 헤더를 전달 proxy_set_header X-Real-IP $remote_addr; # 실제 클라이언트 IP 전달 proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # X-Forwarded-For 헤더 전달 proxy_set_header X-Forwarded-Proto $scheme; # 프로토콜 헤더 (http/https) 전달 } } Jenkins 설정 변경 execute shell docker build -t backtoback/bitcamp-final-front:1.0 . docker login -u backtoback -p 허브비번! docker.io docker push backtoback/bitcamp-final-front:1.0 Send files or execute commands over SSH after the build runs Exec command docker login -u backtoback -p 허브비번! docker.io docker pull backtoback/bitcamp-final-front:1.0 docker ps -aq --filter name=bitcamp-front-final | grep -q . &amp;&amp; docker rm -f $(docker ps -aq --filter name=bitcamp-front-final) || true docker run -d --name bitcamp-front-final -p 80:80 backtoback/bitcamp-final-front:1.0 Jenkins 빌드 시작Jenkins 환경 변수 이용하여 서버 URL 처리하기 Dockerfile 수정 # 1. Node.js 기반 이미지 사용 FROM node:18-alpine AS build # 2. 앱 디렉토리 생성 WORKDIR /app # 3. 패키지 설치 COPY package*.json ./ RUN npm install # 4. 앱 빌드 COPY . ./ RUN npm run build # 5. Nginx 기반 이미지 사용 FROM nginx:alpine # 6. 환경 변수 설정 (API URL 및 SERVER_NAME) ARG API_URL ENV API_URL=${API_URL} # 7. 앱 빌드 결과물 복사 COPY --from=build /app/build /usr/share/nginx/html # 8. 기존 Nginx 설정 파일 제거 RUN rm /etc/nginx/conf.d/default.conf # 9. Nginx 설정 파일 템플릿 복사 COPY ./nginx.conf.template /etc/nginx/conf.d/default.conf.template # 10. Nginx 설정 파일을 envsubst로 치환하여 기본 설정 파일로 복사 CMD envsubst '${API_URL}' &lt; /etc/nginx/conf.d/default.conf.template &gt; /etc/nginx/conf.d/default.conf &amp;&amp; nginx -g 'daemon off;' # 11. Nginx 포트 오픈 EXPOSE 80 기존의 niginx.conf 파일 server { listen 80; # HTTP만 처리 (443번 포트는 사용하지 않음) server_name http://211.188.48.5; # 실제 도메인 이름 # React 앱을 서빙하는 위치 location / { root /usr/share/nginx/html; # React 앱 빌드 폴더 위치 index index.html; try_files $uri $uri/ /index.html; # SPA (Single Page Application) 설정 } # /api 경로로 시작하는 요청을 Spring Boot 서버로 프록시 location /api { proxy_pass ${API_URL}; # Spring Boot API 서버 주소 proxy_set_header Host $host; # 원본 요청의 호스트 헤더를 전달 proxy_set_header X-Real-IP $remote_addr; # 실제 클라이언트 IP 전달 proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # X-Forwarded-For 헤더 전달 proxy_set_header X-Forwarded-Proto $scheme; # 프로토콜 헤더 (http/https) 전달 } } Jenkins 환경 변수 적용 방법 Build Steps ⇒ Execute shell docker build --build-arg API_URL=${API_URL} -t backtoback/bitcamp-final-front:1.0 . docker login -u backtoback -p 허브비번!! docker.io docker push backtoback/bitcamp-final-front:1.0 211.188.48.5 확인 http://go.remapber.p-e.kr 확인 서버 Jenkins 서버 젠킨스 컨테이너가 실행되고 있는 서버 Jenkins 서버에서는 GitHub의 레포지토리 변경을 감지하여 (Github Webhook 사용) 빌드를 트리거한다. 즉, GitHub 푸시 이벤트 발생 시 Jenkins는 해당 Repo를 Clone하거나 Pull한다. 프로젝트 서버 React 앱 빌드 및 배포 최신화된 Repo의 Dockerfile과 nginx.conf를 기준으로 컨테이너 빌드를 실행한다. Dockerfile과 nginx.conf를 사용하여 React 앱의 정적 파일을 빌드(npm run build)한 후, 빌드된 정적 파일들을 Nginx로 배포한다. 즉, nginx.conf 파일을 통해 Nginx를 설정하고 React 앱의 정적 파일을 제공한다 Nginx는 Docker 컨테이너로 실행되고, Dockerfile과 nginx.conf 설정에 따라 React 앱을 Nginx 컨테이너에서 서비스하도록 구성된다. 빌드된 이미지는 Docker Hub에 Push된다. Jenkins는 이후SSH 통신을 통해 프로젝트 서버에 접속하고, Docker Hub에서 이미지를 Pull하여, React 앱을 실행하는 Nginx 컨테이너를 80:80 포트로 배포한다. (exec 명령어를 통해 Docker 명령어를 실행) Spring Boot 앱 빌드 및 배포 최신화된 Repo에서 gradle build를 실행하여 jar 파일을 생성한다. 생성된 jar 파일을 포함하는 Docker 이미지를 만들고, 이 이미지를 Docker Hub에 푸시한다. Jenkins는 이후SSH 통신을 통해 프로젝트 서버에 접속하고, Docker Hub에서 이미지를 Pull하여, SpringBoot 앱을 실행하는 컨테이너를 8080:8080 포트로 배포한다. (exec 명령어를 통해 Docker 명령어를 실행) " }, { "title": "Jenkins 사용법", "url": "/posts/jenkins-howtouse/", "categories": "프로젝트, CICD, Jenkins", "tags": "Jenkins, Docker, 배포 자동화", "date": "2024-11-26 11:00:00 +0900", "snippet": "(1) Jenkins 서버 생성 및 Jenkins 네트워크 브릿지 생성Jenkins용 리눅스 서버 생성 console   ⇒   server   ⇒   생성 (기존 콘솔 화면)   ⇒   CentOS-7.8-64, High CPU bitcamp-vpc, bitcamp-vpc-web-subnet 10.0.1...", "content": "(1) Jenkins 서버 생성 및 Jenkins 네트워크 브릿지 생성Jenkins용 리눅스 서버 생성 console   ⇒   server   ⇒   생성 (기존 콘솔 화면)   ⇒   CentOS-7.8-64, High CPU bitcamp-vpc, bitcamp-vpc-web-subnet 10.0.1.0/24 High CPU(vCPU 2개, 4GB, 50GB, g2), 시간 요금제 서버 이름   :   bitcamp-svr-final-jenkins network interface의 ip 입력   :   10.0.1.53   ⇒   새로운 공인 IP 할당 물리 배치 그룹 미사용 / 반납 보호 해제 인증키 이용 새로운 인증키 생성    (이름 예시 : bitcamp0524-95) 네트워크 접근 설정 (ACG) bitcamp-vpc-web-acg 서버 생성 student 일반 사용자 추가 / 비밀번호 설정 / 권한 설정 $ sudo yum update Docker Engine 받기네트워크 브릿지 생성 젠킨스 도커 컨테이너에서 사용할 브릿지 네트워크를 준비한다. # docker network ls   :   네트워크 목록 확인 # docker network create jenkins   :   Jenkins와 컨테이너가 통신할 네트워크 생성 [student@bitcamp-svr-final ~]$ sudo docker network ls [sudo] password for student: NETWORK ID NAME DRIVER SCOPE f5549640db92 bridge bridge local 01ee24acf253 host host local e7496018f6dd none null local [student@bitcamp-svr-final ~]$ sudo docker network create jenkins 9d944f354e333a0f86aa3ef26e5dc4d67ddc23ede8b17460eaec4eb50b5500b6 [student@bitcamp-svr-final ~]$ sudo docker network ls NETWORK ID NAME DRIVER SCOPE f5549640db92 bridge bridge local 01ee24acf253 host host local 9d944f354e33 jenkins bridge local e7496018f6dd none null local (2) Jenkins Docker 컨테이너 생성 및 실행Jenkins Docker 이미지 다운로드 젠킨스 도커 이미지 가져오기 # docker pull jenkins/jenkins:jdk21   :   Jenkins Docker 이미지 다운로드 # docker image ls   :   # docker images와 같은 명령어지만 새로운 명령 구조 [student@bitcamp-svr-final ~]$ sudo docker pull jenkins/jenkins:jdk21 [sudo] password for student: jdk21: Pulling from jenkins/jenkins b2b31b28ee3c: Already exists cf5313b8439f: Pull complete 131ccd8ae6df: Pull complete 98c40a8886f1: Pull complete 9f48c0cbf990: Pull complete 3eba3e0aca54: Pull complete a3d4294ce7e3: Pull complete 0908c948a73e: Pull complete cd72c4b0ee34: Pull complete 9124c27d77a0: Pull complete 3c3b9bf6160a: Pull complete 8fe50c533fb6: Pull complete Digest: sha256:6bda81af6ef786f7d3687a9ca3009ba932a44d1c199086cec2b6b05f0e004aea Status: Downloaded newer image for jenkins/jenkins:jdk21 docker.io/jenkins/jenkins:jdk21 [student@bitcamp-svr-final ~]$ sudo docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE bitcamp-final-front first b8dc875a08da 18 hours ago 510MB jenkins/jenkins jdk21 9ad7ab5685af 6 days ago 485MB backtoback/bitcamp 0.1 d1eb90b730dc 7 days ago 1.35GB bitcamp-final first d1eb90b730dc 7 days ago 1.35GB &lt;none&gt; &lt;none&gt; d959fe30f57d 7 days ago 1.35GB ubuntu latest fec8bfd95b54 5 weeks ago 78.1MB hello-world latest d2c94e258dcb 19 months ago 13.3kB centos 7 eeb6ee3f44bd 3 years ago 204MB ubuntu 14.04 13b66b487594 3 years ago 197MB 도커 이미지 만들기   :   젠킨스   +   JDK21   +   도커 클라이언트 작업 디렉토리 생성 후 install-docker.sh 파일 생성 [student@bitcamp-svr-final ~]$ mkdir jenkins [student@bitcamp-svr-final ~]$ cd jenkins [student@bitcamp-svr-final jenkins]$ vi install-docker.sh install-docker.sh 파일 내용 복사 후 붙여 넣기 #!/bin/sh apt-get update apt-get -y install apt-transport-https \\ apt-utils \\ ca-certificates \\ curl \\ gnupg2 \\ zip \\ unzip \\ acl \\ software-properties-common curl -fsSL https://download.docker.com/linux/$(. /etc/os-release; echo \"$ID\")/gpg &gt; /tmp/dkey; apt-key add /tmp/dkey add-apt-repository \\ \"deb [arch=amd64] https://download.docker.com/linux/$(. /etc/os-release; echo \"$ID\") \\ $(lsb_release -cs) \\ stable\" &amp;&amp; \\ apt-get update apt-get -y install docker-ce 작성 완료 후 ESC 클릭 후 :wq 입력 도커 빌드 파일 생성 [student@bitcamp-svr-final jenkins]$ vi Dockerfile Dockerfile 내용 복사 후 붙여 넣기 FROM jenkins/jenkins:jdk21 USER root COPY install-docker.sh /install-docker.sh RUN chmod +x /install-docker.sh RUN /install-docker.sh RUN usermod -aG docker jenkins RUN setfacl -Rm d:g:docker:rwx,g:docker:rwx /var/run/ USER jenkins 도커 이미지 생성 # docker build -t backtoback/bitcamp:jenkins . [student@bitcamp-svr-final jenkins]$ sudo docker build -t backtoback/bitcamp:jenkins . [sudo] password for student: [+] Building 54.9s (11/11) FINISHED docker:default =&gt; [internal] load build definition from Dockerfile 0.0s =&gt; =&gt; transferring dockerfile: 275B 0.0s =&gt; [internal] load metadata for docker.io/jenkins/jenkins:jdk21 0.0s =&gt; [internal] load .dockerignore 0.0s =&gt; =&gt; transferring context: 2B 0.0s =&gt; [internal] load build context 0.0s =&gt; =&gt; transferring context: 563B 0.0s =&gt; [1/6] FROM docker.io/jenkins/jenkins:jdk21 0.1s =&gt; [2/6] COPY install-docker.sh /install-docker.sh 0.0s =&gt; [3/6] RUN chmod +x /install-docker.sh 0.3s =&gt; [4/6] RUN /install-docker.sh 47.5s =&gt; [5/6] RUN usermod -aG docker jenkins 0.3s =&gt; [6/6] RUN setfacl -Rm d:g:docker:rwx,g:docker:rwx /var/run/ 0.2s =&gt; exporting to image 6.4s =&gt; =&gt; exporting layers 6.4s =&gt; =&gt; writing image sha256:aa2cd2c9ac9a8691ae423ed5721f5d6b0e8f0baabb160 0.0s =&gt; =&gt; naming to docker.io/backtoback/bitcamp:jenkins 도커 이미지를 도커 허브 사이트에 업로드 하기 # docker login   :   입력 후 username과 password를 입력하면 로그인 된다. # docker push backtoback/bitcamp:jenkins   :   로컬의 이미지를 도커 허브에 업로드 [사용자 이름]/[저장소 이름]:[태그] 사용자 이름과 저장소 이름은 도커 허브 사이트에 있는 것을 사용해야 한다. [student@bitcamp-svr-final jenkins]$ sudo docker login [sudo] password for student: Authenticating with existing credentials... WARNING! Your password will be stored unencrypted in /root/.docker/config.json. Configure a credential helper to remove this warning. See https://docs.docker.com/engine/reference/commandline/login/#credentials-store Login Succeeded [student@bitcamp-svr-final jenkins]$ sudo docker push backtoback/bitcamp:jenkins The push refers to repository [docker.io/backtoback/bitcamp] 8e837c36d4f1: Pushed 5f69b67c07c9: Pushed 4851e4b39029: Pushed a48de29c78e8: Pushed b337f6f3395b: Pushed c57854c6754d: Pushed d453c9a3f980: Pushed 200df0fdd6da: Pushed a47fce14f185: Pushed fc0b714bfc86: Pushed e2b50ada3c38: Pushed ad429ebafa13: Pushed 452ea6c210d0: Pushed a65090797361: Pushed c18f5e54294a: Pushed a07cdd6d45d1: Pushed 24b5ce0f1e07: Pushed jenkins: digest: sha256:99425d9ccf948a355476118a7ebef6f38459325ec8d98d3982799010fe1d772e size: 3875 컨테이너 생성 및 실행하기   (DooD 방식) DooD(Docker out of Docker) 방식은 도커 컨테이너 내부에서 호스트 머신의 Docker 데몬(Docker Engine)을 직접 사용하는 방식이다. 컨테이너 내부에서 docker 명령어 실행 시, 실제로 호스트 머신의 Docker 데몬이 작업을 처리한다. # docker run --privileged -d -v /var/run/docker.sock:/var/run/docker.sock -v jenkins_home:/var/jenkins_home -p 8080:8080 -p 50000:50000 --restart=on-failure --network=\"jenkins\" --name docker-jenkins backtoback/bitcamp:jenkins --privileged 컨테이너에 추가적인 권한을 부여   (DooD 방식 관련) -v /var/run/docker.sock:/var/run/docker.sock 호스트의 Docker 데몬 소켓(/var/run/docker.sock)을 컨테이너 내부에 마운트하는 것 컨테이너에서 도커 명령을 실행하면, 호스트의 Docker 데몬과 직접 통신   (DooD 방식) -v jenkins_home:/var/jenkins_home jenkins_home라는 이름의 도커 볼륨을 생성 p 8080:8080 Jenkins의 웹 인터페이스는 기본적으로 컨테이너의 8080 포트에서 실행된다. p 50000:50000 Jenkins에서 노드 간 통신을 위한 포트 --restart=on-failure 컨테이너가 실패로 종료되었을 때 자동으로 재시작   (오류로 종료된 경우에만) --network=\"jenkins\" jenkins라는 이름의 Docker 네트워크를 사용 ⇒ 컨테이너가 같은 네트워크 안에 있는 다른 컨테이너와 통신 가능 --name docker-jenkins backtoback/bitcamp:jenkins backtoback/bitcamp:jenkins 이미지로 docker-jenkins 컨테이너 생성 [student@bitcamp-svr-final jenkins]$ sudo docker run --privileged -d -v /var/run/docker.sock:/var/run/docker.sock -v jenkins_home:/var/jenkins_home -p 8080:8080 -p 50000:50000 --restart=on-failure --network=\"jenkins\" --name docker-jenkins backtoback/bitcamp:jenkins [sudo] password for student: 7665e5d7a3263b4b24d8b4343a6e720400f4cf6b6e70b64a018fc9cb1ba15b11 [student@bitcamp-svr-final jenkins]$ sudo docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESa39e02fc8c88 backtoback/bitcamp:jenkins \"/usr/bin/tini -- /u…\" 5 seconds ago Up 4 seconds 0.0.0.0:8080-&gt;8080/tcp, 0.0.0.0:50000-&gt;50000/tcp docker-jenkins (주의!) 젠킨스 컨테이너를 재생성 할 때, 기존 젠킨스 볼륨을 제거하기 [student@bitcamp-svr-final jenkins]$ sudo docker volume ls DRIVER VOLUME NAME local jenkins_home [student@bitcamp-svr-final jenkins]$ sudo docker rm jenkins_home 젠킨스 설정 젠킨스 잠금을 풀기 위해 관리자 암호 찾아서 넣기 # docker logs docker-jenkins [student@bitcamp-svr-final2 ~]$ sudo docker logs docker-jenkins Running from: /usr/share/jenkins/jenkins.war webroot: /var/jenkins_home/war 2024-11-26 10:42:10.703+0000 [id=1] INFO winstone.Logger#logInternal: Beginning extraction from war file 2024-11-26 10:42:11.752+0000 [id=1] WARNING o.e.j.ee9.nested.ContextHandler#setContextPath: Empty contextPath 2024-11-26 10:42:11.812+0000 [id=1] INFO org.eclipse.jetty.server.Server#doStart: jetty-12.0.14; built: 2024-09-30T14:22:54.197Z; git: e77516598a07cca826d27fa8a4f7c70e953921a6; jvm 21.0.5+11-LTS 2024-11-26 10:42:12.279+0000 [id=1] INFO o.e.j.e.w.StandardDescriptorProcessor#visitServlet: NO JSP Support for /, did not find org.eclipse.jetty.ee9.jsp.JettyJspServlet 2024-11-26 10:42:12.330+0000 [id=1] INFO o.e.j.s.DefaultSessionIdManager#doStart: Session workerName=node0 2024-11-26 10:42:12.810+0000 [id=1] INFO hudson.WebAppMain#contextInitialized: Jenkins home directory: /var/jenkins_home found at: EnvVars.masterEnvVars.get(\"JENKINS_HOME\") 2024-11-26 10:42:13.008+0000 [id=1] INFO o.e.j.s.handler.ContextHandler#doStart: Started oeje9n.ContextHandler$CoreContextHandler@a518813{Jenkins v2.486,/,b=file:///var/jenkins_home/war/,a=AVAILABLE,h=oeje9n.ContextHandler$CoreContextHandler$CoreToNestedHandler@43d38654{STARTED}} 2024-11-26 10:42:13.019+0000 [id=1] INFO o.e.j.server.AbstractConnector#doStart: Started ServerConnector@772861aa{HTTP/1.1, (http/1.1)}{0.0.0.0:8080} 2024-11-26 10:42:13.032+0000 [id=1] INFO org.eclipse.jetty.server.Server#doStart: Started oejs.Server@422c3c7a{STARTING}[12.0.14,sto=0] @3074ms 2024-11-26 10:42:13.033+0000 [id=31] INFO winstone.Logger#logInternal: Winstone Servlet Engine running: controlPort=disabled 2024-11-26 10:42:13.177+0000 [id=30] INFO jenkins.model.Jenkins#&lt;init&gt;: Starting version 2.486 2024-11-26 10:42:13.254+0000 [id=40] INFO jenkins.InitReactorRunner$1#onAttained: Started initialization 2024-11-26 10:42:13.264+0000 [id=39] INFO jenkins.InitReactorRunner$1#onAttained: Listed all plugins 2024-11-26 10:42:14.162+0000 [id=40] INFO jenkins.InitReactorRunner$1#onAttained: Prepared all plugins 2024-11-26 10:42:14.166+0000 [id=40] INFO jenkins.InitReactorRunner$1#onAttained: Started all plugins 2024-11-26 10:42:14.172+0000 [id=38] INFO jenkins.InitReactorRunner$1#onAttained: Augmented all extensions 2024-11-26 10:42:14.377+0000 [id=38] INFO jenkins.InitReactorRunner$1#onAttained: System config loaded 2024-11-26 10:42:14.377+0000 [id=38] INFO jenkins.InitReactorRunner$1#onAttained: System config adapted 2024-11-26 10:42:14.377+0000 [id=38] INFO jenkins.InitReactorRunner$1#onAttained: Loaded all jobs 2024-11-26 10:42:14.381+0000 [id=38] INFO jenkins.InitReactorRunner$1#onAttained: Configuration for all jobs updated 2024-11-26 10:42:14.483+0000 [id=53] INFO hudson.util.Retrier#start: Attempt #1 to do the action check updates server 2024-11-26 10:42:14.869+0000 [id=39] INFO jenkins.install.SetupWizard#init: ************************************************************* ************************************************************* ************************************************************* Jenkins initial setup is required. An admin user has been created and a password generated. Please use the following password to proceed to installation: 0d28216e00574ebcb782a149c57702e7 This may also be found at: /var/jenkins_home/secrets/initialAdminPassword ************************************************************* ************************************************************* ************************************************************* 2024-11-26 10:42:19.842+0000 [id=39] INFO jenkins.InitReactorRunner$1#onAttained: Completed initialization 2024-11-26 10:42:19.902+0000 [id=30] INFO hudson.lifecycle.Lifecycle#onReady: Jenkins is fully up and running 2024-11-26 10:42:21.805+0000 [id=53] INFO h.m.DownloadService$Downloadable#load: Obtained the updated data file for hudson.tasks.Maven.MavenInstaller 2024-11-26 10:42:21.805+0000 [id=53] INFO hudson.util.Retrier#start: Performed the action check updates server successfully at the attempt #1 /var/jenkins_home/secrets/initialAdminPassword 파일에 저장된 암호가 보인다. 젠킨스 플러그인 설치 Jenkins 웹 UI에 접속한다.     (http://서버IP:8080) 포트는 컨테이너 생성 시 지정한 포트이다. 위에서 찾은 관리자 암호를 넣어준다. “Install suggested plugins” 클릭 첫 번째 젠킨스 관리자 등록 계정명: admin 암호: 1111 암호확인: 1111 이름: admin 이메일주소: xxx@xxx.xxx 젠킨스 루트 URL 설정 http://서버IP:8080 자동 입력되어 있다. Start Using Jenkins 클릭 (3) 젠킨스 환경 설정JDK 및 Gradle 설정 Dashboard / Jenkins 관리 System Configuration / Tools JDK Add JDK 클릭 Name: OpenJDK-21 JAVA_HOME: /opt/java/openjdk Apply 클릭 Gradle Add Gradle 클릭 Name: Gradle 8.7 Install automatically: 체크 Version: 8.7 선택 Apply 클릭 Node.js 설정 Dashboard / Jenkins 관리 플러그인 관리 Available plugins 선택 Nodejs 검색 NodeJS 체크 Install without restart 클릭 System Configuration / Global Tool Configuration (= Tools) NodeJS Add NodeJS 클릭 Name: NodeJS 18.16.0 Install automatically: 체크 Version: 18.16.0 선택 Apply 클릭 ****(주의!) jenkins/jenkins:lts-jdk11 을 설치했을 경우 우리는 $ sudo docker pull jenkins/jenkins:jdk21 이것을 설치했다. JDK 17 설치 root 사용자로 젠킨스 컨테이너에 접속하기 호스트# docker exec -itu 0 jenkins-jdk11 bash 컨테이너/# apt-get update 컨테이너/# apt-get install openjdk-17-jdk -y 젠킨스에 JDK 17 경로 등록 Jenkins 관리 Global Tool Configuration JDK Add JDK 클릭 Name: OpenJDK-17 JAVA_HOME: /usr/lib/jvm/java-17-openjdk-amd64 SAVE 클릭 (4) Jenkins에 프로젝트 등록 및 자동 배포하기github.com의 프로젝트 연동 Dashboard   ⇒   새로운 Item Enter an item name   :   bitcamp-final Freestyle project 클릭 OK 클릭 설정 General 설명   :   bitcamp-final 빌드 GitHub project 체크 Project url   :   https://github.com/backnback/bitcamp-final.git General ⇒ 소스 코드 관리 Git 선택 Repository url   :   https://github.com/backnback/bitcamp-final.git Credentials   :   (push를 할 경우) Add 버튼 클릭   :   Add Jenkins 선택 Username with Password 선택 Username   :   깃허브 사용자이름 Password   :   깃허브 토큰 ‘Add’ 클릭 Username/토큰 선택 Branch Specifier   :   */main General ⇒ Triggers   (빌드 유발) GitHub hook trigger for GITScm polling 선택 General ⇒ Environment   (빌드 환경) Provide Node &amp; npm bin/ foler to PATH 체크 NodeJS 18.16.0 선택 General ⇒ Build Steps Invoke Gradle script 선택 Invoke Gradle 선택 Gradle Version   :   Gradle 8.7 선택 Tasks clean build 입력 저장하기 지금 빌드 클릭 Console Output 확인 Started by user admin Running as SYSTEM Building in workspace /var/jenkins_home/workspace/bitcamp-final The recommended git tool is: NONE using credential b278040e-7116-4257-b06e-f8644b4be52c Cloning the remote Git repository Cloning repository https://github.com/backnback/bitcamp-final &gt; git init /var/jenkins_home/workspace/bitcamp-final # timeout=10 Fetching upstream changes from https://github.com/backnback/bitcamp-final &gt; git --version # timeout=10 &gt; git --version # 'git version 2.39.5' using GIT_ASKPASS to set credentials &gt; git fetch --tags --force --progress -- https://github.com/backnback/bitcamp-final +refs/heads/*:refs/remotes/origin/* # timeout=10 &gt; git config remote.origin.url https://github.com/backnback/bitcamp-final # timeout=10 &gt; git config --add remote.origin.fetch +refs/heads/*:refs/remotes/origin/* # timeout=10 Avoid second fetch &gt; git rev-parse refs/remotes/origin/main^{commit} # timeout=10 Checking out Revision 64f00f28f271fee84be00d134599a0d1e00cf84e (refs/remotes/origin/main) &gt; git config core.sparsecheckout # timeout=10 &gt; git checkout -f 64f00f28f271fee84be00d134599a0d1e00cf84e # timeout=10 Commit message: \"Merge pull request #121 from backnback/orbit\" First time build. Skipping changelog. Unpacking https://nodejs.org/dist/v18.16.0/node-v18.16.0-linux-x64.tar.gz to /var/jenkins_home/tools/jenkins.plugins.nodejs.tools.NodeJSInstallation/NodeJS_18.16.0 on Jenkins [Gradle] - Launching build. Unpacking https://services.gradle.org/distributions/gradle-8.7-bin.zip to /var/jenkins_home/tools/hudson.plugins.gradle.GradleInstallation/Gradle_8.7 on Jenkins [bitcamp-final] $ /var/jenkins_home/tools/hudson.plugins.gradle.GradleInstallation/Gradle_8.7/bin/gradle clean build Welcome to Gradle 8.7! Here are the highlights of this release: - Compiling and testing with Java 22 - Cacheable Groovy script compilation - New methods in lazy collection properties For more details see https://docs.gradle.org/8.7/release-notes.html Starting a Gradle Daemon (subsequent builds will be faster) &gt; Task :app:clean UP-TO-DATE &gt; Task :app:compileJava Note: /var/jenkins_home/workspace/bitcamp-final/app/src/main/java/bitcamp/project/service/impl/UserServiceImpl.java uses or overrides a deprecated API. Note: Recompile with -Xlint:deprecation for details. &gt; Task :app:processResources &gt; Task :app:classes &gt; Task :app:bootJarMainClassName &gt; Task :app:bootJar &gt; Task :app:jar SKIPPED &gt; Task :app:assemble &gt; Task :app:compileTestJava &gt; Task :app:processTestResources &gt; Task :app:testClasses &gt; Task :app:test &gt; Task :app:check &gt; Task :app:build BUILD SUCCESSFUL in 2m 16s 8 actionable tasks: 7 executed, 1 up-to-date Build step 'Invoke Gradle script' changed build result to SUCCESS Finished: SUCCESS 리눅스 서버에서 확인 $ sudo docker exec -itu 0 docker-jenkins bash 접속 # cd /var/jenkins_home/workspace/ [student@bitcamp-svr-final jenkins]$ sudo docker exec -itu 0 docker-jenkins bash [sudo] password for student: root@7665e5d7a326:/# root@7665e5d7a326:/# cd /var/jenkins_home/workspace/ root@7665e5d7a326:/var/jenkins_home/workspace# ls bitcamp-final bitcamp-final@tmp github webhook 연동 깃허브 [Repository]     ⇒     Settings     ⇒     Webhooks Add webook 클릭 Payload URL   :   http://젠킨스서버주소:8080/github-webhook/ Content type   :   application/json 저장 스프링부트 애플리케이션 docker 이미지 생성 및 도커 허브에 push 하기 Jenkins의 Dashboard bitcamp-final Freestyle 아이템 선택 구성 탭 선택 Build Steps Add build step   :   Execute shell 클릭 docker build -t [dockerHub UserName]/[dockerHub Repository]:[version] . Dockerfile을 사용하여 backtoback/bitcamp-final이라는 이름의 이미지 빌드 docker login -u '도커허브아이디' -p '도커허브비번' docker.io docker push [dockerHub UserName]/[dockerHub Repository]:[version] docker build -t backtoback/bitcamp-final:1.0 . docker login -u backtoback -p 비밀번호 docker.io docker push backtoback/bitcamp-final:1.0 저장하기 /var/run/docker.sock의 permission denied 발생하는 경우 Started by GitHub push by backnback Running as SYSTEM Building in workspace /var/jenkins_home/workspace/bitcamp-final The recommended git tool is: NONE using credential b278040e-7116-4257-b06e-f8644b4be52c &gt; git rev-parse --resolve-git-dir /var/jenkins_home/workspace/bitcamp-final/.git # timeout=10 Fetching changes from the remote Git repository &gt; git config remote.origin.url https://github.com/backnback/bitcamp-final # timeout=10 Fetching upstream changes from https://github.com/backnback/bitcamp-final &gt; git --version # timeout=10 &gt; git --version # 'git version 2.39.5' using GIT_ASKPASS to set credentials &gt; git fetch --tags --force --progress -- https://github.com/backnback/bitcamp-final +refs/heads/*:refs/remotes/origin/* # timeout=10 &gt; git rev-parse refs/remotes/origin/main^{commit} # timeout=10 Checking out Revision 6f2200860b02e5c58f22c5af171aa2ef53cf30e2 (refs/remotes/origin/main) &gt; git config core.sparsecheckout # timeout=10 &gt; git checkout -f 6f2200860b02e5c58f22c5af171aa2ef53cf30e2 # timeout=10 Commit message: \"Merge pull request #122 from backnback/backnback\" &gt; git rev-list --no-walk 64f00f28f271fee84be00d134599a0d1e00cf84e # timeout=10 [Gradle] - Launching build. [bitcamp-final] $ /var/jenkins_home/tools/hudson.plugins.gradle.GradleInstallation/Gradle_8.7/bin/gradle clean build Starting a Gradle Daemon (subsequent builds will be faster) &gt; Task :app:clean &gt; Task :app:compileJava Note: /var/jenkins_home/workspace/bitcamp-final/app/src/main/java/bitcamp/project/service/impl/UserServiceImpl.java uses or overrides a deprecated API. Note: Recompile with -Xlint:deprecation for details. &gt; Task :app:processResources &gt; Task :app:classes &gt; Task :app:bootJarMainClassName &gt; Task :app:bootJar &gt; Task :app:jar SKIPPED &gt; Task :app:assemble &gt; Task :app:compileTestJava &gt; Task :app:processTestResources &gt; Task :app:testClasses &gt; Task :app:test &gt; Task :app:check &gt; Task :app:build BUILD SUCCESSFUL in 17s 8 actionable tasks: 8 executed Build step 'Invoke Gradle script' changed build result to SUCCESS [bitcamp-final] $ /bin/sh -xe /tmp/jenkins12607953437281659352.sh + docker build -t backtoback/bitcamp-final:1.0 . ERROR: permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Head \"http://%2Fvar%2Frun%2Fdocker.sock/_ping\": dial unix /var/run/docker.sock: connect: permission denied Build step 'Execute shell' marked build as failure Finished: FAILURE git push 후 Jenkins UI에서 보니 /var/run/docker.sock: connect: permission denied가 발생했다. 호스트# chmod 666 /var/run/docker.sock [student@bitcamp-svr-final jenkins]$ sudo chmod 666 /var/run/docker.sock [sudo] password for student: Dockerfile이 없다는 오류 발생 ..... BUILD SUCCESSFUL in 18s 8 actionable tasks: 8 executed Build step 'Invoke Gradle script' changed build result to SUCCESS [bitcamp-final] $ /bin/sh -xe /tmp/jenkins3289070697202538191.sh + docker build -t backtoback/bitcamp-final:1.0 . #0 building with \"default\" instance using docker driver #1 [internal] load build definition from Dockerfile #1 transferring dockerfile: 2B done #1 DONE 0.0s ERROR: failed to solve: failed to read dockerfile: open Dockerfile: no such file or directory Build step 'Execute shell' marked build as failure Finished: FAILURE bitcamp-final의 Dockerfile 만들기 FROM openjdk:21-jdk ARG JAR_FILE=app/build/libs/bitcamp-final.jar COPY ${JAR_FILE} bitcamp-final.jar ENTRYPOINT [ \"java\", \"-jar\", \"bitcamp-final.jar\" ] Git Push 후 Jenkins UI와 Docker Hub를 확인하면 성공한 결과를 볼 수 있다. Started by GitHub push by backnback Running as SYSTEM Building in workspace /var/jenkins_home/workspace/bitcamp-final ... Starting a Gradle Daemon (subsequent builds will be faster) &gt; Task :app:clean &gt; Task :app:compileJava ... BUILD SUCCESSFUL in 17s 8 actionable tasks: 8 executed Build step 'Invoke Gradle script' changed build result to SUCCESS [bitcamp-final] $ /bin/sh -xe /tmp/jenkins6351348835620207006.sh + docker build -t backtoback/bitcamp-final:1.0 . #0 building with \"default\" instance using docker driver #1 [internal] load build definition from Dockerfile #1 transferring dockerfile: 194B done #1 DONE 0.0s #2 [internal] load metadata for docker.io/library/openjdk:21-jdk #2 DONE 2.6s #3 [internal] load .dockerignore #3 transferring context: 2B done #3 DONE 0.0s #4 [1/2] FROM docker.io/library/openjdk:21-jdk@sha256:af9de795d1f8d3b6172f6c55ca9ba1c5768baa11bb2dc8af7045c7db9d4c33ac #4 resolve docker.io/library/openjdk:21-jdk@sha256:af9de795d1f8d3b6172f6c55ca9ba1c5768baa11bb2dc8af7045c7db9d4c33ac 0.0s done #4 sha256:af9de795d1f8d3b6172f6c55ca9ba1c5768baa11bb2dc8af7045c7db9d4c33ac 1.04kB / 1.04kB done #4 sha256:c67f402f77197f2e6ae84ff1fca868699ce3b38bfa78604524051420fa2e4383 954B / 954B done #4 sha256:079114de2be199f2ae0f7766ac0187d24a0c3a2d658fc51bffc6af5b8bd85469 4.42kB / 4.42kB done #4 sha256:5262579e8e45cb87fdc8fb6182d30da3c9e4f1036e02223508f287899ea434c0 0B / 44.96MB 0.2s #4 sha256:0eab4e2287a59db00ae2d401e107a120e21ac3a291b097faffb1af38a1bc773c 0B / 15.03MB 0.2s #4 sha256:7c002e8f606286a649b6f6cc6420c9056f7d3075fe3094b9cc33a715ff609335 0B / 203.93MB 0.2s #4 sha256:5262579e8e45cb87fdc8fb6182d30da3c9e4f1036e02223508f287899ea434c0 10.49MB / 44.96MB 0.5s #4 sha256:5262579e8e45cb87fdc8fb6182d30da3c9e4f1036e02223508f287899ea434c0 16.78MB / 44.96MB 0.6s #4 ... #5 [internal] load build context #5 transferring context: 62.71MB 0.5s done #5 DONE 0.7s #4 [1/2] FROM docker.io/library/openjdk:21-jdk@sha256:af9de795d1f8d3b6172f6c55ca9ba1c5768baa11bb2dc8af7045c7db9d4c33ac #4 sha256:5262579e8e45cb87fdc8fb6182d30da3c9e4f1036e02223508f287899ea434c0 26.21MB / 44.96MB 0.8s #4 sha256:0eab4e2287a59db00ae2d401e107a120e21ac3a291b097faffb1af38a1bc773c 10.49MB / 15.03MB 0.8s #4 sha256:5262579e8e45cb87fdc8fb6182d30da3c9e4f1036e02223508f287899ea434c0 31.46MB / 44.96MB 0.9s #4 sha256:0eab4e2287a59db00ae2d401e107a120e21ac3a291b097faffb1af38a1bc773c 15.03MB / 15.03MB 0.9s #4 sha256:5262579e8e45cb87fdc8fb6182d30da3c9e4f1036e02223508f287899ea434c0 37.75MB / 44.96MB 1.0s #4 sha256:7c002e8f606286a649b6f6cc6420c9056f7d3075fe3094b9cc33a715ff609335 11.53MB / 203.93MB 1.0s #4 sha256:5262579e8e45cb87fdc8fb6182d30da3c9e4f1036e02223508f287899ea434c0 44.96MB / 44.96MB 1.1s done #4 sha256:0eab4e2287a59db00ae2d401e107a120e21ac3a291b097faffb1af38a1bc773c 15.03MB / 15.03MB 1.1s done #4 sha256:7c002e8f606286a649b6f6cc6420c9056f7d3075fe3094b9cc33a715ff609335 22.02MB / 203.93MB 1.2s #4 extracting sha256:5262579e8e45cb87fdc8fb6182d30da3c9e4f1036e02223508f287899ea434c0 0.1s #4 sha256:7c002e8f606286a649b6f6cc6420c9056f7d3075fe3094b9cc33a715ff609335 34.60MB / 203.93MB 1.4s #4 sha256:7c002e8f606286a649b6f6cc6420c9056f7d3075fe3094b9cc33a715ff609335 54.53MB / 203.93MB 1.7s #4 sha256:7c002e8f606286a649b6f6cc6420c9056f7d3075fe3094b9cc33a715ff609335 66.06MB / 203.93MB 1.9s #4 sha256:7c002e8f606286a649b6f6cc6420c9056f7d3075fe3094b9cc33a715ff609335 79.69MB / 203.93MB 2.1s #4 sha256:7c002e8f606286a649b6f6cc6420c9056f7d3075fe3094b9cc33a715ff609335 92.27MB / 203.93MB 2.3s #4 sha256:7c002e8f606286a649b6f6cc6420c9056f7d3075fe3094b9cc33a715ff609335 111.15MB / 203.93MB 2.6s #4 sha256:7c002e8f606286a649b6f6cc6420c9056f7d3075fe3094b9cc33a715ff609335 124.78MB / 203.93MB 2.8s #4 sha256:7c002e8f606286a649b6f6cc6420c9056f7d3075fe3094b9cc33a715ff609335 140.51MB / 203.93MB 3.1s #4 sha256:7c002e8f606286a649b6f6cc6420c9056f7d3075fe3094b9cc33a715ff609335 150.99MB / 203.93MB 3.3s #4 sha256:7c002e8f606286a649b6f6cc6420c9056f7d3075fe3094b9cc33a715ff609335 170.92MB / 203.93MB 3.7s #4 sha256:7c002e8f606286a649b6f6cc6420c9056f7d3075fe3094b9cc33a715ff609335 182.45MB / 203.93MB 3.9s #4 sha256:7c002e8f606286a649b6f6cc6420c9056f7d3075fe3094b9cc33a715ff609335 195.04MB / 203.93MB 4.1s #4 extracting sha256:5262579e8e45cb87fdc8fb6182d30da3c9e4f1036e02223508f287899ea434c0 2.9s done #4 sha256:7c002e8f606286a649b6f6cc6420c9056f7d3075fe3094b9cc33a715ff609335 203.93MB / 203.93MB 4.4s done #4 extracting sha256:0eab4e2287a59db00ae2d401e107a120e21ac3a291b097faffb1af38a1bc773c 0.1s #4 extracting sha256:0eab4e2287a59db00ae2d401e107a120e21ac3a291b097faffb1af38a1bc773c 0.6s done #4 extracting sha256:7c002e8f606286a649b6f6cc6420c9056f7d3075fe3094b9cc33a715ff609335 0.1s #4 extracting sha256:7c002e8f606286a649b6f6cc6420c9056f7d3075fe3094b9cc33a715ff609335 4.9s done #4 DONE 10.2s #6 [2/2] COPY app/build/libs/bitcamp-final.jar bitcamp-final.jar #6 DONE 1.1s #7 exporting to image #7 exporting layers #7 exporting layers 0.3s done #7 writing image sha256:ff5b7389237cc2b023712d537cd30de204534ffee8bfe8d3470607c544a551fc 0.0s done #7 naming to docker.io/backtoback/bitcamp-final:1.0 done #7 DONE 0.4s + docker login -u backtoback -p dlrkfka8796!! docker.io WARNING! Using --password via the CLI is insecure. Use --password-stdin. WARNING! Your password will be stored unencrypted in /var/jenkins_home/.docker/config.json. Configure a credential helper to remove this warning. See https://docs.docker.com/engine/reference/commandline/login/#credential-stores Login Succeeded + docker push backtoback/bitcamp-final:1.0 The push refers to repository [docker.io/backtoback/bitcamp-final] 0fcc4731f586: Preparing 10359c5dc4ba: Preparing 601b48657e0c: Preparing b42107e74152: Preparing 601b48657e0c: Mounted from library/openjdk 10359c5dc4ba: Mounted from library/openjdk b42107e74152: Mounted from library/openjdk 0fcc4731f586: Pushed 1.0: digest: sha256:fd2ab8a6624a4adfc8fe411d953eb6ab4d70116358fa5f635a265ff890aa2a83 size: 1166 Finished: SUCCESS (5) 스프링부트 애플리케이션 컨테이너 실행하기작업 디렉토리 만들기 작업 디렉토리 만들기 root@bitcamp-jenkins:~# mkdir springboot root@bitcamp-jenkins:~# cd springboot root@bitcamp-jenkins:~/springboot# [student@bitcamp-svr-final ~]$ mkdir springboot [student@bitcamp-svr-final ~]$ cd springboot [student@bitcamp-svr-final springboot]$ ssh key 생성 docker-jenkins 도커 컨테이너에서 실행 root@bitcamp-jenkins:~/springboot# docker exec -itu 0 docker-jenkins bash [student@bitcamp-svr-final springboot]$ sudo docker exec -itu 0 docker-jenkins bash [sudo] password for student: root@7665e5d7a326:/# root@젠킨스컨테이너:/# ssh-keygen -t rsa -C \"docker-jenkins-key\" -m PEM -P \"\" -f /root/.ssh/docker-jenkins-key root@7665e5d7a326:/# ssh-keygen -t rsa -C \"docker-jenkins-key\" -m PEM -P \"\" -f /root/.ssh/docker-jenkins-key Generating public/private rsa key pair. Your identification has been saved in /root/.ssh/docker-jenkins-key Your public key has been saved in /root/.ssh/docker-jenkins-key.pub The key fingerprint is: SHA256:5hFiRhI1t3tJv39++4fq6oXmNN6p9jxw2q3htvZCUEA docker-jenkins-key The key's randomart image is: +---[RSA 3072]----+ | oo+ ..E. | | o o . . | | + o .. | | o . +.o | | S o.. | | o o..o. | | . =*+. . | | =o**+o +| | o*B@Bo+B| +----[SHA256]-----+ root@젠킨스컨테이너:/# ls ~/.ssh/ 결과   :   docker-jenkins-key docker-jenkins-key.pub root@7665e5d7a326:/# ls ~/.ssh/ docker-jenkins-key docker-jenkins-key.pub root@젠킨스컨테이너:/# cat ~/.ssh/docker-jenkins-key 개인키 내용 출력 root@7665e5d7a326:/# cat ~/.ssh/docker-jenkins-key -----BEGIN RSA PRIVATE KEY----- MIIG4wIBAAKCAYEA1o4NZmOLHINy+vV7UzPmbDoCZ5jhH+xCXEGNHQ0u9P6eH/XO ....... Vu15mf6dOrxaMhe2ix1XaGhFJecHjiUMoXeGtQj/GrRxzkrpuPOv -----END RSA PRIVATE KEY----- root@젠킨스컨테이너:/# cat ~/.ssh/docker-jenkins-key.pub 공개키 내용 출력 root@7665e5d7a326:/# cat ~/.ssh/docker-jenkins-key.pub ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDWjg1mY4scg3L69XtTM+ZsOg ...... rITFA8= docker-jenkins-key SSH-KEY 개인키 파일을 젠킨스 홈 폴더에 두기 root@젠킨스컨테이너:/# cp ~/.ssh/docker-jenkins-key /var/jenkins_home/ Jenkins에서 SSH 키를 사용 가능하게 하는것 root@젠킨스컨테이너:/# chmod +r /var/jenkins_home/docker-jenkins-key 파일 읽기 권한 추가 root@7665e5d7a326:/# cp ~/.ssh/docker-jenkins-key /var/jenkins_home/ root@7665e5d7a326:/# chmod +r /var/jenkins_home/docker-jenkins-key root@a39e02fc8c88:/# chmod 600 /var/jenkins_home/docker-jenkins-key root@a39e02fc8c88:/# ls -l /var/jenkins_home/docker-jenkins-key -rw------- 1 root root 2455 Nov 27 00:42 /var/jenkins_home/docker-jenkins-key root@a39e02fc8c88:/# ssh -i /var/jenkins_home/docker-jenkins-key student@211.188.48.5 [student@bitcamp-svr-final ~]$ docker-jenkins 컨테이너의 SSH-KEY 공개키 파일을 Host로 복사해오기 root@bitcamp-jenkins:~/springboot# docker cp docker-jenkins:/root/.ssh/docker-jenkins-key.pub ./docker-jenkins-key.pub Docker 컨테이너에서 파일을 호스트 시스템으로 복사하는 명령어 root@bitcamp-jenkins:~/springboot# cat docker-jenkins-key.pub 공개키 내용 출력 root@a39e02fc8c88:/# read escape sequence [student@bitcamp-svr-final2 ~]$ sudo docker cp docker-jenkins:/root/.ssh/docker-jenkins-key.pub ./docker-jenkins-key.pub [sudo] password for student: Successfully copied 2.56kB to /home/student/docker-jenkins-key.pub [student@bitcamp-svr-final2 ~]$ cat docker-jenkins-key.pub ssh-rsa AAAAB3NzaC1y .... IDIRrkOrNAm/QL/oLWU= docker-jenkins-key 공개키를 복사한다. 스프링부트 서버에 SSH-KEY 공개키 등록하기 bitcamp-final 서버로 이동 일반사용자@bitcamp-springboot:~$ sudo -i Root 권한으로 전환 root@bitcamp-springboot:~# mkdir .ssh root@bitcamp-springboot:~# cd .ssh root@bitcamp-springboot:~/.ssh# vi authorized_keys Jenkins 컨테이너의 공개키 **복사하여 붙여 넣기 [student@bitcamp-svr-final ~]$ sudo -i [root@bitcamp-svr-final ~]# mkdir .ssh [root@bitcamp-svr-final ~]# cd .ssh [root@bitcamp-svr-final .ssh]# vi authorized_keys Jenkins에 Publish Over SSH 플러그인 설정 플러그인 설치 Jenkins UI   ⇒   Dashboard   ⇒   Jenkins 관리 plugins Available plugins 탭 Publish Over SSH 플러그인 설치 플러그인 연동 Jenkins UI   ⇒   Dashboard   ⇒   Jenkins 관리 System(시스템 설정) Publish over SSH Passphrase   :   접속하려는 컨테이너의 root 암호   &lt;===   암호로 접속할 때 (SSH 키에 암호가 설정된 경우에만 입력   ⇒   없으면 비워두기 ) Path to key   :   docker-jenkins-key   &lt;===   SSH-KEY로 접속할 때 (private key 파일 경로, JENKINS_HOME 기준) 절대 경로로 /var/jenkins_home/docker-jenkins-key Key   :   개인키 파일의 내용   &lt;===   SSH-KEY 개인키 파일의 내용을 직접 입력할 때 추가 버튼 클릭 SSH Servers Name   :   임의의 서버 이름     (원하는 이름 기입) Hostname   :   스프링부트서버의 IP 주소 (bitcamp-final 서버 IP) Username   :   사용자 아이디     (서버의 일반 사용자 이름) 고급 버튼 클릭 Passphrase / Password   :   student의 비밀번호 Test Configuration 버튼 클릭 Success OK! Jenkins 서버에서 스프링부트 서버를 제어하여 스프링부트 컨테이너 실행하기 bitcamp-final 서버에서 docker pull 및 run Jenkins UI   ⇒   Dashboard   ⇒   bitcamp-final Freestyle 아이템 선택 구성 탭 선택   ⇒   Environment   (빌드 환경) Send files or execute commands over SSH after the build runs 선택 Transfers Exec command docker login -u '도커허브아아디' -p '도커허브비번' docker.io 도커 허브에 로그인 docker pull [dockerHub UserName]/[dockerHub Repository]:[version] 도커 허브에서 이미지 가져오기 docker ps -aq --filter name=[containerName] | grep -q . &amp;&amp; docker rm -f $(docker ps -aq --filter name=[containerName]) 기존에 존재하는 컨테이너 삭제     (“bitcamp-final이 들어가는 것”) docker run -d --name [containerName] -p 80:80 -v /root/config:/root/config [dockerHub UserName]/[dockerHub Repository]:[version] 새로운 컨테이너 생성하여 백그라운드로 실행하기 -v /root/config:/root/config   :   서버의 파일을 컨테이너의 특정 위치에 복사하는 것 docker login -u backtoback -p 도커허브비번 docker.io docker pull backtoback/bitcamp-final:1.0 docker ps -aq --filter name=bitcamp-final | grep -q . &amp;&amp; docker rm -f $(docker ps -aq --filter name=bitcamp-final) docker run -d --name bitcamp-final -p 8080:8080 -v /root/config:/root/config backtoback/bitcamp-final:1.0 현재 상태에서 Git push를 하면 도커 허브에 이미지가 생성되고 bitcamp-final용 서버에 컨테이너가 생성된다. . ____ _ __ _ _ /\\\\ / ___'_ __ _ _(_)_ __ __ _ \\ \\ \\ \\ ( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.7.18) 2024-11-27 04:10:28.575 INFO 1 --- [ main] bitcamp.project.App : Starting App using Java 21 on 2946f50c33ac with PID 1 (/bitcamp-final.jar started by root in /) 2024-11-27 04:10:28.578 DEBUG 1 --- [ main] bitcamp.project.App : Running with Spring Boot v2.7.18, Spring v5.3.31 2024-11-27 04:10:28.579 INFO 1 --- [ main] bitcamp.project.App : No active profile set, falling back to 1 default profile: \"default\" 2024-11-27 04:10:28.905 ERROR 1 --- [ main] o.s.boot.SpringApplication : Application run failed org.springframework.beans.factory.BeanDefinitionStoreException: Failed to parse configuration class [bitcamp.project.App]; nested exception is java.io.FileNotFoundException: /root/config/final.properties (No such file or directory) at org.springframework.context.annotation.ConfigurationClassParser.parse(ConfigurationClassParser.java:188) ~[spring-context-5.3.31.jar!/:5.3.31] at org.springframework.context.annotation.ConfigurationClassPostProcessor.processConfigBeanDefinitions(ConfigurationClassPostProcessor.java:331) ~[spring-context-5.3.31.jar!/:5.3.31] at org.springframework.context.annotation.ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry(ConfigurationClassPostProcessor.java:247) ~[spring-context-5.3.31.jar!/:5.3.31] at org.springframework.context.support.PostProcessorRegistrationDelegate.invokeBeanDefinitionRegistryPostProcessors(PostProcessorRegistrationDelegate.java:311) ~[spring-context-5.3.31.jar!/:5.3.31] at org.springframework.context.support.PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(PostProcessorRegistrationDelegate.java:112) ~[spring-context-5.3.31.jar!/:5.3.31] at org.springframework.context.support.AbstractApplicationContext.invokeBeanFactoryPostProcessors(AbstractApplicationContext.java:756) ~[spring-context-5.3.31.jar!/:5.3.31] at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:572) ~[spring-context-5.3.31.jar!/:5.3.31] at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:147) ~[spring-boot-2.7.18.jar!/:2.7.18] at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:732) ~[spring-boot-2.7.18.jar!/:2.7.18] at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:409) ~[spring-boot-2.7.18.jar!/:2.7.18] at org.springframework.boot.SpringApplication.run(SpringApplication.java:308) ~[spring-boot-2.7.18.jar!/:2.7.18] at org.springframework.boot.SpringApplication.run(SpringApplication.java:1300) ~[spring-boot-2.7.18.jar!/:2.7.18] at org.springframework.boot.SpringApplication.run(SpringApplication.java:1289) ~[spring-boot-2.7.18.jar!/:2.7.18] at bitcamp.project.App.main(App.java:34) ~[classes!/:na] at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103) ~[na:na] at java.base/java.lang.reflect.Method.invoke(Method.java:580) ~[na:na] at org.springframework.boot.loader.MainMethodRunner.run(MainMethodRunner.java:49) ~[bitcamp-final.jar:na] at org.springframework.boot.loader.Launcher.launch(Launcher.java:108) ~[bitcamp-final.jar:na] at org.springframework.boot.loader.Launcher.launch(Launcher.java:58) ~[bitcamp-final.jar:na] at org.springframework.boot.loader.JarLauncher.main(JarLauncher.java:65) ~[bitcamp-final.jar:na] Caused by: java.io.FileNotFoundException: /root/config/final.properties (No such file or directory) at java.base/java.io.FileInputStream.open0(Native Method) ~[na:na] at java.base/java.io.FileInputStream.open(FileInputStream.java:213) ~[na:na] at java.base/java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:152) ~[na:na] at java.base/java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:106) ~[na:na] at java.base/sun.net.www.protocol.file.FileURLConnection.connect(FileURLConnection.java:84) ~[na:na] at java.base/sun.net.www.protocol.file.FileURLConnection.getInputStream(FileURLConnection.java:180) ~[na:na] at org.springframework.core.io.UrlResource.getInputStream(UrlResource.java:187) ~[spring-core-5.3.31.jar!/:5.3.31] at org.springframework.core.io.support.EncodedResource.getInputStream(EncodedResource.java:159) ~[spring-core-5.3.31.jar!/:5.3.31] at org.springframework.core.io.support.PropertiesLoaderUtils.fillProperties(PropertiesLoaderUtils.java:110) ~[spring-core-5.3.31.jar!/:5.3.31] at org.springframework.core.io.support.PropertiesLoaderUtils.fillProperties(PropertiesLoaderUtils.java:81) ~[spring-core-5.3.31.jar!/:5.3.31] at org.springframework.core.io.support.PropertiesLoaderUtils.loadProperties(PropertiesLoaderUtils.java:67) ~[spring-core-5.3.31.jar!/:5.3.31] at org.springframework.core.io.support.ResourcePropertySource.&lt;init&gt;(ResourcePropertySource.java:67) ~[spring-core-5.3.31.jar!/:5.3.31] at org.springframework.core.io.support.DefaultPropertySourceFactory.createPropertySource(DefaultPropertySourceFactory.java:37) ~[spring-core-5.3.31.jar!/:5.3.31] at org.springframework.context.annotation.ConfigurationClassParser.processPropertySource(ConfigurationClassParser.java:465) ~[spring-context-5.3.31.jar!/:5.3.31] at org.springframework.context.annotation.ConfigurationClassParser.doProcessConfigurationClass(ConfigurationClassParser.java:279) ~[spring-context-5.3.31.jar!/:5.3.31] at org.springframework.context.annotation.ConfigurationClassParser.processConfigurationClass(ConfigurationClassParser.java:249) ~[spring-context-5.3.31.jar!/:5.3.31] at org.springframework.context.annotation.ConfigurationClassParser.parse(ConfigurationClassParser.java:206) ~[spring-context-5.3.31.jar!/:5.3.31] at org.springframework.context.annotation.ConfigurationClassParser.parse(ConfigurationClassParser.java:174) ~[spring-context-5.3.31.jar!/:5.3.31] ... 19 common frames omitted 하지만 오류가 발생하여 컨테이너가 실행되고 바로 종료된다. final.properties 파일 등이 없어서 그렇다. .properties, .env 파일 설정 final.properties, email.propertis, .env 넣어주기 도커 컨네이너가 올라가는 서버(bitcamp-final용 서버)에 파일을 만들어준다. nano final.properties nano email.properties nano .env [student@bitcamp-svr-final ~]$ pwd /home/student [student@bitcamp-svr-final ~]$ ls config git ncp-iam-authenticator springboot [student@bitcamp-svr-final ~]$ cd config [student@bitcamp-svr-final config]$ ls email.properties final.properties [student@bitcamp-svr-final config]$ cd .. [student@bitcamp-svr-final ~]$ nano .env [student@bitcamp-svr-final ~]$ ls -a . .bash_history .bash_profile .cache .config .env .gradle .pki .viminfo .. .bash_logout .bashrc config .docker git ncp-iam-authenticator springboot 즉, /home/student/config에 final.properties, email.propertis을 만들고 /home/student/config에 .env를 만들었다. (다르게 만들어도 상관없다. 나중에 위치만 잘 지정해주면 된다) Jenkins로 컨네이너를 생성하고 실행할 때 설정 파일들을 지정하기 Jenkins UI   ⇒   Dashboard   ⇒   bitcamp-final Freestyle 아이템 선택 구성 탭 선택   ⇒   Environment   (빌드 환경) Send files or execute commands over SSH after the build runs 선택 Transfers Exec command 수정 전 docker run -d --name bitcamp-final -p 8080:8080 -v /root/config:/root/config backtoback/bitcamp-final:1.0 수정 후 docker run -d --name bitcamp-final -p 8080:8080 -v /home/student/.env:/.env -v /home/student/config/final.properties:/root/config/final.properties -v /home/student/config/email.properties:/root/config/email.properties backtoback/bitcamp-final:1.0 Jenkins 자동 배포 완료 [student@bitcamp-svr-final ~]$ sudo docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 58f547cfe445 backtoback/bitcamp-final:1.0 \"java -jar bitcamp-f…\" 19 seconds ago Up 19 seconds 0.0.0.0:8080-&gt;8080/tcp bitcamp-final 5c1df2794973 bitcamp-final-front:first \"docker-entrypoint.s…\" 3 hours ago Up 3 hours 0.0.0.0:3000-&gt;3000/tcp bitcamp-front-final 브라우저에서 서버 공인 IP:3000에 접속하면 된다. " }, { "title": "bitcamp-final 프로젝트 배포하기 3", "url": "/posts/final-deploy-3/", "categories": "프로젝트, CICD, Docker", "tags": "Docker, NCP, React, Server", "date": "2024-11-25 19:08:00 +0900", "snippet": "(11) bitcamp-final-front 프로젝트 컨테이너 만들기Dokcerfile 생성 프로젝트 Root 디렉토리에 Dockerfile 생성하기 # 1. Node.js 기반의 Alpine 이미지를 사용 FROM node:18-alpine # 2. 작업 디렉토리 설정 WORKDIR /app # 3. pack...", "content": "(11) bitcamp-final-front 프로젝트 컨테이너 만들기Dokcerfile 생성 프로젝트 Root 디렉토리에 Dockerfile 생성하기 # 1. Node.js 기반의 Alpine 이미지를 사용 FROM node:18-alpine # 2. 작업 디렉토리 설정 WORKDIR /app # 3. package.json과 package-lock.json을 먼저 복사 COPY package*.json ./ # 4. 의존성 설치 (npm 사용) RUN npm install # 5. 애플리케이션 소스 코드 복사 COPY . . # 6. 포트 설정 EXPOSE 3000 # 7. 앱 실행 (npm start) CMD [\"npm\", \"start\"] Git push 하여 업데이트 해준다. 리눅스 서버에서 bitcamp-final-front(프로젝트 Repo.)를 clone해준다. [student@bitcamp-svr-final ~]$ cd git [student@bitcamp-svr-final git]$ ls bitcamp-final [student@bitcamp-svr-final git]$ git clone https://github.com/backnback/bitcamp-final-front Cloning into 'bitcamp-final-front'... remote: Enumerating objects: 2137, done. remote: Counting objects: 100% (24/24), done. remote: Compressing objects: 100% (23/23), done. remote: Total 2137 (delta 1), reused 6 (delta 1), pack-reused 2113 (from 1) Receiving objects: 100% (2137/2137), 14.82 MiB | 15.65 MiB/s, done. Resolving deltas: 100% (1501/1501), done. Docker 이미지 빌드 bitcamp-final-front의 루트 디렉토리로 이동하고 Dockerfile을 이용하여 이미지를 빌드한다. sudo docker build -t bitcamp-final-front:first . -t [이미지이름]:[태그] : 태그(tag) 지정 옵션 . : 현재 디렉토리 (Dockerfile을 찾는 위치) [student@bitcamp-svr-final git]$ cd bitcamp-final-front [student@bitcamp-svr-final bitcamp-final-front]$ sudo docker build -t bitcamp-final-front:first . [+] Building 37.8s (11/11) FINISHED docker:default =&gt; [internal] load build definition from Dockerfile 0.0s =&gt; =&gt; transferring dockerfile: 423B 0.0s =&gt; [internal] load metadata for docker.io/library/node:18-alpine 2.4s =&gt; [auth] library/node:pull token for registry-1.docker.io 0.0s =&gt; [internal] load .dockerignore 0.0s =&gt; =&gt; transferring context: 2B 0.0s =&gt; [1/5] FROM docker.io/library/node:18-alpine@sha256:7e43a2d633d91e8655a6c0f45d2ed987aa4930f0792f6d9dd3bff 3.4s =&gt; =&gt; resolve docker.io/library/node:18-alpine@sha256:7e43a2d633d91e8655a6c0f45d2ed987aa4930f0792f6d9dd3bff 0.0s =&gt; =&gt; sha256:7000d2e73f938c4f62fdda6d398d7dffd50e6c129409ae2b1a36ccebf9289ffe 1.72kB / 1.72kB 0.0s =&gt; =&gt; sha256:870e987bd79332f29e9e21d7fa06ae028cfb507bb8bbca058f6eb60f7111cae9 6.20kB / 6.20kB 0.0s =&gt; =&gt; sha256:aa6f657bab0c137ad8a7930532dbd7c53338023e828890090a4070f47a2ed65d 40.09MB / 40.09MB 1.0s =&gt; =&gt; sha256:f477ea663f1c2a017b6f95e743b5ad72f8ff8bf861b0759a86ba1985f706308f 1.39MB / 1.39MB 0.7s =&gt; =&gt; sha256:43c47a581c29baa57713ee0da7af754f3994227b64949cb5e9e4dbbc2108c6cd 449B / 449B 0.9s =&gt; =&gt; sha256:7e43a2d633d91e8655a6c0f45d2ed987aa4930f0792f6d9dd3bffc7496e44882 7.67kB / 7.67kB 0.0s =&gt; =&gt; extracting sha256:aa6f657bab0c137ad8a7930532dbd7c53338023e828890090a4070f47a2ed65d 2.1s =&gt; =&gt; extracting sha256:f477ea663f1c2a017b6f95e743b5ad72f8ff8bf861b0759a86ba1985f706308f 0.1s =&gt; =&gt; extracting sha256:43c47a581c29baa57713ee0da7af754f3994227b64949cb5e9e4dbbc2108c6cd 0.0s =&gt; [internal] load build context 0.0s =&gt; =&gt; transferring context: 37.40kB 0.0s =&gt; [2/5] WORKDIR /app 0.5s =&gt; [3/5] COPY package*.json ./ 0.1s =&gt; [4/5] RUN npm install 25.5s =&gt; [5/5] COPY . . 0.2s =&gt; exporting to image 5.6s =&gt; =&gt; exporting layers ....... 이미지 빌드 확인 $ sudo docker images [student@bitcamp-svr-final bitcamp-final-front]$ sudo docker images REPOSITORY TAG IMAGE ID CREATED SIZE bitcamp-final-front first b8dc875a08da 12 seconds ago 510MB backtoback/bitcamp 0.1 d1eb90b730dc 7 days ago 1.35GB bitcamp-final first d1eb90b730dc 7 days ago 1.35GB &lt;none&gt; &lt;none&gt; d959fe30f57d 7 days ago 1.35GB ubuntu latest fec8bfd95b54 5 weeks ago 78.1MB hello-world latest d2c94e258dcb 19 months ago 13.3kB centos 7 eeb6ee3f44bd 3 years ago 204MB ubuntu 14.04 13b66b487594 3 years ago 197MB bitcamp-final-front 이미지가 존재하는 것을 확인할 수 있다. 컨테이너 실행하기 sudo docker run -d -p 3000:3000 --name bitcamp-final-front bitcamp-final-front:first -d : 백그라운드로 실행하는 것이다. [student@bitcamp-svr-final bitcamp-final-front]$ sudo docker run -d -p 3000:3000 --name bitcamp-final-front bitcamp-final-front:first e51e35b65c899ad8f23ba69bb2fd5069d267264b1125f9635bb6130ca2c2c0af [student@bitcamp-svr-final bitcamp-final-front]$ sudo docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES e51e35b65c89 bitcamp-final-front:first \"docker-entrypoint.s…\" 18 seconds ago Up 17 seconds 0.0.0.0:3000-&gt;3000/tcp bitcamp-final-front 506a7a2a9ecb bitcamp-final:first \"/bin/bash\" 6 days ago Up 50 minutes 0.0.0.0:8080-&gt;8080/tcp bitcamp-final http://211.188.48.5:3000 으로 접속하면 첫 화면이 보인다. 접속 후 벡엔드와 연결이 되지 않는다면 [WebConfig.java] package bitcamp.project; import org.apache.ibatis.session.SqlSessionFactory; import org.mybatis.spring.SqlSessionFactoryBean; import org.mybatis.spring.annotation.MapperScan; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.core.io.support.PathMatchingResourcePatternResolver; import org.springframework.web.servlet.config.annotation.CorsRegistry; import org.springframework.web.servlet.config.annotation.WebMvcConfigurer; import javax.sql.DataSource; @Configuration public class WebConfig implements WebMvcConfigurer { @Override public void addCorsMappings(CorsRegistry registry) { registry.addMapping(\"/**\") .allowedOrigins(\"http://211.188.48.5:3000\", \"http://localhost:3000\") // 리액트 앱이 실행되는 주소 .allowedMethods(\"GET\", \"POST\", \"PUT\", \"DELETE\") .allowedHeaders(\"Authorization\", \"Content-Type\") .allowCredentials(true); } } allowedOrigins 설정이 올바르게 되어 있는지 확인한다. 위에서 설정한 것처럼 http://211.188.48.5:3000을 허용해줘야 벡엔드와 프론트엔드가 연결될 수 있다. 설정했다면 꼭 다시 git pull로 최신 상태로 업데이트하고 반드시 build 후 실행해야 한다. % 참고 % Nginx를 사용하여 배포하기 # 1. Node.js 기반의 이미지를 사용 FROM node:18 AS build # 2. 작업 디렉토리 설정 WORKDIR /app # 3. package.json과 package-lock.json을 먼저 복사 COPY package*.json ./ # 4. 의존성 설치 RUN npm install # 5. 애플리케이션 빌드 COPY . . RUN npm run build # 6. Nginx 이미지로 애플리케이션을 서빙 FROM nginx:alpine # 7. 빌드된 파일을 Nginx의 기본 웹 서버 디렉토리로 복사 COPY --from=build /app/build /usr/share/nginx/html # 8. Nginx 서버를 실행할 포트 지정 EXPOSE 80 # 9. Nginx 실행 CMD [\"nginx\", \"-g\", \"daemon off;\"] " }, { "title": "DML", "url": "/posts/mysql-dml/", "categories": "코딩 지식, MySQL, SQL", "tags": "MySQL, DML, 문법", "date": "2024-11-25 13:04:00 +0900", "snippet": "DML eomcs-docs → sql 폴더 → exam02 # DML(Data Manipulation Language) 데이터 등록, 변경, 삭제를 다루는 SQL 문법 ## insert - 데이터를 입력할 때 사용하는 문법이다. /* 연락처 테이블 생성 */ create table test1 ( ...", "content": "DML eomcs-docs → sql 폴더 → exam02 # DML(Data Manipulation Language) 데이터 등록, 변경, 삭제를 다루는 SQL 문법 ## insert - 데이터를 입력할 때 사용하는 문법이다. /* 연락처 테이블 생성 */ create table test1 ( no int not null, name varchar(20) not null, tel varchar(20) not null, fax varchar(20), pstno varchar(5), addr varchar(200) ); /* PK 컬럼 지정 */ alter table test1 add constraint test1_pk primary key (no); /* 자동 증가 컬럼 지정 */ alter table test1 modify column no int not null auto_increment; - 전체 컬럼 값 입력하기 /* 컬럼을 지정하지 않으면 * 테이블을 생성할 때 선언한 컬럼 순서대로 * 값을 지정해야 한다.*/ insert into 테이블명 values(값,....); insert into test1 values(null,'aaa','111','222','10101','seoul'); /* 컬럼을 명시할 수 있다. 이때 값을 입력하는 컬럼의 순서를 바꿀 수 있다. */ insert into 테이블명(컬럼,컬럼,...) values(값,값,...); insert into test1(name,fax,tel,no,pstno,addr) values('bbb','222','111',null,'10101','seoul'); - 값을 입력할 컬럼을 선택하기. 단 필수 입력 컬럼은 반드시 선택해야 한다. /* no 컬럼은 필수 입력 컬럼이지만, 자동 증가 컬럼이기 때문에 값을 입력하지 않아도 된다.*/ insert into test1(name,tel) values('ccc','333'); ### 여러 개의 값을 한 번에 insert 하기 insert into test1(name,tel) values ('aaa', '1111'), ('bbb', '2222'), ('ccc', '3333'); ### select 결과를 테이블에 insert하기 create table test2 ( no int primary key auto_increment, fullname varchar(20) not null, phone varchar(20) not null, kor int, eng int, math int ); /* select 결과를 테이블에 바로 입력하기 =&gt; select 결과의 컬럼명과 insert 테이블의 컬럼명이 같을 필요는 없다. =&gt; 그러나 결과의 컬럼 개수와 insert 하려는 컬럼 개수가 같아야 한다. =&gt; 결과의 컬럼 타입과 insert 하려는 컬럼의 타입이 같거나 입력 할 수 있는 타입이어야 한다. */ insert into test2(fullname,phone) select name, tel from test1 where addr='seoul'; ## update - 등록된 데이터를 변경할 때 사용하는 명령이다. update 테이블명 set 컬럼명=값, 컬럼명=값, ... where 조건...; update test1 set pstno='11111', fax='222' where no=3; update test1 set tel='3030', fax='1212' where no=2; /* 조건을 지정하지 않으면, 모든 데이터에 대해 변경한다.*/ update test1 set fax='333'; ## delete - 데이터를 삭제할 때 사용하는 명령이다. delete from 테이블명 where 조건; delete from test1 where no=2 or no=3; /* 조건을 지정하지 않으면 모든 데이터가 삭제된다. 주의!*/ delete from test1; ## autocommit mysql은 autocommit의 기본 값이 true이다. 따라서 명령창에서 SQL을 실행하면 바로 실제 테이블에 적용된다. 수동으로 처리하고 싶다면 autocommit을 false로 설정하라! &gt; set autocommit=false; insert/update/delete을 수행한 후 승인을 해야만 실제 테이블에 적용된다. &gt; commmit; 마지막 commit 상태로 되돌리고 싶다면, &gt; rollback; 연습1: insert into test1(name, tel) values('xxx', '1111'); insert into test1(name, tel) values('yyy', '2222'); insert into test1(name, tel) values('zzz', '2222'); update test1 set fax='1212' where name='xxx'; delete from test1 where no=1; rollback; /* 지금까지 작업한 insert, update, delete은 최소된다.*/ 연습2: insert into test1(name, tel) values('xxx', '1111'); insert into test1(name, tel) values('yyy', '2222'); insert into test1(name, tel) values('zzz', '2222'); commit; /* 지금까지 한 작업을 테이블에 적용한다.*/ update test1 set fax='1212' where name='xxx'; delete from test1 where no=1; rollback; /* 막지막 commit 이후에 수행한 insert, update, delete은 최소된다.*/ DML (Data Manipulation Language) 데이터 등록, 변경, 삭제를 다루는 SQL 문법 insert, update, deleteinsert 데이터를 입력할 때 사용하는 문법이다. 테이블 생성 (연락처) create table test1 ( no int not null, name varchar(20) not null, tel varchar(20) not null, fax varchar(20), pstno varchar(5), addr varchar(200) ); PK 컬럼 &amp; 자동 증가 컬럼 지정 mysql&gt; alter table test1 add constraint test1_pk primary key (no); mysql&gt; alter table test1 modify column no int not null auto_increment; 전체 컬럼 값 입력하기 컬럼을 지정하지 않으면, 테이블을 생성할 때 선언한 컬럼 순서대로 값을 지정해야 한다. insert into 테이블명 values('aaa', 20, null, ....); mysql&gt; insert into test1 values(null,'aaa','111','222','10101','seoul'); mysql&gt; select * from test1; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ +----+------+-----+------+-------+-------+ | no | name | tel | fax | pstno | addr | +----+------+-----+------+-------+-------+ | 1 | aaa | 111 | 222 | 10101 | seoul | +----+------+-----+------+-------+-------+ no는 PK &amp; 자동 증가 컬럼으로 지정되어서 null 입력 시 자동으로 입력한다. 컬럼을 명시할 수 있다. ⇒ 이때 값을 입력하는 컬럼의 순서를 바꿀 수 있다. insert into 테이블명(name, age, tel, ....) values('aaa', 20, null, ....); mysql&gt; insert into test1(name,fax,tel,no,pstno,addr) values('bbb','222','111',null,'10101','seoul'); mysql&gt; select * from test1; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ +----+------+-----+------+-------+-------+ | no | name | tel | fax | pstno | addr | +----+------+-----+------+-------+-------+ | 1 | aaa | 111 | 222 | 10101 | seoul | | 2 | bbb | 111 | 222 | 10101 | seoul | +----+------+-----+------+-------+-------+ MySQL에서는 숫자가 들어갈 자리에 문자열을 넣으면 자동 형변환한다. ⇒ 그러나 이렇게 쓰지 마라 ! mysql&gt; insert into test1(name,fax,tel,no,pstno,addr) values('bbb','222','111','200','10101','seoul'); mysql&gt; select * from test1; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ +-----+------+-----+------+-------+-------+ | no | name | tel | fax | pstno | addr | +-----+------+-----+------+-------+-------+ | 1 | aaa | 111 | 222 | 10101 | seoul | | 2 | bbb | 111 | 222 | 10101 | seoul | | 200 | bbb | 111 | 222 | 10101 | seoul | +-----+------+-----+------+-------+-------+ 필수 컬럼만 지정하기 값을 입력할 컬럼을 선택하기. (단, 필수 입력 컬럼은 반드시 선택해야 한다) **mysql&gt; insert into test1(name,tel) values('ccc','333');** no 컬럼은 필수 입력 컬럼이지만, 자동 증가 컬럼이기 때문에 값을 입력하지 않아도 된다 여러 개의 값을 한 번에 insert 하기 mysql&gt; insert into test1(name,tel) values('ccc','333'); mysql&gt; insert into test1(name,tel) values -&gt; ('aaa', '1111'), -&gt; ('bbb', '2222'), -&gt; ('ccc', '3333'); mysql&gt; select * from test1; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ +-----+------+------+------+-------+-------+ | no | name | tel | fax | pstno | addr | +-----+------+------+------+-------+-------+ | 1 | aaa | 111 | 222 | 10101 | seoul | | 2 | bbb | 111 | 222 | 10101 | seoul | | 200 | bbb | 111 | 222 | 10101 | seoul | | 201 | ccc | 333 | NULL | NULL | NULL | | 202 | aaa | 1111 | NULL | NULL | NULL | | 203 | bbb | 2222 | NULL | NULL | NULL | | 204 | ccc | 3333 | NULL | NULL | NULL | +-----+------+------+------+-------+-------+ select 결과를 테이블에 insert하기 (select 결과를 테이블에 바로 입력하기) select 결과의 컬럼명과 insert 테이블의 컬럼명이 같을 필요는 없다. 그러나 결과의 컬럼 개수와 insert 하려는 컬럼 개수가 같아야 한다. 결과의 컬럼 타입과 insert 하려는 컬럼의 타입이 같거나 입력 할 수 있는 타입이어야 한다. create table test2 ( no int primary key auto_increment, fullname varchar(20) not null, phone varchar(20) not null, kor int, eng int, math int ); mysql&gt; insert into test2(fullname, phone) select no, name, tel from test1 where addr='seoul'; =&gt; 꺼낸 컬럼은 3개인데 지정된 컬럼은 2개 뿐이라서 mysql&gt; insert into test2(fullname, phone) select name, tel from test1 where addr='seoul'; mysql&gt; select * from test2; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ +----+----------+-------+------+------+------+ | no | fullname | phone | kor | eng | math | +----+----------+-------+------+------+------+ | 1 | 1 | aaa | NULL | NULL | NULL | | 2 | 2 | bbb | NULL | NULL | NULL | | 3 | 200 | bbb | NULL | NULL | NULL | | 4 | aaa | 111 | NULL | NULL | NULL | | 5 | bbb | 111 | NULL | NULL | NULL | | 6 | bbb | 111 | NULL | NULL | NULL | +----+----------+-------+------+------+------+ update 등록된 데이터를 변경할 때 사용하는 명령 update 테이블명 set 컬럼명=값, 컬럼명=값, … where 조건 … ; +-----+------+------+------+-------+-------+ | no | name | tel | fax | pstno | addr | +-----+------+------+------+-------+-------+ | 1 | aaa | 111 | 222 | 10101 | seoul | | 2 | bbb | 111 | 222 | 10101 | seoul | | 200 | bbb | 111 | 222 | 10101 | seoul | | 201 | ccc | 333 | NULL | NULL | NULL | | 202 | aaa | 1111 | NULL | NULL | NULL | | 203 | bbb | 2222 | NULL | NULL | NULL | | 204 | ccc | 3333 | NULL | NULL | NULL | +-----+------+------+------+-------+-------+ mysql&gt; update test1 set pstno='11111', fax='222' where no=200; mysql&gt; select * from test1; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ +-----+------+------+------+-------+-------+ | no | name | tel | fax | pstno | addr | +-----+------+------+------+-------+-------+ | 1 | aaa | 111 | 222 | 10101 | seoul | | 2 | bbb | 111 | 222 | 10101 | seoul | | 200 | bbb | 111 | 222 | 11111 | seoul | | 201 | ccc | 333 | NULL | NULL | NULL | | 202 | aaa | 1111 | NULL | NULL | NULL | | 203 | bbb | 2222 | NULL | NULL | NULL | | 204 | ccc | 3333 | NULL | NULL | NULL | +-----+------+------+------+-------+-------+ mysql&gt; update test1 set tel='3030', fax='1212' where no=2; mysql&gt; select * from test1; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ +-----+------+------+------+-------+-------+ | no | name | tel | fax | pstno | addr | +-----+------+------+------+-------+-------+ | 1 | aaa | 111 | 222 | 10101 | seoul | | 2 | bbb | 3030 | 1212 | 10101 | seoul | | 200 | bbb | 111 | 222 | 11111 | seoul | | 201 | ccc | 333 | NULL | NULL | NULL | | 202 | aaa | 1111 | NULL | NULL | NULL | | 203 | bbb | 2222 | NULL | NULL | NULL | | 204 | ccc | 3333 | NULL | NULL | NULL | +-----+------+------+------+-------+-------+ 조건을 지정하지 않으면, 모든 데이터에 대해 변경한다. mysql&gt; update test1 set fax='333'; mysql&gt; select * from test1; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ +-----+------+------+------+-------+-------+ | no | name | tel | fax | pstno | addr | +-----+------+------+------+-------+-------+ | 1 | aaa | 111 | 333 | 10101 | seoul | | 2 | bbb | 3030 | 333 | 10101 | seoul | | 200 | bbb | 111 | 333 | 11111 | seoul | | 201 | ccc | 333 | 333 | NULL | NULL | | 202 | aaa | 1111 | 333 | NULL | NULL | | 203 | bbb | 2222 | 333 | NULL | NULL | | 204 | ccc | 3333 | 333 | NULL | NULL | +-----+------+------+------+-------+-------+ 모든 데이터가 의미 없어질 수 있다. delete 데이터를 삭제할 때 사용하는 명령이다. delete 테이블명 where 조건 … ; mysql&gt; delete from test1 where no=2 or no=200; mysql&gt; select * from test1; ━━━━━━━━━━━━━━━━━━━━━━━━━ +-----+------+------+------+-------+-------+ | no | name | tel | fax | pstno | addr | +-----+------+------+------+-------+-------+ | 1 | aaa | 111 | 333 | 10101 | seoul | | 201 | ccc | 333 | 333 | NULL | NULL | | 202 | aaa | 1111 | 333 | NULL | NULL | | 203 | bbb | 2222 | 333 | NULL | NULL | | 204 | ccc | 3333 | 333 | NULL | NULL | +-----+------+------+------+-------+-------+ 조건을 지정하지 않으면, 모든 데이터가 삭제된다. 주의!! delete from test1; 삭제된 데이터는 복구가 되지 않는다. ★ 파일과 변경/삭제 파일 데이터 변경 기존 값을 저장한 부분을 변경 파일 데이터 삭제 기존 값을 저장한 부분을 초기화 지우려는 기존 값을 0으로 초기화 시킨다. ★ 데이터를 제거하려면 뒤의 데이터를 앞으로 당겨야 한다. (⇒ 즉, 복사해야 한다) ⇒ 이 과정에서 시간이 많이 소요된다. ⇒ 그래서 그냥 데이터가 저장된 부분을 0으로 덮어쓰는 것이다. 파일의 특정 부분을 잘라낼 수 없다. ⇒ (1) 잘라낼 부분을 뺀 데이터를 새 파일에 쓰거나 ⇒ (2) 또는 뒤의 데이터를 삭제할 부분으로 당겨야 한다. ★ 즉, 삽입이라는 것은 실제로는 맨 뒤에 데이터를 넣고 별도 데이터로 위치 데이터를 관리한다. autocommit / 수동 커밋 ★ autocommit MySQL은 autocommit의 기본 값이 true이다. 따라서 명령창에서 SQL을 실행하면 바로 실제 테이블에 적용된다. 수동으로 처리하고 싶다면 autocommit을 false로 설정하라! 수동 커밋 - commit autocommit을 false로 설정하면 insert / update / delete을 수행한 후 승인(commit)을 해야만 실제 테이블에 적용된다. &gt; commmit; commit 전에는 버퍼(cache)라고 하는 임시 저장소에 실행 결과가 보관되고 commit 명령을 하는 경우 실제 테이블에 적용되고 버퍼는 비워진다. 수동 커밋 - rollback commit을 하기 전 실행 결과가 버퍼에 임시 보관되어 있을 때 select을 하는 경우, DBMS의 table 데이터와 버퍼에 있는 임시 데이터를 종합하여 select 결과를 보여준다. 이때, 다시 되돌리고 싶다면 버퍼를 rollback 명령으로 비워주면 된다. 즉, 마지막 commit 상태로 되돌리고 싶다면, &gt; rollback; ⇒ 이렇게 하면 버퍼의 데이터가 싹 날아감 (commit 해봤자 의미 없음) client와 commit ★★ Client1 : autocommit = false 인 경우 mysql&gt; set autocommit = false; insert / update / delete 명령을 실행하면 insert into test1(name, tel) values('xxx', '1111'); insert into test1(name, tel) values('yyy', '2222'); insert into test1(name, tel) values('zzz', '2222'); Thread는 명령 실행 결과를 버퍼(chache)에 임시 보관한다. 이후 select 명령 시 mysql&gt; select * from test1 Thread는 DMBS에서 테이블 데이터를 조회하고 버퍼에서 임시 데이터를 조회한다. 테이블 데이터와 임시 데이터를 종합하여 select한 결과를 리턴한다. (select한 결과를 버퍼에 임시 보관한다) +-----+------+------+------+-------+------+ | no | name | tel | fax | pstno | addr | +-----+------+------+------+-------+------+ | 205 | xxx | 1111 | NULL | NULL | NULL | | 206 | yyy | 2222 | NULL | NULL | NULL | | 207 | zzz | 2222 | NULL | NULL | NULL | +-----+------+------+------+-------+------+ ⇒ 현재 상태는 명령 실행 결과를 실제 테이블에 반영을 하지 않는 상태이다. ⇒ 한 번 select 결과를 cache하면 원본 테이블이 바뀌던 안 바뀐던 상관안한다. ★ ⇒ 보관은 언제까지? commit/rollback해서 버퍼를 비울 때까지 보관해둔다. (보관이라는 의미는 데이터 위치 정보만) ⇒ select 할 때는 이 보관소에 있는 데이터를 조회한다. ★ Client2 : autocommit = true 인 또 다른 Client 추가 select 문을 실행한다. Thread가 DBMS에서 실제 테이블 데이터를 조회한다. 조회한 결과를 리턴한다. mysql&gt; select * from test1; Empty set (0.00 sec) (테이블에는 데이터 없음 증명) ⇒ Client1에서 commit을 하지 않은 상태로 insert 실행 결과가 반영되지 않았다. 따라서 현재 테이블엔 아무 데이터가 없는 상태이다. (0개) Client1 &amp; Client2 Client1에서 commit 명령을 실행하여 결과를 반영시키고 다시 select 명령 실행한다. mysql&gt; select * from test1; +-----+------+------+------+-------+------+ | no | name | tel | fax | pstno | addr | +-----+------+------+------+-------+------+ | 205 | xxx | 1111 | NULL | NULL | NULL | | 206 | yyy | 2222 | NULL | NULL | NULL | | 207 | zzz | 2222 | NULL | NULL | NULL | +-----+------+------+------+-------+------+ Client2에서 insert로 새로운 데이터를 추가한 후 select 명령 실행한다. (Client1에서 추가한 데이터 3개와 Client2에서 추가한 데이터가 잘 나타난다) mysql&gt; select * from test1; +-----+------+------+------+-------+------+ | no | name | tel | fax | pstno | addr | +-----+------+------+------+-------+------+ | 205 | xxx | 1111 | NULL | NULL | NULL | | 206 | yyy | 2222 | NULL | NULL | NULL | | 207 | zzz | 2222 | NULL | NULL | NULL | | 208 | aaa | 0000 | NULL | NULL | NULL | +-----+------+------+------+-------+------+ 다시 Client1에서 select 명령을 실행한다. ⇒ Client2에서 추가한 데이터가 보이지 않는다. mysql&gt; select * from test1; +-----+------+------+------+-------+------+ | no | name | tel | fax | pstno | addr | +-----+------+------+------+-------+------+ | 205 | xxx | 1111 | NULL | NULL | NULL | | 206 | yyy | 2222 | NULL | NULL | NULL | | 207 | zzz | 2222 | NULL | NULL | NULL | +-----+------+------+------+-------+------+ Client2에서 추가로 데이터 3개를 insert 한다. Client1에서 commit 명령을 실행하고 select 명령을 실행한다. (이 순간 Client2에서 추가했던 데이터들을 가져온다) mysql&gt; select * from test1; +-----+------+------+------+-------+------+ | no | name | tel | fax | pstno | addr | +-----+------+------+------+-------+------+ | 205 | xxx | 1111 | NULL | NULL | NULL | | 206 | yyy | 2222 | NULL | NULL | NULL | | 207 | zzz | 2222 | NULL | NULL | NULL | | 208 | aaa | 0000 | NULL | NULL | NULL | | 209 | xxx | 1111 | NULL | NULL | NULL | | 210 | yyy | 2222 | NULL | NULL | NULL | | 211 | aaa | 0000 | NULL | NULL | NULL | +-----+------+------+------+-------+------+ 조심해야 할 것은 DBMS 마다 이러한 작동 방식이 살짝 다르다는 것이다. 중요한 것은 insert / update / delete하게 되면 그 결과는 임시 버퍼에 보관된다. select를 하게 되면 테이블의 값과 임시 버퍼에 보관된 값을 조합하여 return하는데, 중요한 것은 테이블의 값이 실시간으로 반영된 것이 아니라는 것이다. ★ 그러므로 commit을 먼저 하고 select 해야 한다 즉, autocommit이 false인 상태일 때 select를 하게 되면 실제 테이블의 값과 다를 수 있음을 감안해야 한다. 또, 다른 client에서는 임시 버퍼에 있는 결과는 가져오지 못한다. ★ commit을 통해 반영시켜야만 다른 client에서도 그 결과를 알 수 있다. 연습1:insert into test1(name, tel) values('xxx', '1111');insert into test1(name, tel) values('yyy', '2222');insert into test1(name, tel) values('zzz', '2222');update test1 set fax='1212' where name='xxx';delete from test1 where no=1;rollback; /* 지금까지 작업한 insert, update, delete은 최소된다.*/연습2:insert into test1(name, tel) values('xxx', '1111');insert into test1(name, tel) values('yyy', '2222');insert into test1(name, tel) values('zzz', '2222');commit; /* 지금까지 한 작업을 테이블에 적용한다.*/update test1 set fax='1212' where name='xxx';delete from test1 where no=1;rollback; /* 막지막 commit 이후에 수행한 insert, update, delete은 최소된다.*/트랜잭션 (transaction) 트랜잭션 (transaction) 여러 개의 작업을 한 단위로 묶은 것 (작업 : insert / update / delete) ⇒ 수동 커밋을 설정하는 경우 ⇒ “commit / rollback”으로 제어 예시 “퇴사”라는 트랜잭션 회사 대출 완납 + 월급 미정산분 정산 + 대여 물품 반납 등 “계좌이체”라는 트랜잭션 나의 계좌(-) ⇒ 상대편 계좌(+) ⇒ 완료 전달 받으면 commit 완료 처리 ⇒ 완료 전달 ⇒ 상대방 쪽에서 commit 완료 처리 " }, { "title": "DQL", "url": "/posts/mysql-dql/", "categories": "코딩 지식, MySQL, SQL", "tags": "MySQL, DQL, 문법", "date": "2024-11-24 11:04:00 +0900", "snippet": "DQL eomcs-docs → sql 폴더 → exam03 # DQL(Data Query Language) 데이터를 조회할 때 사용하는 문법 ## 테스트 용 테이블 및 데이터 준비 create table test1 ( no int primary key auto_increment, name va...", "content": "DQL eomcs-docs → sql 폴더 → exam03 # DQL(Data Query Language) 데이터를 조회할 때 사용하는 문법 ## 테스트 용 테이블 및 데이터 준비 create table test1 ( no int primary key auto_increment, name varchar(20) not null, class varchar(10) not null, working char(1) not null, tel varchar(20) ); insert into test1(name,class,working) values('aaa','java100','Y'); insert into test1(name,class,working) values('bbb','java100','N'); insert into test1(name,class,working) values('ccc','java100','Y'); insert into test1(name,class,working) values('ddd','java100','N'); insert into test1(name,class,working) values('eee','java100','Y'); insert into test1(name,class,working) values('kkk','java101','N'); insert into test1(name,class,working) values('lll','java101','Y'); insert into test1(name,class,working) values('mmm','java101','N'); insert into test1(name,class,working) values('nnn','java101','Y'); insert into test1(name,class,working) values('ooo','java101','N'); ## select - 테이블의 데이터를 조회할 때 사용하는 명령이다. /* 모든 컬럼 값 조회하기. 컬럼 순서는 테이블을 생성할 때 선언한 순서이다.*/ select * from 테이블; select * from test1; /* 특정 컬럼의 값만 조회할 때 =&gt; \"프로젝션(projection)\"이라 부른다.*/ select 컬럼명,컬럼명 from 테이블; select no, name, tel from test1; /* 가상의 컬럼 값을 조회하기*/ select no, concat(name,'(',class,')') from test1; ### 조회하는 컬럼에 별명 붙이기 - 별명을 붙이지 않으면 원래의 컬럼명이 조회 결과의 컬럼이름으로 사용된다. - 위의 예제처럼 복잡한 식으로 표현한 컬럼인 경우 컬럼명도 그 식이 된다. - 이런 경우 별명을 붙이면 조회 결과를 보기 쉽다. /* 컬럼에 별명 붙이기*/ select 컬럼명 [as] 별명 ... select no as num, concat(name,'(',class,')') as title from test1; /* as를 생략해도 된다.*/ select no num, concat(name,'(',class,')') title from test1; ### 조회할 때 조건 지정하기 - where 절과 연산자를 이용하여 조회 조건을 지정할 수 있다. - 이렇게 조건을 지정하여 결과를 선택하는 것을 \"셀렉션(selection)\" 이라 한다. select ... from ... where 조건... select * from test1 where no &gt; 5; ## 연산자 ### OR, AND, NOT - OR : 두 조건 중에 참인 것이 있으면 조회 결과에 포함시킨다. - AND : 두 조건 모두 참일 때만 조회 결과에 포함시킨다. - NOT : 조건에 일치하지 않을 때만 결과에 포함시킨다. select * from test1; /* 재직자 또는 java100기 학생만 조회하라!*/ select no, name, class, working from test1 where working='Y' or class='java100'; /* java100기 학생 중에 재직자만 조회하라!*/ select no, name, class, working from test1 where working='Y' and class='java100'; /* 주의! * where 절을 통해 결과 데이터를 먼저 선택(selection)한 다음 * 결과 데이터에서 가져올 컬럼을 선택(projection)한다. * 따라서 실행 순서는: * from ==&gt; where ==&gt; select ==&gt; order by ==&gt; limit */ select no, name from test1 where working='Y' and class='java100'; /* 재직자가 아닌 사람만 조회하라!*/ select no, name, class, working from test1 where not working = 'Y'; select no, name, class, working from test1 where working != 'Y'; select no, name, class, working from test1 where working &lt;&gt; 'Y'; /* 학생 번호가 짝수인 경우 전화 번호를 '1111'로 변경하라*/ update test1 set tel = '1111' where (no % 2) = 0; /* 학생 번호가 3의 배수인 경우 전화번호를 '2222'로 변경하라*/ update test1 set tel = '2222' where (no % 3) = 0; /* 전화 번호가 있는 학생만 조회하라!*/ /* =&gt; 다음과 같이 null에 != 연산자를 사용하면 조건이 맞지 않는다.*/ select * from test1 where tel != null; /* =&gt; null인지 여부를 가릴 때는 is 또는 is not 연산자를 사용하라!*/ select * from test1 where tel is not null; select * from test1 where not tel is null; /* 전화 번호가 없는 학생만 조회하라!*/ /* =&gt; null인지 여부를 가릴 때는 = 연산자가 아닌 is 연산자를 사용해야 한다.*/ select * from test1 where tel = null; /* 실패 */ select * from test1 where tel is null; /* OK */ ### 사칙연산 - +, -, *, /, % 연산자를 사용할 수 있다. select (4 + 5), (4 - 5), (4 * 5), (4 / 5), (4 % 5); ### 비교연산 - =, !=, &gt;, &gt;=, &lt;, &lt;=, &lt;&gt; select (4=5), (4!=5), (4&gt;5), (4&gt;=5), (4&lt;5), (4&lt;=5), (4&lt;&gt;5); ### between 값1 and 값2 - 두 값 사이(두 값도 포함)에 있는지 검사한다. select 5 between 3 and 5; ### like - 문자열을 비교할 때 사용한다. insert into test1(name,class,working) values('xxx', 'window27', '1'); insert into test1(name,class,working) values('yyy', 'window27', '0'); insert into test1(name,class,working) values('zzz', 'window28', '1'); insert into test1(name,class,working) values('qqq', 'window28', '0'); insert into test1(name,class,working) values('s01', 'javawin1', '1'); insert into test1(name,class,working) values('s02', 'javawin1', '0'); insert into test1(name,class,working) values('s03', 'javawin1', '0'); insert into test1(name,class,working) values('s04', 'iotjava5', '1'); insert into test1(name,class,working) values('s05', 'iotjava5', '0'); insert into test1(name,class,working) values('s06', 'iotjava5', '0'); insert into test1(name,class,working) values('s011', 'iotjava5', '1'); insert into test1(name,class,working) values('s012', 'iotjava5', '1'); insert into test1(name,class,working) values('s013', 'iotjava5', '1'); /* class 이름이 java로 시작하는 모든 학생 조회하기 * =&gt; % : 0개 이상의 문자 */ select * from test1 where class like 'java%'; /* class 이름에 java를 포함한 모든 학생 조회하기 이 경우 조회 속도가 느리다.*/ select * from test1 where class like '%java%'; /* class 이름이 101로 끝나는 반의 모든 학생 조회하기 */ select * from test1 where class like '%101'; /* 학생의 이름에서 첫번째 문자가 s이고 두번째 문자가 0인 학생 중에서 딱 세자의 이름을 가진 학생을 모두 조회하라!*/ /* =&gt; %는 0자 이상을 의미하기 때문에 이 조건에 맞지 않다.*/ select * from test1 where name like 's0%'; /* =&gt; _는 딱 1자를 의미한다.*/ select * from test1 where name like 's0_'; ### 날짜 다루기 - 날짜 함수와 문자열 함수를 사용하여 날짜 값을 다루는 방법. drop table test1; create table test1 ( no int not null, title varchar(200) not null, content text, regdt datetime not null ); alter table test1 add constraint primary key (no), modify column no int not null auto_increment; insert into test1(title, regdt) values('aaaa', '2022-01-27'); insert into test1(title, regdt) values('bbbb', '2022-2-2'); insert into test1(title, regdt) values('cccc', '2022-2-13'); insert into test1(title, regdt) values('dddd', '2022-3-2'); insert into test1(title, regdt) values('eeee', '2022-4-15'); insert into test1(title, regdt) values('ffff', '2022-6-7'); insert into test1(title, regdt) values('gggg', '2022-6-17'); insert into test1(title, regdt) values('hhhh', '2022-6-27'); insert into test1(title, regdt) values('iiii', '2022-9-5'); insert into test1(title, regdt) values('jjjj', '2022-10-12'); insert into test1(title, regdt) values('kkkk', '2022-11-22'); insert into test1(title, regdt) values('llll', '2022-11-24'); insert into test1(title, regdt) values('mmmm', '2022-12-31'); - 날짜 값 비교하기 /* 특정 날짜의 게시글 찾기 */ select * from test1 where regdt = '2022-6-17'; /* 특정 기간의 게시글 조회 */ select * from test1 where regdt between '2022-11-1' and '2022-12-31'; select * from test1 where regdt &gt;= '2022-11-1' and regdt &lt;= '2022-12-31'; - 날짜를 다루는 연산자와 함수 /* 현재 날짜 및 시간 알아내기 */ select now(); /* 현재 날짜 알아내기 */ select curdate(); /* 현재 시간 알아내기 */ select curtime(); /* 주어진 날짜, 시간에서 날짜만 뽑거나 시간만 뽑기 */ select regdt, date(regdt), time(regdt) from test1; /* 특정 날짜에 시,분,초,일,월,년을 추가하거나 빼기*/ date_add(날짜데이터, interval 값 단위); date_sub(날짜데이터, interval 값 단위); select date_add(now(), interval 11 day); select date_sub(now(), interval 11 day); /* 두 날짜 사이의 간격을 알아내기 */ datediff(날짜1, 날짜2); select datediff(curdate(), '2023-2-10'); /* 날짜에서 특정 형식으로 값을 추출하기 */ date_format(날짜, 형식) select regdt, date_format(regdt, '%m/%e/%Y') from test1; /* 09/7/2022 */ select regdt, date_format(regdt, '%M/%d/%y') from test1; /* September/07/17 */ select regdt, date_format(regdt, '%W %w %a') from test1; /* Thursday 4 Thu */ select regdt, date_format(regdt, '%M %b') from test1; /* September Sep */ select now(), date_format(now(), '%p %h %H %l'); /* PM 01 13 1 */ select now(), date_format(now(), '%i %s'); /* 05 45 */ /* 문자열을 날짜 값으로 바꾸기 */ select str_to_date('11/22/2022', '%m/%d/%Y'); select str_to_date('2022.2.12', '%Y.%m.%d'); /* 날짜 값을 저장할 때 기본 형식은 yyyy-MM-dd이다. */ insert into test1 (title, regdt) values('aaaa', '2022-11-22'); /* 다음 형식의 문자열을 날짜 값으로 지정할 수 없다.*/ insert into test1 (title, regdt) values('bbbb', '11/22/2022'); /* 특정 형식으로 입력된 날짜를 date 타입의 컬럼 값으로 변환하면 입력할 수 있다.*/ insert into test1 (title, regdt) values('bbbb', str_to_date('11/22/2022', '%m/%d/%Y')); ⨳ DQL (Data Query Language) 데이터를 조회할 때 사용하는 문법 테스트 용 테이블 및 데이터 준비 create table test1 ( no int primary key auto_increment, name varchar(20) not null, class varchar(10) not null, working char(1) not null, tel varchar(20) ); insert into test1(name,class,working) values('aaa','java100','Y'); insert into test1(name,class,working) values('bbb','java100','N'); insert into test1(name,class,working) values('ccc','java100','Y'); insert into test1(name,class,working) values('ddd','java100','N'); insert into test1(name,class,working) values('eee','java100','Y'); insert into test1(name,class,working) values('kkk','java101','N'); insert into test1(name,class,working) values('lll','java101','Y'); insert into test1(name,class,working) values('mmm','java101','N'); insert into test1(name,class,working) values('nnn','java101','Y'); insert into test1(name,class,working) values('ooo','java101','N'); ※ select 문 (select statement) 컬럼명 자리 : 식, 리터럴 select 테이블의 데이터를 조회할 때 사용하는 명령이다. 모든 컬럼 값 조회하기 (컬럼 순서는 테이블을 생성할 때 선언한 순서) mysql&gt; select * from test1; +----+------+---------+---------+------+ | no | name | class | working | tel | +----+------+---------+---------+------+ | 1 | aaa | java100 | Y | NULL | | 2 | bbb | java100 | N | NULL | | 3 | ccc | java100 | Y | NULL | | 4 | ddd | java100 | N | NULL | | 5 | eee | java100 | Y | NULL | | 6 | kkk | java101 | N | NULL | | 7 | lll | java101 | Y | NULL | | 8 | mmm | java101 | N | NULL | | 9 | nnn | java101 | Y | NULL | | 10 | ooo | java101 | N | NULL | +----+------+---------+---------+------+ “프로젝션 (projection)” 특정 컬럼의 값만 조회할 때 ⇒ “프로젝션(projection)”이라 부른다. mysql&gt; select no, name, tel from test1; +----+------+------+ | no | name | tel | +----+------+------+ | 1 | aaa | NULL | | 2 | bbb | NULL | | 3 | ccc | NULL | | 4 | ddd | NULL | | 5 | eee | NULL | | 6 | kkk | NULL | | 7 | lll | NULL | | 8 | mmm | NULL | | 9 | nnn | NULL | | 10 | ooo | NULL | +----+------+------+ 가상의 컬럼 값을 조회하기 concat( ) 기능으로 컬럼의 값들을 합치거나 문자열을 추가할 수 있다. mysql&gt; select no, 'okok' from test1; +----+------+ | no | okok | +----+------+ | 1 | okok | | 2 | okok | | 3 | okok | | 4 | okok | | 5 | okok | | 6 | okok | | 7 | okok | | 8 | okok | | 9 | okok | | 10 | okok | +----+------+ mysql&gt; select no, concat('aaa', 'bbb') from test1; +----+----------------------+ | no | concat('aaa', 'bbb') | +----+----------------------+ | 1 | aaabbb | | 2 | aaabbb | | 3 | aaabbb | | 4 | aaabbb | | 5 | aaabbb | | 6 | aaabbb | | 7 | aaabbb | | 8 | aaabbb | | 9 | aaabbb | | 10 | aaabbb | +----+----------------------+ mysql&gt; select no, concat(name,'(',class,')') from test1; +----+----------------------------+ | no | concat(name,'(',class,')') | +----+----------------------------+ | 1 | aaa(java100) | | 2 | bbb(java100) | | 3 | ccc(java100) | | 4 | ddd(java100) | | 5 | eee(java100) | | 6 | kkk(java101) | | 7 | lll(java101) | | 8 | mmm(java101) | | 9 | nnn(java101) | | 10 | ooo(java101) | +----+----------------------------+ 문제 ⇒ 컬럼 이름이 “식 자체”로 나온다는 것이다. 조회하는 컬럼에 별명 붙이기 별명을 붙이지 않으면 원래의 컬럼명이 조회 결과의 컬럼 이름으로 사용된다. (복잡한 식으로 표현한 컬럼인 경우 컬럼명도 그 식이 된다) ⇒ 이런 경우 별명을 붙이면 조회 결과를 보기 쉽다. mysql&gt; select no as num, concat(name,'(',class,')') as title from test1; +-----+--------------+ | num | title | +-----+--------------+ | 1 | aaa(java100) | | 2 | bbb(java100) | | 3 | ccc(java100) | | 4 | ddd(java100) | | 5 | eee(java100) | | 6 | kkk(java101) | | 7 | lll(java101) | | 8 | mmm(java101) | | 9 | nnn(java101) | | 10 | ooo(java101) | +-----+--------------+ as를 생략해도 된다 mysql&gt; select no num, concat(name,'(',class,')') title from test1; +-----+--------------+ | num | title | +-----+--------------+ | 1 | aaa(java100) | | 2 | bbb(java100) | | 3 | ccc(java100) | | 4 | ddd(java100) | | 5 | eee(java100) | | 6 | kkk(java101) | | 7 | lll(java101) | | 8 | mmm(java101) | | 9 | nnn(java101) | | 10 | ooo(java101) | +-----+--------------+ 조회할 때 조건 지정하기 (”selection”) where 절과 연산자를 이용하여 조회 조건을 지정할 수 있다. 이렇게 조건을 지정하여 결과를 선택하는 것을 “셀렉션(selection)” 이라 한다. select * from test1 where no &gt; 5; ⨳ OR, AND, NOT 연산자 OR 두 조건 중에 참인 것이 있으면 조회 결과에 포함시킨다. 예시 (재직자 또는 java100기 학생만 조회) select no, name, class, working from test1 where working='Y' or class='java100'; AND 두 조건 모두 참일 때만 조회 결과에 포함시킨다. 예시 (java100기 학생 중에 재직자만 조회) select no, name, class, working from test1 where working='Y' and class='java100'; NOT 조건에 일치하지 않을 때만 결과에 포함시킨다. 예시 (재직자가 아닌 사람만 조회) select no, name, class, working from test1 where not working = 'Y'; ★ 주의! Selection ⇒ Projection where 절을 통해 결과 데이터를 먼저 선택(selection)한 다음 ⇒ 결과 데이터에서 가져올 컬럼을 선택(projection)한다. 조건은 앞에서 부터 처리한다. 조건에는 식이 올 수도 있다. ★ 실행 순서 ★ from ⇒ where ⇒ select ⇒ order by ⇒ limit ⨳ 사칙연산, 비교연산, Between, is null (is not null) 사칙연산 +, -, *, /, % 연산자를 사용할 수 있다. 연산 결과를 반환한다. select (4 + 5), (4 - 5), (4 * 5), (4 / 5), (4 % 5); ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ +---------+---------+---------+---------+---------+ | 4 + 5 | 4 - 5 | 4 * 5 | 4 / 5 | 4 % 5 | +---------+---------+---------+---------+---------+ | 9 | -1 | 20 | 0.8 | 4 | +---------+---------+---------+---------+---------+ 짝수 찾기 (학생 번호가 짝수인 경우 전화 번호를 ‘1111’로 변경하라) update test1 set tel = '1111' where (no % 2) = 0; 3의 배수 찾기 (학생 번호가 3의 배수인 경우 전화번호를 ‘2222’로 변경) update test1 set tel = '2222' where (no % 3) = 0; 비교연산 =, !=, &gt;, &gt;=, &lt;, &lt;=, &lt;&gt;(다름) 비교 결과를 true, false로 반환 select (4=5), (4!=5), (4&gt;5), (4&gt;=5), (4&lt;5), (4&lt;=5), (4&lt;&gt;5); ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ +-------+-------+-------+--------+-------+--------+-------+ | 4=5 | 4!=5 | 4&gt;5 | 4&gt;=5 | 4&lt;5 | 4&lt;=5 | 4&lt;&gt;5 | +-------+-------+-------+--------+-------+--------+-------+ | 0 | 1 | 0 | 0 | 1 | 1 | 1 | +-------+-------+-------+--------+-------+--------+-------+ != 와 &lt;&gt;는 동일하다. select no, name, class, working from test1 where working != 'Y'; select no, name, class, working from test1 where working &lt;&gt; 'Y'; is null (is not null) null 값을 비교 연산자로 비교할 수 없다. ⇒ “is null / is not null”로 비교 예시 (전화번호가 있는 학생만 조회) select * from test1 where tel != null; ( X ) select * from test1 where tel is not null; ( OK ) is null을 not 연산자와 함께 사용하여 is not null을 대체할 수 있다. select * from test1 where not tel is null; ( OK ) between 값1 and 값2 두 값 사이(두 값도 포함)에 있는지 검사한다. select 5 between 3 and 5; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ +-----------------------+ | 5 BETWEEN 3 AND 5 | +-----------------------+ | 1 | +-----------------------+ ⨳ like ⇒ 문자열 비교 like (문자열 비교) 문자열을 비교할 때 사용한다. 예시 데이터 insert into test1(name,class,working) values('xxx', 'window27', '1'); insert into test1(name,class,working) values('yyy', 'window27', '0'); insert into test1(name,class,working) values('zzz', 'window28', '1'); insert into test1(name,class,working) values('qqq', 'window28', '0'); insert into test1(name,class,working) values('s01', 'javawin1', '1'); insert into test1(name,class,working) values('s02', 'javawin1', '0'); insert into test1(name,class,working) values('s03', 'javawin1', '0'); insert into test1(name,class,working) values('s04', 'iotjava5', '1'); insert into test1(name,class,working) values('s05', 'iotjava5', '0'); insert into test1(name,class,working) values('s06', 'iotjava5', '0'); insert into test1(name,class,working) values('s011', 'iotjava5', '1'); insert into test1(name,class,working) values('s012', 'iotjava5', '1'); insert into test1(name,class,working) values('s013', 'iotjava5', '1'); 그러나, 데이터베이스가 검색엔진을 대체할 수 없다. (속도 차이가 엄청나다) class 이름이 java로 시작하는 모든 학생 조회하기 ⇒ % : 0개 이상의 문자 select * from test1 where class like 'java%'; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ +------+---------+---------+ | name | class | working | +------+---------+---------+ | s01 | javawin1| 1 | | s02 | javawin1| 0 | | s03 | javawin1| 0 | +------+---------+---------+ class 이름에 java를 포함한 모든 학생 조회하기 이 경우 조회 속도가 느리다 select * from test1 where class like '%java%'; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ +-------+----------+---------+ | name | class | working | +-------+----------+---------+ | s01 | javawin1 | 1 | | s02 | javawin1 | 0 | | s03 | javawin1 | 0 | | s04 | iotjava5 | 1 | | s05 | iotjava5 | 0 | | s06 | iotjava5 | 0 | | s011 | iotjava5 | 1 | | s012 | iotjava5 | 1 | | s013 | iotjava5 | 1 | +-------+----------+---------+ class 이름이 101로 끝나는 반의 모든 학생 조회하기 select * from test1 where class like '%101'; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 존재 안 함 학생의 이름에서 첫번째 문자가 s이고 두번째 문자가 0인 학생 중에서 딱 세 자의 이름을 가진 학생을 모두 조회하라! %는 0자 이상을 의미하기 때문에 이 조건에 맞지 않다. select * from test1 where name like 's0%'; ( X ) ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ +-------+----------+---------+ | name | class | working | +-------+----------+---------+ | s01 | javawin1 | 1 | | s02 | javawin1 | 0 | | s03 | javawin1 | 0 | | s04 | iotjava5 | 1 | | s05 | iotjava5 | 0 | | s06 | iotjava5 | 0 | | s011 | iotjava5 | 1 | | s012 | iotjava5 | 1 | | s013 | iotjava5 | 1 | +-------+----------+---------+ ⇒ 이름이 4글자인 학생들도 조회된다. ⇒ 이 경우 % 쓰면 안 된다. _는 딱 1자를 의미한다. select * from test1 where name like 's0_'; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ +-------+----------+---------+ | name | class | working | +-------+----------+---------+ | s01 | javawin1 | 1 | | s02 | javawin1 | 0 | | s03 | javawin1 | 0 | | s04 | iotjava5 | 1 | | s05 | iotjava5 | 0 | | s06 | iotjava5 | 0 | +-------+----------+---------+ ⨳ 날짜 다루기 날짜 다루기 날짜 함수와 문자열 함수를 사용하여 날짜 값을 다루는 방법 예시 데이터 및 결과 예시 데이터 create table test1 ( no int not null, title varchar(200) not null, content text, regdt datetime not null ); alter table test1 add constraint primary key (no), modify column no int not null auto_increment; insert into test1(title, regdt) values('aaaa', '2022-01-27'); insert into test1(title, regdt) values('bbbb', '2022-2-2'); insert into test1(title, regdt) values('cccc', '2022-2-13'); insert into test1(title, regdt) values('dddd', '2022-3-2'); insert into test1(title, regdt) values('eeee', '2022-4-15'); insert into test1(title, regdt) values('ffff', '2022-6-7'); insert into test1(title, regdt) values('gggg', '2022-6-17'); insert into test1(title, regdt) values('hhhh', '2022-6-27'); insert into test1(title, regdt) values('iiii', '2022-9-5'); insert into test1(title, regdt) values('jjjj', '2022-10-12'); insert into test1(title, regdt) values('kkkk', '2022-11-22'); insert into test1(title, regdt) values('llll', '2022-11-24'); insert into test1(title, regdt) values('mmmm', '2022-12-31'); 결과 **mysql&gt; desc test1;** +---------+--------------+------+-----+---------+----------------+ | Field | Type | Null | Key | Default | Extra | +---------+--------------+------+-----+---------+----------------+ | no | int | NO | PRI | NULL | auto_increment | | title | varchar(200) | NO | | NULL | | | content | text | YES | | NULL | | | regdt | datetime | NO | | NULL | | +---------+--------------+------+-----+---------+----------------+ **mysql&gt; select * from test1;** +----+-------+---------+---------------------+ | no | title | content | regdt | +----+-------+---------+---------------------+ | 1 | aaaa | NULL | 2022-01-27 00:00:00 | | 2 | bbbb | NULL | 2022-02-02 00:00:00 | | 3 | cccc | NULL | 2022-02-13 00:00:00 | | 4 | dddd | NULL | 2022-03-02 00:00:00 | | 5 | eeee | NULL | 2022-04-15 00:00:00 | | 6 | ffff | NULL | 2022-06-07 00:00:00 | | 7 | gggg | NULL | 2022-06-17 00:00:00 | | 8 | hhhh | NULL | 2022-06-27 00:00:00 | | 9 | iiii | NULL | 2022-09-05 00:00:00 | | 10 | jjjj | NULL | 2022-10-12 00:00:00 | | 11 | kkkk | NULL | 2022-11-22 00:00:00 | | 12 | llll | NULL | 2022-11-24 00:00:00 | | 13 | mmmm | NULL | 2022-12-31 00:00:00 | +----+-------+---------+---------------------+ 날짜 값 비교하기 특정 날짜의 게시글 찾기 mysql&gt; select * from test1 where regdt = '2022-6-17'; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ +----+-------+---------+---------------------+ | no | title | content | regdt | +----+-------+---------+---------------------+ | 7 | gggg | NULL | 2022-06-17 00:00:00 | +----+-------+---------+---------------------+ 특정 기간의 게시글 조회 mysql&gt; select * -&gt; from test1 -&gt; where regdt between '2022-11-1' and '2022-12-31'; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ +----+-------+---------+---------------------+ | no | title | content | regdt | +----+-------+---------+---------------------+ | 11 | kkkk | NULL | 2022-11-22 00:00:00 | | 12 | llll | NULL | 2022-11-24 00:00:00 | | 13 | mmmm | NULL | 2022-12-31 00:00:00 | +----+-------+---------+---------------------+ mysql&gt; select * -&gt; from test1 -&gt; where regdt &gt;= '2022-11-1' and regdt &lt;= '2022-12-31'; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ +----+-------+---------+---------------------+ | no | title | content | regdt | +----+-------+---------+---------------------+ | 11 | kkkk | NULL | 2022-11-22 00:00:00 | | 12 | llll | NULL | 2022-11-24 00:00:00 | | 13 | mmmm | NULL | 2022-12-31 00:00:00 | +----+-------+---------+---------------------+ ⇒ between과 결과 동일 ⨳ 날짜를 다루는 연산자와 함수 ★ 현재 날짜 및 시간 알아내기 now() mysql&gt; select now(); ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ +---------------------+ | now() | +---------------------+ | 2024-08-08 14:45:25 | +---------------------+ 현재 날짜 알아내기 curdate() mysql&gt; select curdate(); ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ +------------+ | curdate() | +------------+ | 2024-08-08 | +------------+ 현재 시간 알아내기 curtime() mysql&gt; select curtime(); ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ +-----------+ | curtime() | +-----------+ | 14:45:43 | +-----------+ 주어진 날짜, 시간에서 날짜만 뽑거나 시간만 뽑기 date() time() MySQL의 날짜/시간 데이터 유형으로 저장되어 있어야만 date( )및 time( ) 함수가 제대로 작동 mysql&gt; select regdt, date(regdt), time(regdt) from test1; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ +---------------------+-------------+-------------+ | regdt | date(regdt) | time(regdt) | +---------------------+-------------+-------------+ | 2022-01-27 00:00:00 | 2022-01-27 | 00:00:00 | | 2022-02-02 00:00:00 | 2022-02-02 | 00:00:00 | | 2022-02-13 00:00:00 | 2022-02-13 | 00:00:00 | | 2022-03-02 00:00:00 | 2022-03-02 | 00:00:00 | | 2022-04-15 00:00:00 | 2022-04-15 | 00:00:00 | | 2022-06-07 00:00:00 | 2022-06-07 | 00:00:00 | | 2022-06-17 00:00:00 | 2022-06-17 | 00:00:00 | | 2022-06-27 00:00:00 | 2022-06-27 | 00:00:00 | | 2022-09-05 00:00:00 | 2022-09-05 | 00:00:00 | | 2022-10-12 00:00:00 | 2022-10-12 | 00:00:00 | | 2022-11-22 00:00:00 | 2022-11-22 | 00:00:00 | | 2022-11-24 00:00:00 | 2022-11-24 | 00:00:00 | | 2022-12-31 00:00:00 | 2022-12-31 | 00:00:00 | +---------------------+-------------+-------------+ ★ 특정 날짜에 시,분,초,일,월,년을 추가하거나 빼기 date_add() date_sub() 현재 mysql&gt; select now(); ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ +---------------------+ | now() | +---------------------+ | 2024-08-08 14:45:25 | +---------------------+ 11일 추가 mysql&gt; select date_add(now(), interval 11 day); ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ +----------------------------------+ | date_add(now(), interval 11 day) | +----------------------------------+ | 2024-08-19 14:46:31 | +----------------------------------+ 11일 이전 mysql&gt; select date_sub(now(), interval 11 day); ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ +----------------------------------+ | date_sub(now(), interval 11 day) | +----------------------------------+ | 2024-07-28 14:46:54 | +----------------------------------+ ★ 두 날짜 사이의 간격을 알아내기 datediff() 간격은 날짜1 - 날짜2로 나타난다. mysql&gt; select datediff(curdate(), '2023-2-10'); ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ +----------------------------------+ | datediff(curdate(), '2023-2-10') | +----------------------------------+ | 545 | +----------------------------------+ mysql&gt; select datediff(curdate(), '2024-12-2'); ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ +----------------------------------+ | datediff(curdate(), '2024-12-2') | +----------------------------------+ | -116 | +----------------------------------+ 날짜에서 특정 형식으로 값을 추출하기 date_format() Day (%e : 1자리, %d : 2자리) mysql&gt; select regdt, date_format(regdt, '%m/%e/%Y') from test1; /* 09/7/2022 */ +---------------------+--------------------------------+ | regdt | date_format(regdt, '%m/%e/%Y') | +---------------------+--------------------------------+ | 2022-09-05 00:00:00 | 09/5/2022 | +---------------------+--------------------------------+ mysql&gt; select regdt, date_format(regdt, '%M/%d/%y') from test1; /* September/07/17 */ +---------------------+--------------------------------+ | regdt | date_format(regdt, '%M/%d/%y') | +---------------------+--------------------------------+ | 2022-09-05 00:00:00 | September/05/22 | +---------------------+--------------------------------+ 요일 (%W : 요일 전체 이름, %a : 요일 약어, %w : 요일 숫자 표현) mysql&gt; select regdt, date_format(regdt, '%W %w %a') from test1; /* Thursday 4 Thu */ +---------------------+--------------------------------+ | regdt | date_format(regdt, '%W %w %a') | +---------------------+--------------------------------+ | 2022-09-05 00:00:00 | Monday 1 Mon | +---------------------+--------------------------------+ 월 (%M : 월 전체 이름, %b : 월 약어, %m : 월 숫자 표현) mysql&gt; select regdt, date_format(regdt, '%M %b %m') from test1; /* September Sep 09 */ +---------------------+--------------------------------+ | regdt | date_format(regdt, '%M %b %m') | +---------------------+--------------------------------+ | 2022-09-05 00:00:00 | September Sep 09 | +---------------------+--------------------------------+ 시간 (%p : AM or PM, %h : 12시간 (0있음), %H : 24시간, %l : 12시간 (0없음)) mysql&gt; select now(), date_format(now(), '%p %h %H %l'); /* PM 01 13 1 */ +---------------------+-----------------------------------+ | now() | date_format(now(), '%p %h %H %l') | +---------------------+-----------------------------------+ | 2024-08-08 14:47:51 | PM 02 14 2 | +---------------------+-----------------------------------+ 분초 (%i : minute (0있음), %s : second (0있음)) mysql&gt; select now(), date_format(now(), '); /* 05 45 */; +---------------------+-----------------------------+ | now() | date_format(now(), '%i %s') | +---------------------+-----------------------------+ | 2024-08-08 14:47:55 | 47 55 | +---------------------+-----------------------------+ 문자열을 날짜 값으로 바꾸기 str_to_date() mysql&gt; select str_to_date('11/22/2022', '%m/%d/%Y'); +---------------------------------------+ | str_to_date('11/22/2022', '%m/%d/%Y') | +---------------------------------------+ | 2022-11-22 | +---------------------------------------+ mysql&gt; select str_to_date('2022.2.12', '%Y.%m.%d'); +--------------------------------------+ | str_to_date('2022.2.12', '%Y.%m.%d') | +--------------------------------------+ | 2022-02-12 | +--------------------------------------+ 날짜 값을 저장할 때 기본 형식은 yyyy-MM-dd이다.. 날짜 데이터는 아래의 형식으로 입력해야 한다. DATE 형식 : 'YYYY-MM-DD' DATETIME 형식 : 'YYYY-MM-DD HH:MM:SS' insert into test1 (title, regdt) values('aaaa', '2022-11-22'); 아래 처럼 입력 불가 insert into test1 (title, regdt) values('bbbb', '11/22/2022'); ( X ) 특정 형식으로 입력된 날짜를 date 타입의 컬럼 값으로 변환하면 입력할 수 있다. insert into test1 (title, regdt) values('bbbb', str_to_date('11/22/2022', '%m/%d/%Y')); " }, { "title": "MySQL 사용 방법", "url": "/posts/mysql-howtouse/", "categories": "코딩 지식, MySQL, 설정", "tags": "MySQL, 사용법, DDL", "date": "2024-11-23 14:08:00 +0900", "snippet": "▶ 데이터베이스와 DBMS mysql-settings # MySQL 설치 및 설정 ## MySQL 설치 [windows OS] scoop 패키지 관리자를 이용하여 mysql 설치 &gt; scoop install MySQL 서비스에 등록 mysqld --install \"서비스명\" &gt; mysql...", "content": "▶ 데이터베이스와 DBMS mysql-settings # MySQL 설치 및 설정 ## MySQL 설치 [windows OS] scoop 패키지 관리자를 이용하여 mysql 설치 &gt; scoop install MySQL 서비스에 등록 mysqld --install \"서비스명\" &gt; mysqld --install \"MySQL\" 서비스 시작 net start 서비스명 &gt; net start MySQL (windows) 서비스 종료 net stop 서비스명 &gt; net stop MySQL [mac] mysql 설치 &gt; brew install mysql mysql 설치 후 root 암호 변경 &gt; sudo mysql_secure_installation mysql 실행 &gt; brew services start mysql &gt; brew services stop mysql 또는 &gt; mysql.server start &gt; mysql.server stop [linux] mysql 설치 &gt; sudo apt update &gt; sudo apt install mysql-server &gt; sudo systemctl status mysql &gt; mysql -V mysql 설치 후 root 암호 변경 &gt; sudo mysql_secure_installation mysql 실행 &gt; service mysql start &gt; service mysql stop &gt; service mysql status ## mysql 서버에 접속하기 로컬 MySQL 서버에 접속 &gt; mysql -u root -p &gt; Enter password: 암호입력 원격 MySQL 서버에 접속 &gt; mysql -h 서버주소 -u root -p &gt; Enter password: 암호입력 ## mysql root 암호 변경 &gt; alter user 'root'@'localhost' identified by '1111'; ## MySQL 사용자 추가 &gt; CREATE USER '사용자아이디'@'서버주소' IDENTIFIED BY '암호'; 로컬에서만 접속할 수 있는 사용자를 만들기: &gt; CREATE USER 'study'@'localhost' IDENTIFIED BY '1111'; =&gt; 이 경우 stidu 사용자는 오직 로컬(서버를 실행하는 컴퓨터)에서만 접속 가능한다. =&gt; 다른 컴퓨터에서 실행하는 MySQL 서버에 접속할 수 없다는 것을 의미한다. 원격에서만 접속할 수 있는 사용자를 만들기: &gt; CREATE USER 'study'@'%' IDENTIFIED BY '1111'; =&gt; 이 경우 study 사용자는 원력에서만 접속 가능하다. ## MySQL 사용자 목록 조회 &gt; select user from 데이터베이스명.테이블명; &gt; select user from mysql.user; ## MySQL 데이터베이스 생성 &gt; CREATE DATABASE 데이터베이스명 DEFAULT CHARACTER SET utf8 DEFAULT COLLATE utf8_general_ci; &gt; CREATE DATABASE studydb DEFAULT CHARACTER SET utf8 DEFAULT COLLATE utf8_general_ci; ## MySQL 사용자에게 데이터베이스 사용 권한 부여 &gt; GRANT ALL ON 데이터베이스명.* TO '사용자아이디'@'서버주소'; &gt; GRANT ALL ON studydb.* TO 'study'@'localhost'; ## 데이터베이스 목록 조회 &gt; show databases; ## 사용자 교체 &gt; quit (프로그램 종료 후) &gt; mysql -u study -p (다시 실행) ## 기본으로 사용할 데이터베이스 지정하기 &gt; use 데이터베이스명 &gt; use studydb; ## 데이터베이스의 전체 테이블 목록 조회 &gt; show tables; ※ DBMS 도입 - 소개 DBMS   :   Database 관리 S/W RDBMS   (관계형 DBMS) Oracle, MS-SQL, DB2, MYSQL(오픈소스), MariaDB, PostgreSQL, Tibero, Cubrid, Altibase MongoDB, Redis 데이터베이스   (DB : DataBase) 데이터베이스는 데이터의 집합이다. 검색, 갱신이 쉽도록 구조화 실시간 접근 동시 공유 데이터 중복 최소화 일관성, 무결성, 보안성 일관성   (규칙 준수) 규칙이나 제약 조건을 준수   ⇒   데이터 신뢰성 확보 ※ DBMS 도입 - MySQL 설치 MySQL DBMS 설치 및 설정 MySQL 서버에 직접 접근할 수 없다. (만약 할 수 있었다면 외부 해커도 가능하니까) ⇒   Linux 서버를 통해 MySQL 서버로 접근한다. (외부 접근은 Linux가 방화벽으로 차단한다) ⇒   그런데 Linux 서버에서는 CLI로 제어한다. 그러므로 개발자도 CLI 방식을 알아야 한다. ※ DBMS 도입 - DBMS 사용1️⃣ 로그인 (서버 접속) 로컬 MySQL 서버에 접속 명령프롬프트 mysql -u root -p C:\\Users\\BITCAMP&gt;mysql -u root -p Enter password: **** Welcome to the MySQL monitor. Commands end with ; or \\g. Your MySQL connection id is 16 Server version: 8.4.2 MySQL Community Server - GPL Copyright (c) 2000, 2024, Oracle and/or its affiliates. Oracle is a registered trademark of Oracle Corporation and/or its affiliates. Other names may be trademarks of their respective owners. Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement. mysql : DBMS 클라이언트 -u : user ID -p : 암호 직접 입력 원격 MySQL 서버에 접속 mysql -h 서버주소 -u root -p mysql root 암호 변경 alter user 'root'@'localhost' identified by '1111'; 서비스 시작 및 종료 명령프롬프트 (관리자 권한 실행) system32$ net stop MySQL84 system32$ net start MySQL84 or (서비스 창에서 start, stop) 2️⃣ DBMS 사용자 등록 똑같은 아이디를 만들 수 있다 호스트   :   접속 허용 서버   (도메인, IP주소, % (All : 외부 모든 서버)) 로컬에서만 접속할 수 있는 사용자를 만들기 CREATE USER 'study'@'localhost' IDENTIFIED BY '1111'; 이 경우 study 사용자는 오직 로컬(서버를 실행하는 컴퓨터)에서만 접속 가능한다. 다른 컴퓨터에서 실행하는 MySQL 서버에 접속할 수 없다는 것을 의미한다. 로그인 $ mysql -u study -p (비번 1111) 원격에서만 접속할 수 있는 사용자를 만들기 CREATE USER 'study'@'%' IDENTIFIED BY '2222'; CREATE USER 'study'@'%' IDENTIFIED BY '1111'; 이 경우 study 사용자는 원격에서만 접속 가능하다. 로그인 $ mysql -h 192.168.0.7 -u study -p (비번 2222) 사용자 교체 &gt; quit (프로그램 종료 후) &gt; mysql -u study -p (다시 실행) 사용자 삭제 $ mysql -u root -p (1111) $ select user, host from mysql.user; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ +------------------+-----------+ | user | host | +------------------+-----------+ | study | % | | mysql.infoschema | localhost | | mysql.session | localhost | | mysql.sys | localhost | | root | localhost | | study | localhost | +------------------+-----------+ $ drop user 'study'@'localhost'; $ drop user 'study'@'%'; $ select user, host from mysql.user; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ +------------------+-----------+ | user | host | +------------------+-----------+ | mysql.infoschema | localhost | | mysql.session | localhost | | mysql.sys | localhost | | root | localhost | +------------------+-----------+ 3️⃣ 데이터베이스 생성&gt; CREATE DATABASE studydb DEFAULT CHARACTER SET utf8 DEFAULT COLLATE utf8_general_ci;&gt; CREATE DATABASE studydb DEFAULT CHARACTER SET utf8 DEFAULT COLLATE utf8_general_ci; Collate   :   문자열 정렬 규칙 utf8_general_ci   :   UTF-8 인데 대소문자 구분 없음 데이터베이스 삭제 &gt; drop database studydb; 4️⃣ 데이터베이스 사용 권한 설정&gt; GRANT ALL ON studydb.* TO 'study'@'localhost';━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Query OK, 0 rows affected (0.01 sec)5️⃣ 데이터베이스 목록 조회 root 사용자의 데이터베이스 $ mysql -u root -p (비번 1111) $ show databases; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ +--------------------+ | Database | +--------------------+ | information_schema | | mysql | | performance_schema | | sakila | | studydb | | sys | | world | +--------------------+ study 사용자의 데이터베이스 $ mysql -u study -p (1111) $ show databases; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ +--------------------+ | Database | +--------------------+ | information_schema | | performance_schema | | studydb | +--------------------+ 6️⃣ 데이터베이스 사용 설정 기본으로 사용할 데이터베이스 지정하기 &gt; use studydb; (이제 부터 쓸거야) 지정하지 않으면 테이블 생성 등을 할 수 없다. 7️⃣ 테이블 목록 조회 기본으로 지정한 데이터베이스의 테이블 &gt; show tables 8️⃣ 테이블 상세 조회&gt; describe 테이블명&gt; desc 테이블명 (실무에서 쓰는 것)9️⃣ 사용자, 호스트 조회 로컬 사용자의 mysql 데이터베이스의 user 테이블 ⇒   현재까지의 사용자를 알 수 있다. $ select user, host from user; ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ +------------------+-----------+ | user | host | +------------------+-----------+ | study | % | | mysql.infoschema | localhost | | mysql.session | localhost | | mysql.sys | localhost | | root | localhost | | study | localhost | +------------------+-----------+** 테이블에서 원하는 컬럼 조회 &gt; select user from 데이터베이스명.테이블명; &gt; select user, host from mysql.user; 현재 데이터베이스면 데이터베이스명 생략 가능 " }, { "title": "MySQL 설치 및 설정", "url": "/posts/mysql-install/", "categories": "코딩 지식, MySQL, 설정", "tags": "MySQL, 설치 및 설정", "date": "2024-11-23 08:08:00 +0900", "snippet": "MySQL 설치 방법MySQL을 설치하는 방법 MySQL 사이트 : https://www.mysql.com/ 메뉴바의 Downloads 클릭   ⇒   MySQL Community (GPL) Downloads 클릭 MySQL Community Server 8.4.3 버전 LTS   ⇒   Wind...", "content": "MySQL 설치 방법MySQL을 설치하는 방법 MySQL 사이트 : https://www.mysql.com/ 메뉴바의 Downloads 클릭   ⇒   MySQL Community (GPL) Downloads 클릭 MySQL Community Server 8.4.3 버전 LTS   ⇒   Windows (x86, 64-bit), MSI Installer 다운로드 “No thanks, just start my download” 클릭   (로그인 필수 아님) 다운로드 받은 MSI Installer 설치 시작   (Complete 버전 설치) MySQL Configurator next ⇒ next ⇒ show advanced and logging options 체크 ⇒ next ⇒ 비밀번호 1111 ⇒ next ⇒ next ⇒ next ⇒ next ⇒ next ⇒ Sample Databases(둘 다 체크하기 (Sakila, World)) ⇒ next ⇒ (다른 버전 있다면 삭제) ⇒ execute 클릭 ⇒ next ⇒ finish MySQL 환경 설정 및 시작하기 (CLI 방식) 명령 프롬프트 $ mysql $ mysql ⇒    (x)   경로를 찾지 못한다. 시스템 환경 변수   ⇒   환경 변수   ⇒   시스템 변수   ⇒   path 새로 만들기   :   C:\\Program Files\\MySQL\\MySQL Server 8.4\\bin 설치된 MySQL 폴더 내부의 bin 폴더 위치 명령 프롬프트 창 닫고 다시 열기 환경 변수를 변경하면 다시 열어야 수정된 환경 변수를 활용할 수 있다. 명령 프롬프트 $ mysql ==&gt; ERROR 1045 (28000): Access denied for user 'ODBC'@'localhost' (using password: NO) 이렇게 나오는 것이 정상이다. 명령 프롬프트 $ mysql -u root -p     (-p   :   비밀번호 직접 입력) $ mysql -u root -p Enter password: **** (설치할 때 설정한 비밀번호 : 1111) Welcome to the MySQL monitor. Commands end with ; or \\g. Your MySQL connection id is 15 Server version: 8.4.2 MySQL Community Server - GPL Copyright (c) 2000, 2024, Oracle and/or its affiliates. Oracle is a registered trademark of Oracle Corporation and/or its affiliates. Other names may be trademarks of their respective owners. Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement. 위의 명령어를 입력하면 비밀번호를 입력하라고 한다. 설치할 때 설정한 비밀번호를 입력하면 접속할 수 있다. 명령 프롬프트 $ quit or $ exit $ quit 나가기 명령어 " }, { "title": "bitcamp-final 프로젝트 배포하기 2", "url": "/posts/final-deploy-2/", "categories": "프로젝트, CICD, Docker", "tags": "Docker, NCP, Server", "date": "2024-11-20 15:08:00 +0900", "snippet": "(7) Docker 엔진 설치설치 준비 파일 목록 업데이트 $ sudo yum update [student@bitcamp-svr1 ~]$ sudo yum update [sudo] password for student: Loaded plugins: fastestmirror, langpacks ... ...", "content": "(7) Docker 엔진 설치설치 준비 파일 목록 업데이트 $ sudo yum update [student@bitcamp-svr1 ~]$ sudo yum update [sudo] password for student: Loaded plugins: fastestmirror, langpacks ... Updated: epel-release.noarch 0:7-14 Complete! apt get 기본적으로 Debian과 Ubuntu 계열의 리눅스 시스템에서 사용하는 패키지 관리 도구 apt-get install &lt;패키지명&gt; [student@bitcamp-svr1 ~]$ chmod 0755 /usr/local/bin/apt-get chmod: changing permissions of ‘/usr/local/bin/apt-get’: Operation not permitted [student@bitcamp-svr1 ~]$ sudo curl https://raw.githubusercontent.com/dvershinin/apt-get-centos/master/apt-get.sh -o /usr/local/bin/apt-get % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 100 1256 100 1256 0 0 1852 0 --:--:-- --:--:-- --:--:-- 1849 [student@bitcamp-svr1 ~]$ sudo chmod 0755 /usr/local/bin/apt-get 기존에 설치된 Docker 제거 sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine [student@bitcamp-svr1 ~]$ sudo yum remove docker \\ &gt; docker-client \\ &gt; docker-client-latest \\ &gt; docker-common \\ &gt; docker-latest \\ &gt; docker-latest-logrotate \\ &gt; docker-logrotate \\ &gt; docker-engine [sudo] password for student: Loaded plugins: fastestmirror, langpacks No Match for argument: docker No Match for argument: docker-client No Match for argument: docker-client-latest No Match for argument: docker-common No Match for argument: docker-latest No Match for argument: docker-latest-logrotate No Match for argument: docker-logrotate No Match for argument: docker-engine No Packages marked for removal \\ 는 옆으로 나열하지 않고 줄바꿈하는 방법 Docker의 공식 리포지토리 추가 set up the repo (docker) Docker 설치 파일을 받기 위한 저장소 등록 Docker는 소프트웨어 컨테이너를 관리하기 위한 도구 CentOS에서 Docker를 설치하려면 Docker의 공식 리포지토리를 시스템에 추가해야 한다. yum-utils는 YUM 패키지 관리자의 여러 유용한 도구들을 포함한 패키지로, YUM 리포지토리를 관리하는 데 필요한 여러 기능을 제공 Docker의 공식 리포지토리를 CentOS에 추가 [student@bitcamp-svr1 ~]$ sudo yum install -y yum-utils Loaded plugins: fastestmirror, langpacks Loading mirror speeds from cached hostfile * epel: repo.jing.rocks Package yum-utils-1.1.31-54.el7_8.noarch already installed and latest version Nothing to do [student@bitcamp-svr1 ~]$ sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo Loaded plugins: fastestmirror, langpacks adding repo from: https://download.docker.com/linux/centos/docker-ce.repo grabbing file https://download.docker.com/linux/centos/docker-ce.repo to /etc/yum.repos.d/docker-ce.repo repo saved to /etc/yum.repos.d/docker-ce.repo Docker Engine 설치 $ sudo yum install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin [student@bitcamp-svr1 ~]$ sudo yum install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin Loaded plugins: fastestmirror, langpacks Loading mirror speeds from cached hostfile * epel: repo.jing.rocks ... Complete! Docker engine 시작 $ sudo systemctl start docker [student@bitcamp-svr1 ~]$ sudo systemctl start docker Docker 설치 확인 $ sudo docker run hello-world [student@bitcamp-svr1 ~]$ sudo docker run hello-world Unable to find image 'hello-world:latest' locally latest: Pulling from library/hello-world c1ec31eb5944: Pull complete Digest: sha256:d211f485f2dd1dee407a80973c8f129f00d54604d2c90732e8e320e5038a0348 Status: Downloaded newer image for hello-world:latest Hello from Docker! This message shows that your installation appears to be working correctly. To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal. To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bash Share images, automate workflows, and more with a free Docker ID: https://hub.docker.com/ For more examples and ideas, visit: https://docs.docker.com/get-started/ (8) Docker 컨테이너 생성 및 실행도커 컨테이너 생성 및 실행 우분투 14.04 컨테이너 생성 $ sudo docker run -i -t ubuntu:14.04 [student@bitcamp-svr1 ~]$ sudo docker run -i -t ubuntu:14.04 Unable to find image 'ubuntu:14.04' locally 14.04: Pulling from library/ubuntu 2e6e20c8e2e6: Pull complete 0551a797c01d: Pull complete 512123a864da: Pull complete Digest: sha256:64483f3496c1373bfd55348e88694d1c4d0c9b660dee6bfef5e12f43b9933b30 Status: Downloaded newer image for ubuntu:14.04 root@afe8ed187221:/# 컨테이너에 접속한 상태이다. (root@afe8ed187221:/#) root@afe8ed187221:/# whoami root root@afe8ed187221:/# hostname afe8ed187221 root@afe8ed187221:/# ls bin dev home lib64 mnt proc run srv tmp var boot etc lib media opt root sbin sys usr 컨테이너 나가기 (# exit, or ctrl + D) ⇒ 다시 리눅스 서버로 돌아온다. ⇒ 헷갈리면 안된다. 우리는 현재 리눅스 서버에 접속한 상태에서 컨테이너에 접속한 것이다. ★ 단, 컨테이너를 나갈 때 컨테이너도 종료된다. 도커 이미지 목록 확인하기 $ sudo docker images 현재 Docker 시스템에 다운로드되어 있는 이미지 목록 [student@bitcamp-svr1 ~]$ sudo docker images REPOSITORY TAG IMAGE ID CREATED SIZE hello-world latest d2c94e258dcb 18 months ago 13.3kB ubuntu 14.04 13b66b487594 3 years ago 197MB 도커 이미지 내려받기 (centos:7) $ sudo docker pull centos:7 [student@bitcamp-svr1 ~]$ sudo docker pull centos:7 7: Pulling from library/centos 2d473b07cdd5: Pull complete Digest: sha256:be65f488b7764ad3638f236b7b515b3678369a5124c47b8d32916d6487418ea4 Status: Downloaded newer image for centos:7 docker.io/library/centos:7 [student@bitcamp-svr1 ~]$ sudo docker images REPOSITORY TAG IMAGE ID CREATED SIZE hello-world latest d2c94e258dcb 18 months ago 13.3kB centos 7 eeb6ee3f44bd 3 years ago 204MB ubuntu 14.04 13b66b487594 3 years ago 197MB 도커 이미지로 컨테이너 생성하기 $ sudo docker create -i -t --name mycentos centos:7 [student@bitcamp-svr1 ~]$ sudo docker create -i -t --name mycentos centos:7 7d357dfeb0f6f7193ba11ea9e8306fe8bf9a159018182aefee82a1c76a323a96 (컨테이너의 고유 ID) 도커 컨테이너 목록 보기 $ sudo docker ps $ sudo docker ps -a [student@bitcamp-svr1 ~]$ sudo docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES [student@bitcamp-svr1 ~]$ sudo docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 7d357dfeb0f6 centos:7 \"/bin/bash\" 45 seconds ago Created mycentos f1079aa5ffc1 ubuntu:14.04 \"/bin/bash\" 11 minutes ago Exited (1) 8 minutes ago laughing_haibt afe8ed187221 ubuntu:14.04 \"/bin/bash\" 19 minutes ago Exited (0) 12 minutes ago serene_shtern 49cc738cd62f hello-world \"/hello\" 23 minutes ago Exited (0) 23 minutes ago charming_shirley name을 지정하지 않으면 아무 2개 단어로 만든다. $ sudo docker ps -a : 전체 컨테이너 출력 $ sudo docker ps : 현재 실행 중인 것만 나온다. CONTAINER ID : 컨테이너에 자동 할당되는 고유한 ID. $ sudo docker inspect 컨테이너이름 | grep Id : 컨테이너 ID 전체 보기 IMAGE : 컨테이너 이미지 이름 COMMAND : 컨테이너가 시작될 때 실행될 명령 CREATED : 컨테이너가 생성된 후 흐른 시간 STATUS : 컨테이너 상태 ( Up(실행중), Exited(종료), Pause(중지) ) PORTS : 컨테이너가 개방한 포트와 호스트에 연결한 포트 외부에 노출하도록 설정하지 않았다면 출력 내용 없음 NAMES : 컨테이너의 고유한 이름 --name 옵션으로 설정한 이름. 설정하지 않으면 형용사와 명사를 사용해 무작위 생성 $ sudo docker rename 무작위이름 새이름 도커 컨테이너 실행하기 $ sudo docker start mycentos $ sudo docker start 해시아이디일부분 [student@bitcamp-svr1 ~]$ sudo docker start mycentos mycentos [student@bitcamp-svr1 ~]$ sudo docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 7d357dfeb0f6 centos:7 \"/bin/bash\" 5 minutes ago Up 55 seconds mycentos f1079aa5ffc1 ubuntu:14.04 \"/bin/bash\" 16 minutes ago Exited (1) 13 minutes ago laughing_haibt afe8ed187221 ubuntu:14.04 \"/bin/bash\" 23 minutes ago Exited (0) 16 minutes ago serene_shtern 49cc738cd62f hello-world \"/hello\" 28 minutes ago Exited (0) 28 minutes ago charming_shirley [student@bitcamp-svr1 ~]$ sudo docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 7d357dfeb0f6 centos:7 \"/bin/bash\" 5 minutes ago Up About a minute mycentos 도커 컨테이너에 접속하기 $ sudo docker attach mycentos [student@bitcamp-svr1 ~]$ sudo docker attach mycentos [root@7d357dfeb0f6 /]# [root@7d357dfeb0f6 /]# exit exit [student@bitcamp-svr1 ~]$ sudo docker attach mycentos You cannot attach to a stopped container, start it first [student@bitcamp-svr1 ~]$ sudo docker start mycentos mycentos [student@bitcamp-svr1 ~]$ sudo docker attach mycentos [root@7d357dfeb0f6 /]# [root@7d357dfeb0f6 /]# read escape sequence (ctrl + p, ctrl + q) [student@bitcamp-svr1 ~]$ sudo docker attach mycentos [root@7d357dfeb0f6 /]# exit로 나가면 컨테이너를 종료한다. ⇒ ctrl + P ⇒ ctrl + Q 로 단순히 컨테이너 쉘만 빠져나간다. (실행 유지) ★ 한방에 모든 과정을 끝내는 법 docker run -i -t ★ 이미지 없으면 docker pull docker create -i -t docker start docker attach : -i -t 옵션을 사용했을 때 docker create 이미지 없으면 docker pull 도커 컨테이너 rename $ sudo docker rename 무작위이름 새이름 [student@bitcamp-svr1 ~]$ sudo docker rename charming_shirley hello [student@bitcamp-svr1 ~]$ sudo docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 7d357dfeb0f6 centos:7 \"/bin/bash\" 30 minutes ago Up 22 minutes mycentos f1079aa5ffc1 ubuntu:14.04 \"/bin/bash\" 41 minutes ago Exited (1) 38 minutes ago laughing_haibt afe8ed187221 ubuntu:14.04 \"/bin/bash\" 49 minutes ago Exited (0) 42 minutes ago serene_shtern 49cc738cd62f hello-world \"/hello\" 54 minutes ago Exited (0) About a minute ago hello 도커 컨테이너 삭제하기 $ sudo docker rm 컨테이너이름 [student@bitcamp-svr1 ~]$ sudo docker rm serene_shtern serene_shtern [student@bitcamp-svr1 ~]$ sudo docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 7d357dfeb0f6 centos:7 \"/bin/bash\" 31 minutes ago Up 23 minutes mycentos f1079aa5ffc1 ubuntu:14.04 \"/bin/bash\" 42 minutes ago Exited (1) 39 minutes ago laughing_haibt 49cc738cd62f hello-world \"/hello\" 54 minutes ago Exited (0) 2 minutes ago hello 실행 중인 것은 멈추고 삭제해야 한다. $ sudo docker stop 컨테이너이름 [student@bitcamp-svr1 ~]$ sudo docker stop mycentos mycentos [student@bitcamp-svr1 ~]$ sudo docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 7d357dfeb0f6 centos:7 \"/bin/bash\" 32 minutes ago Exited (137) 2 seconds ago mycentos f1079aa5ffc1 ubuntu:14.04 \"/bin/bash\" 43 minutes ago Exited (1) 40 minutes ago laughing_haibt 49cc738cd62f hello-world \"/hello\" 55 minutes ago Exited (0) 3 minutes ago hello [student@bitcamp-svr1 ~]$ sudo docker rm mycentos mycentos [student@bitcamp-svr1 ~]$ sudo docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES f1079aa5ffc1 ubuntu:14.04 \"/bin/bash\" 43 minutes ago Exited (1) 40 minutes ago laughing_haibt 49cc738cd62f hello-world \"/hello\" 55 minutes ago Exited (0) 3 minutes ago hello 실행 중인 것도 강제 삭제하기 $ sudo docker rm -f 컨테이너명 [student@bitcamp-svr1 ~]$ sudo docker rm -f mycentos2 mycentos2 [student@bitcamp-svr1 ~]$ sudo docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES f1079aa5ffc1 ubuntu:14.04 \"/bin/bash\" 45 minutes ago Exited (1) 42 minutes ago laughing_haibt 49cc738cd62f hello-world \"/hello\" 57 minutes ago Exited (0) 5 minutes ago hello 정지된 모든 컨테이너 삭제 $ sudo docker container prune [student@bitcamp-svr1 ~]$ sudo docker container prune WARNING! This will remove all stopped containers. Are you sure you want to continue? [y/N] y Deleted Containers: f1079aa5ffc19014f4da63d1d1df4677bece49f3e6b6650d05f3fb6fbad0d0fd 49cc738cd62f5a140a2244eb2fc2666bdaf4e0e7f820bd40106e644fd6748077 Total reclaimed space: 24B [student@bitcamp-svr1 ~]$ sudo docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES (8-1) 외부에서 컨테이너 접속하기 현재는 도커가 설치된 호스트만 접속 가능한데 외부에서도 접속할 수 있게 설정ubuntu 컨테이너를 만들고 시작 $ sudo docker run -i -t --name network_test ubuntu:14.04 [student@bitcamp-svr1 ~]$ sudo docker run -i -t --name network_test ubuntu:14.04 root@4fa012018bab:/# root@4fa012018bab:/# ifconfig eth0 Link encap:Ethernet HWaddr 02:42:ac:11:00:02 inet addr:172.17.0.2 Bcast:172.17.255.255 Mask:255.255.0.0 UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:0 errors:0 dropped:0 overruns:0 frame:0 TX packets:1 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:0 RX bytes:0 (0.0 B) TX bytes:42 (42.0 B) lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 inet6 addr: ::1/128 Scope:Host UP LOOPBACK RUNNING MTU:65536 Metric:1 RX packets:1 errors:0 dropped:0 overruns:0 frame:0 TX packets:1 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:28 (28.0 B) TX bytes:28 (28.0 B) # ifconfig : 현재 이 컨테이너의 IP address 나온다. 컨테이너에 아파치 설치하기 # apt install apache2 root@4fa012018bab:/# apt install apache2 Reading package lists... Done Building dependency tree Reading state information... Done The following extra packages will be installed: ..... 아파치 실행 # service apache2 start root@4fa012018bab:/# service apache2 status * apache2 is not running root@4fa012018bab:/# service apache2 start * Starting web server apache2 테스트 root@4fa012018bab:/# apt install curl Reading package lists... Done Building dependency tree Reading state information... Done The following extra packages will be installed: libcurl3 The following NEW packages will be installed: curl libcurl3 0 upgraded, 2 newly installed, 0 to remove and 0 not upgraded. Need to get 295 kB of archives. After this operation, 871 kB of additional disk space will be used. Do you want to continue? [Y/n] y ... ... root@4fa012018bab:/# curl http://www.naver.com &lt;html&gt; &lt;head&gt;&lt;title&gt;302 Found&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;center&gt;&lt;h1&gt;302 Found&lt;/h1&gt;&lt;/center&gt; &lt;hr&gt;&lt;center&gt; NWS &lt;/center&gt; &lt;/body&gt; &lt;/html&gt; curl CLI용 HTTP 클라이언트로, HTTP/HTTPS 요청을 보내고 응답을 받을 수 있는 도구 # curl localhost / $ curl 172.17.0.2 root@4fa012018bab:/# curl localhost &lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt; &lt;html xmlns=\"http://www.w3.org/1999/xhtml\"&gt; &lt;!-- Modified from the Debian original for Ubuntu Last updated: 2014-03-19 See: https://launchpad.net/bugs/1288690 --&gt; &lt;head&gt; .... 리눅스에서 만들었으므로 DOCKER에 당연히 접속 가능 외부에서 컨테이너 접속하기 리눅스 서버 공인 IP (NCP) [student@bitcamp-svr1 ~]$ sudo docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 4fa012018bab ubuntu:14.04 \"/bin/bash\" 19 minutes ago Up 19 minutes network_test [student@bitcamp-svr1 ~]$ curl 172.17.0.2 리눅스 서버에서 현재 컨테이너에 접속이 되는데 외부에서는 안 된다. ⇒ 포트 포워딩이 필요하다. (8-2) 포트 포워딩포트 포워딩 컨테이너를 만들 때 옵션을 지정해야 한다. $ sudo docker run -i -t --name 컨테이너이름 -p 80:80 ubuntu:14.04 ⇒ 리눅스 서버에 접속하면 컨테이너에 전달하도록 [student@bitcamp-svr1 ~]$ sudo docker run -i -t --name network_test2 -p 80:80 ubuntu:14.04 [sudo] password for student: root@7bb74ebaa03b:/# # apt install apache2 # service apache2 start ctrl P, ctrl q [student@bitcamp-svr1 ~]$ sudo docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 7bb74ebaa03b ubuntu:14.04 \"/bin/bash\" About a minute ago Up About a minute 0.0.0.0:80-&gt;80/tcp network_test2 4fa012018bab ubuntu:14.04 \"/bin/bash\" 26 minutes ago Up 26 minutes network_test ⇒ host에 80 포트로 오면 컨테이너의 80번 포트로 전달하라. 인터렉션(-i 옵션)을 하지 않으면 시작하자 마자 exited 된다. 다시 브라우저를 열고 101.79.10.151 열기 이번엔 8888 포트를 80포트로 연결하기 (위의 과정 반복) 브라우저에서 http://101.79.10.151:8888/ $ curl ip.me로 서버 IP 주소를 알아낼 수 있다. index.html 직접 수정하기 # cd var/www/html # sudo vi index.html root@b39f2c13ef55:/# cd var/www/html root@b39f2c13ef55:/var/www/html# sudo nano index.html sudo: nano: command not found (nano editor가 없음) root@b39f2c13ef55:/var/www/html# sudo vi index.html (수정 작업 하기 esc + a) 8888 포트로 들어온 사이트를 수정한 것 도커가 바인딩된 포트번호 확인하기 $ sudo docker port 컨테이너이름 [student@bitcamp-svr1 ~]$ sudo docker port network_test (바인딩도니 포트번호가 없으므로) [student@bitcamp-svr1 ~]$ sudo docker port network_test2 80/tcp -&gt; 0.0.0.0:80 [student@bitcamp-svr1 ~]$ sudo docker port network_test3 80/tcp -&gt; 0.0.0.0:8888 (컨테이너) (호스트) 다른 방법으로 컨테이너에 접속하기 $ sudo docker exec -i -t 컨테이너명 /bin/bash [student@bitcamp-svr1 ~]$ sudo docker exec -i -t mycentos /bin/bash root@ea73d30ab8ea:/# attach와 결과는 동일하다. Detached 모드로 컨테이너의 내부 셸을 사용하기 $ sudo docker exec 컨테이너명 명령어 접속을 하지 않고 컨테이너에 명령 넣기 ⇒ 컨테이너는 결과를 host os에 리턴한다. [student@bitcamp-svr1 ~]$ sudo docker exec mycentos ls bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var [student@bitcamp-svr1 ~]$ sudo docker exec mycentos ls -al total 4 drwxr-xr-x 1 root root 6 Nov 7 05:22 . drwxr-xr-x 1 root root 6 Nov 7 05:22 .. -rwxr-xr-x 1 root root 0 Nov 7 05:22 .dockerenv drwxr-xr-x 2 root root 4096 Dec 17 2019 bin drwxr-xr-x 2 root root 6 Apr 10 2014 boot drwxr-xr-x 5 root root 360 Nov 7 05:22 dev drwxr-xr-x 1 root root 66 Nov 7 05:22 etc drwxr-xr-x 2 root root 6 Apr 10 2014 home drwxr-xr-x 12 root root 208 Dec 17 2019 lib drwxr-xr-x 2 root root 34 Dec 17 2019 lib64 drwxr-xr-x 2 root root 6 Dec 17 2019 media drwxr-xr-x 2 root root 6 Apr 10 2014 mnt drwxr-xr-x 2 root root 6 Dec 17 2019 opt dr-xr-xr-x 141 root root 0 Nov 7 05:22 proc drwx------ 2 root root 37 Dec 17 2019 root drwxr-xr-x 1 root root 21 Mar 25 2021 run drwxr-xr-x 1 root root 44 Mar 25 2021 sbin drwxr-xr-x 2 root root 6 Dec 17 2019 srv dr-xr-xr-x 13 root root 0 Nov 7 05:22 sys drwxrwxrwt 2 root root 6 Dec 17 2019 tmp drwxr-xr-x 1 root root 18 Dec 17 2019 usr drwxr-xr-x 1 root root 17 Dec 17 2019 var (9) bitcamp-final 웹 애플리케이션 컨테이너 생성 쓸모없는 것 제거 [student@bitcamp-svr-final ~]$ sudo docker container prune WARNING! This will remove all stopped containers. Are you sure you want to continue? [y/N] y Deleted Containers: cb7242e92e05b1b870af538ed311932dc3c2f0d4455300ae674f1df8d5d013ad 1252c24fd0a43f4829ebbf4ea40de8df96be9234c1d8970f332e7b5274b379aa 14a8c9099f593449cdb93c8682633ce1e76894337fe31ca017581d70c363202a a4f3d6a4d499d51e636f171e900b34671a16dd2a6dc4912e88688816ef1c7b14 Total reclaimed space: 69B [student@bitcamp-svr-final ~]$ sudo docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ubuntu 최신 버전 이미지로 컨테이너 생성** Ubuntu 22.04 컨테이너 생성 및 실행 $ sudo docker run -p 8080:8080 -it --name bitcamp-final ubuntu [student@bitcamp-svr-final ~]$ sudo docker run -p 8080:8080 -it --name bitcamp-final ubuntu Unable to find image 'ubuntu:latest' locally latest: Pulling from library/ubuntu ff65ddf9395b: Pull complete Digest: sha256:99c35190e22d294cdace2783ac55effc69d32896daaa265f0bbedbcde4fbe3e5 Status: Downloaded newer image for ubuntu:latest root@506a7a2a9ecb:/# [student@bitcamp-svr-final ~]$ sudo docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 506a7a2a9ecb bitcamp-final:first \"/bin/bash\" 2 days ago Up 2 seconds 0.0.0.0:8080-&gt;8080/tcp bitcamp-final -i -t = -it 다시 서버로 나가서 컨테이너 상태 확인 재접속 후 # apt update $ sudo docker exec -it bitcamp-final /bin/bash 컨테이너에서 # apt update [student@bitcamp-svr-final ~]$ sudo docker exec -it bitcamp-final /bin/bash root@506a7a2a9ecb:/# apt update Get:1 http://archive.ubuntu.com/ubuntu noble InRelease [256 kB] Get:2 http://security.ubuntu.com/ubuntu noble-security InRelease [126 kB] Get:3 http://security.ubuntu.com/ubuntu noble-security/multiverse amd64 Packages [15.3 kB] Get:4 http://security.ubuntu.com/ubuntu noble-security/universe amd64 Packages [720 kB] Get:5 http://archive.ubuntu.com/ubuntu noble-updates InRelease [126 kB] Get:6 http://archive.ubuntu.com/ubuntu noble-backports InRelease [126 kB] Get:7 http://security.ubuntu.com/ubuntu noble-security/restricted amd64 Packages [537 kB] Get:8 http://security.ubuntu.com/ubuntu noble-security/main amd64 Packages [574 kB] Get:9 http://archive.ubuntu.com/ubuntu noble/multiverse amd64 Packages [331 kB] Get:10 http://archive.ubuntu.com/ubuntu noble/restricted amd64 Packages [117 kB] Get:11 http://archive.ubuntu.com/ubuntu noble/main amd64 Packages [1808 kB] Get:12 http://archive.ubuntu.com/ubuntu noble/universe amd64 Packages [19.3 MB] Get:13 http://archive.ubuntu.com/ubuntu noble-updates/universe amd64 Packages [922 kB] Get:14 http://archive.ubuntu.com/ubuntu noble-updates/restricted amd64 Packages [542 kB] Get:15 http://archive.ubuntu.com/ubuntu noble-updates/multiverse amd64 Packages [18.4 kB] Get:16 http://archive.ubuntu.com/ubuntu noble-updates/main amd64 Packages [792 kB] Get:17 http://archive.ubuntu.com/ubuntu noble-backports/universe amd64 Packages [11.8 kB] Fetched 26.3 MB in 7s (3805 kB/s) Reading package lists... Done Building dependency tree... Done Reading state information... Done 3 packages can be upgraded. Run 'apt list --upgradable' to see them. 기타 프로그램 추가 및 설정 ifconfig 등 네트워킹 관련 프로그램 추가 # apt update # apt install net-tools nano 에디터 설치 # apt install nano JDK 설치 # apt install openjdk-21-jdk -y JAVA_HOME 환경 변수 설정 root@506a7a2a9ecb:/# ls -al /usr/lib/jvm total 8 drwxr-xr-x 4 root root 126 Nov 7 16:36 . drwxr-xr-x 1 root root 4096 Nov 7 16:36 .. -rw-r--r-- 1 root root 1840 Jul 23 10:34 .java-1.21.0-openjdk-amd64.jinfo lrwxrwxrwx 1 root root 21 Jul 23 10:34 java-1.21.0-openjdk-amd64 -&gt; java-21-openjdk-amd64 drwxr-xr-x 9 root root 119 Nov 7 16:36 java-21-openjdk-amd64 drwxr-xr-x 2 root root 21 Nov 7 16:36 openjdk-21 root@506a7a2a9ecb:/# echo 'export JAVA_HOME=/usr/lib/jvm/java-21-openjdk-amd64' | tee -a /etc/bash.bashrc export JAVA_HOME=/usr/lib/jvm/java-21-openjdk-amd64 root@506a7a2a9ecb:/# cat /etc/bash.bashrc (확인하는 것) # System-wide .bashrc file for interactive bash(1) shells. # To enable the settings / commands in this file for login shells as well, # this file has to be sourced in /etc/profile. # If not running interactively, don't do anything [ -z \"$PS1\" ] &amp;&amp; return # check the window size after each command and, if necessary, # update the values of LINES and COLUMNS. shopt -s checkwinsize # set variable identifying the chroot you work in (used in the prompt below) if [ -z \"${debian_chroot:-}\" ] &amp;&amp; [ -r /etc/debian_chroot ]; then debian_chroot=$(cat /etc/debian_chroot) fi # set a fancy prompt (non-color, overwrite the one in /etc/profile) # but only if not SUDOing and have SUDO_PS1 set; then assume smart user. if ! [ -n \"${SUDO_USER}\" -a -n \"${SUDO_PS1}\" ]; then PS1='${debian_chroot:+($debian_chroot)}\\u@\\h:\\w\\$ ' fi # Commented out, don't overwrite xterm -T \"title\" -n \"icontitle\" by default. # If this is an xterm set the title to user@host:dir #case \"$TERM\" in #xterm*|rxvt*) # PROMPT_COMMAND='echo -ne \"\\033]0;${USER}@${HOSTNAME}: ${PWD}\\007\"' # ;; #*) # ;; #esac # enable bash completion in interactive shells #if ! shopt -oq posix; then # if [ -f /usr/share/bash-completion/bash_completion ]; then # . /usr/share/bash-completion/bash_completion # elif [ -f /etc/bash_completion ]; then # . /etc/bash_completion # fi #fi # sudo hint if [ ! -e \"$HOME/.sudo_as_admin_successful\" ] &amp;&amp; [ ! -e \"$HOME/.hushlogin\" ] ; then case \" $(groups) \" in *\\ admin\\ *|*\\ sudo\\ *) if [ -x /usr/bin/sudo ]; then cat &lt;&lt;-EOF To run a command as administrator (user \"root\"), use \"sudo &lt;command&gt;\". See \"man sudo_root\" for details. EOF fi esac fi # if the command-not-found package is installed, use it if [ -x /usr/lib/command-not-found -o -x /usr/share/command-not-found/command-not-found ]; then function command_not_found_handle { # check because c-n-f could've been removed in the meantime if [ -x /usr/lib/command-not-found ]; then /usr/lib/command-not-found -- \"$1\" return $? elif [ -x /usr/share/command-not-found/command-not-found ]; then /usr/share/command-not-found/command-not-found -- \"$1\" return $? else printf \"%s: command not found\\n\" \"$1\" &gt;&amp;2 return 127 fi } fi export JAVA_HOME=/usr/lib/jvm/java-21-openjdk-amd64 이렇게 맨 마지막에 들어가는 것을 확인할 수 있다. export JAVA_HOME=/usr/lib/jvm/java-21-openjdk-amd64 환경 변수 설정 적용 후 확인 root@506a7a2a9ecb:/# source /etc/bash.bashrc root@506a7a2a9ecb:/# echo $JAVA_HOME /usr/lib/jvm/java-21-openjdk-amd64 git 설치 # apt install git -y # apt install git -y root@506a7a2a9ecb:/# git --version git version 2.43.0 wget 설치 # apt install wget -y unzip 설치 # apt install unzip -y bitcamp-final 저장소 복제 후 빌드 및 실행 bitcamp-fianl git 저장소 가져오기 # git clone … root@506a7a2a9ecb:/# cd root@506a7a2a9ecb:/# pwd /root root@506a7a2a9ecb:/# mkdir git root@506a7a2a9ecb:/# cd git root@506a7a2a9ecb:/#:~/git# git clone https://github.com/backnback/bitcamp-final Cloning into 'bitcamp-final'... remote: Enumerating objects: 98, done. remote: Counting objects: 100% (98/98), done. remote: Compressing objects: 100% (71/71), done. remote: Total 98 (delta 15), reused 95 (delta 15), pack-reused 0 (from 0) Receiving objects: 100% (98/98), 77.82 KiB | 2.51 MiB/s, done. Resolving deltas: 100% (15/15), done. 빌드 후 실행하기 root@506a7a2a9ecb:~/git/bitcamp-final# ./gradlew build bash: ./gradlew: Permission denied root@506a7a2a9ecb:~/git/bitcamp-final# chmod 755 ./gradlew root@506a7a2a9ecb:~/git/bitcamp-final# ./gradlew build Downloading https://services.gradle.org/distributions/gradle-8.10.2-bin.zip .... root@506a7a2a9ecb:~/git/bitcamp-final# java -jar ./app/build/libs/bitcamp-final.jar 실행이 되지 않는다. ⇒ final.properties 과 email.properties 추가 필요 final.properties 과 email.properties 추가 후 재실행 root@506a7a2a9ecb:~/git/bitcamp-final# cd root@506a7a2a9ecb:~# mkdir config root@506a7a2a9ecb:~# cd config root@506a7a2a9ecb:~/config# nano final.properties root@506a7a2a9ecb:~/config# nano email.properties root@506a7a2a9ecb:~/config# cd root@506a7a2a9ecb:~# cd git/bitcamp-final root@506a7a2a9ecb:~/git/bitcamp-final# java -jar ./app/build/libs/bitcamp-final.jar (10) 컨테이너로 이미지 생성컨테이너를 그대로 이미지로 만들기 $ sudo docker commit 옵션 컨테이너명 REPOSITORY:TAG $ sudo docker commit -a \"alicek106\" -m \"my first commit\" commit_test commit_test:first -a author : 이미지 작성자에 대한 정보를 이미지에 포함시킨다. -m 커밋메시지 : 이미지에 포함될 부가 설명을 설정한다. root@506a7a2a9ecb:~/git/bitcamp-final# cd root@506a7a2a9ecb:~# exit exit [student@bitcamp-svr-final ~]$ sudo docker commit -a \"backnback\" -m \"my first commit\" bitcamp-final bitcamp-final:first sha256:73.... [student@bitcamp-svr-final ~]$ sudo docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE bitcamp-final first 73..... 15 seconds ago 1...GB wordpress latest 4c9b15c9a8ae 3 weeks ago 697MB ubuntu latest 59ab366372d5 3 weeks ago 78.1MB mysql 5.7 5107333e08a8 11 months ago 501MB hello-world latest d2c94e258dcb 18 months ago 13.3kB centos 7 eeb6ee3f44bd 3 years ago 204MB ubuntu 14.04 13b66b487594 3 years ago 197MB alicek106/volume_test latest 342a67bc9486 8 years ago 197MB 만든 이미지로 컨테이너 만들기 $ sudo docker run -i -t --name commit_test2 commit_test:first 컨테이너 변경 : # echo test_second! &gt;&gt; second [student@bitcamp-svr-final ~]$ sudo docker stop bitcamp-final bitcamp-final [student@bitcamp-svr-final ~]$ sudo docker run -i -t --name bitcamp-fianl2 -p 8081:8080 bitcamp-final:first ctrl + P ⇒ ctrl + Q 를 하면 종료 안하고 서버로 갈 수 있다. 서버를 여러 개 띄울 수 있다. " }, { "title": "bitcamp-final 프로젝트 배포하기 1", "url": "/posts/final-deploy-1/", "categories": "프로젝트, CICD, Docker", "tags": "Docker, NCP, Server", "date": "2024-11-20 15:08:00 +0900", "snippet": "(1) 배포 파일 생성 및 실행 확인build.gradle 변경 스프링부트 실행 jar 파일을 만들 때 파일명 설정 jar 태스크를 수행하지 않게 설정 [build.gradle] plugins { id 'java' id 'org.springframework.boot' version '2.7.18' id...", "content": "(1) 배포 파일 생성 및 실행 확인build.gradle 변경 스프링부트 실행 jar 파일을 만들 때 파일명 설정 jar 태스크를 수행하지 않게 설정 [build.gradle] plugins { id 'java' id 'org.springframework.boot' version '2.7.18' id 'io.spring.dependency-management' version '1.1.6' } ... // 스프링부트 실행 jar 파일을 만들 때 파일명 설정 bootJar { archiveFileName = \"${rootProject.name}.jar\" } // jar 태스크를 수행하지 않게 설정 tasks.named(\"jar\") { enabled = false } ... Gradle 명령어 $ gradle help --task bootJar 특정 태스크(bootJar)에 대한 도움말 출력 $ gradle build --console=plain 프로젝트 빌드 C:\\Users\\river\\git\\bitcamp-final\\app\\build\\libs에 bitcamp-final.jar 생긴다. (settings.gradle의 rootProject.name을 설정한대로) --console=plain : 출력 형식 = 평문 설정 (깔끔하게 로그 확인) river@BOOK-VKBCE9E5R0 MINGW64 ~/git/bitcamp-final (backnback) $ gradle build --console=plain &gt; Task :app:compileJava UP-TO-DATE &gt; Task :app:processResources UP-TO-DATE &gt; Task :app:classes UP-TO-DATE &gt; Task :app:bootJarMainClassName UP-TO-DATE &gt; Task :app:bootJar UP-TO-DATE &gt; Task :app:jar SKIPPED &gt; Task :app:assemble UP-TO-DATE &gt; Task :app:compileTestJava UP-TO-DATE &gt; Task :app:processTestResources UP-TO-DATE &gt; Task :app:testClasses UP-TO-DATE &gt; Task :app:test UP-TO-DATE &gt; Task :app:check UP-TO-DATE &gt; Task :app:build UP-TO-DATE BUILD SUCCESSFUL in 1s 7 actionable tasks: 7 up-to-date Jar 파일 실행하기 $ java -jar bitcamp-final.jar river@BOOK-VKBCE9E5R0 MINGW64 ~/git/bitcamp-final (backnback) $ cd app/build/libs river@BOOK-VKBCE9E5R0 MINGW64 ~/git/bitcamp-final/app/build/libs (backnback) $ ls bitcamp-final.jar river@BOOK-VKBCE9E5R0 MINGW64 ~/git/bitcamp-final/app/build/libs (backnback) $ java -jar bitcamp-final.jar 만약 .env 파일이 존재하는 경우 ~/git/bitcamp-final/app/build/libs에서 JAR 파일을 실행시킨다면 .env 파일을 현재 위치에서 찾아서 오류가 발생한다. .env 파일이 존재하는 Root 디렉토리에서 JAR 파일을 실행시킨다. java -jar ./app/build/libs/bitcamp-final.jar 단, JAR 파일로 실행 시 정적 파일을 올바르게 로드할 수 있도록 ⇒   즉, 기본 경로를 사용하기 위해서 application.properties에 아래 코드가 있다면 주석 처리 spring.web.resources.static-locations=file:src/main/resources/static 정적 리소스(static resources)의 위치를 명시적으로 지정 주석 처리 시, Spring Boot는 기본적으로 /static, /public, /resources, /META-INF/resources 디렉토리에서 정적 리소스를 검색 애플리케이션이 실행되는 환경에 따라 해당 파일 경로가 유효하지 않을 수 있기 때문이다. (2) 스프링부트 설정 파일을 개발과 운영으로 분리개발 모드와 운영 모드를 분리 application-prod.properties application-dev.properties실행 옵션 JVM 아규먼트   :   -Dspring.profiles.active=dev 예) $ java -Dspring.profiles.active=dev -jar bitcamp-final.jar 예) Gradle : 환경변수를 통해 설정 $ export SPRING_PROFILES_ACTIVE=dev $ gradle bootRun 예) IntelliJ : 환경변수를 통해 설정한다. bootRun   ⇒   구성   ⇒   편집 : spring.profiles.active=dev 프로그램 아규먼트   :   --spring.profiles.active=dev 예) $ java -jar bitcamp-final.jar --spring.profiles.active=prod 예) $ gradle bootRun --args='--spring.profiles.active=dev' intelliJ 에서 application.properties 이름 지정해주기 bootRun의 구성 편집   ⇒   실행 항목   ⇒   실행 창 : bootRun --args='--spring.profiles.active=dev’ JVM 아규먼트로 실행하기 dev 모드 실행 예시 river@BOOK-VKBCE9E5R0 MINGW64 ~/git/bitcamp-final/app/build/libs (backnback) $ cd ~/git/bitcamp-final river@BOOK-VKBCE9E5R0 MINGW64 ~/git/bitcamp-final (backnback) $ cd app/build/libs river@BOOK-VKBCE9E5R0 MINGW64 ~/git/bitcamp-final/app/build/libs (backnback) $ java -Dspring.profiles.active=dev -jar bitcamp-final.jar 프로그램 아규먼트로 실행하기 dev 모드 실행 예시 river@BOOK-VKBCE9E5R0 MINGW64 ~/git/bitcamp-final/app/build/libs (backnback) $ java -jar bitcamp-final.jar --spring.profiles.active=dev Gradle bootRun 실행 방법 루트 프로젝트로 이동 후 river@BOOK-VKBCE9E5R0 MINGW64 ~/git/bitcamp-final (backnback) $ gradle bootRun --args='spring.profiles.active=dev' (3) NCP 리눅스 서버 생성ACG 설정 console   ⇒   server   ⇒   ACG   ⇒   생성   ⇒   bitcamp-vpc-web-acg   (bitcamp-vpc 선택) Inbound 설정 TCP   :   접근 소스 (0.0.0.0/0) 허용 포트 (1-65535) UDP   :   접근 소스 (0.0.0.0/0) 허용 포트 (1-65535) ICMP   :   접근 소스 (0.0.0.0/0) Outbound 설정 TCP   :   목적지 (0.0.0.0/0) 허용 포트 (1-65535) UDP   :   목적지 (0.0.0.0/0) 허용 포트 (1-65535) ICMP   :   목적지 (0.0.0.0/0) 리눅스 서버 생성 console   ⇒   server   ⇒   생성 (기존 콘솔 화면)   ⇒   CentOS-7.8-64, High CPU bitcamp-vpc, bitcamp-vpc-web-subnet 10.0.1.0/24 High CPU(vCPU 2개, 4GB, 50GB, g2), 시간 요금제 서버 이름   :   bitcamp-svr-final network interface의 ip 입력   :   10.0.1.51   ⇒   새로운 공인 IP 할당 물리 배치 그룹 미사용 / 반납 보호 해제 인증키 이용 새로운 인증키 생성    (이름 예시 : bitcamp0524-95) 네트워크 접근 설정 (ACG) bitcamp-vpc-web-acg 서버 생성 SSH ( telnet(원격 접속) + 보안 ) ncp에서 만든 서버의 공인 IP를 복사하여 접속 서버 관리 및 설정 변경   ⇒   서버 창에서 관리자 비밀번호 확인 클릭 ⇒ 우리 인증키를 주면서 비밀번호 확인하기   ⇒   다시 git bash에서 비밀번호 넣기 river@BOOK-VKBCE9E5R0 MINGW64 ~/git/bitcamp-final (backnback) $ ssh root@211.188.48.5 The authenticity of host '211.188.48.5 (211.188.48.5)' can't be established. ED25519 key fingerprint is SHA256:bmFD/+yEZhyPRF/BE85yj9e2/Fd1vFpKP6B9kqjSZHo. This key is not known by any other names. Are you sure you want to continue connecting (yes/no/[fingerprint])? Please type 'yes', 'no' or the fingerprint: yes Warning: Permanently added '211.188.48.5' (ED25519) to the list of known hosts. root@211.188.48.5's password: [root@bitcamp-svr-final ~]# 관리자 모드는 #으로 시작한다.    (일반 사용자 : $) (3-1) 일반 사용자 생성student 유저 생성 # useradd student [root@bitcamp-svr-final ~]# useradd student [root@bitcamp-svr-final ~]# cd .. [root@bitcamp-svr-final ~]# ls bin dev home lib media opt root sbin sys usr boot etc home1 lib64 mnt proc run srv tmp var [root@bitcamp-svr-final /]# cd home [root@bitcamp-svr-final home]# ls student [root@bitcamp-svr-final home]# cd student [root@bitcamp-svr-final student]# ls [root@bitcamp-svr-final student]# ls -al total 12 drwx------ 2 student student 62 Nov 5 14:34 . drwxr-xr-x. 3 root root 21 Nov 5 14:34 .. -rw-r--r-- 1 student student 18 Apr 1 2020 .bash_logout -rw-r--r-- 1 student student 193 Apr 1 2020 .bash_profile -rw-r--r-- 1 student student 231 Apr 1 2020 .bashrc [root@bitcamp-svr-final student]# Unix Shell에서 sh(bourne shell)와 bash(bourne again shell)의 차이 bash는 sh의 상위 호환으로, 더 현대적이고 스크립팅에 유용한 기능을 많이 제공한다 [root@bitcamp-svr-final **student]# nano** 나가기   :   ctrl + x nano   :   텍스트 파일을 편집할 때 사용. cat   :   텍스트 파일의 내용을 출력하거나 여러 파일을 병합할 때 사용 [root@bitcamp-svr-final student]# cat .bash_profile # .bash_profile # Get the aliases and functions if [ -f ~/.bashrc ]; then . ~/.bashrc fi # User specific environment and startup programs PATH=$PATH:$HOME/.local/bin:$HOME/bin export PATH [root@bitcamp-svr-final student]# cat .bashrc # .bashrc # Source global definitions if [ -f /etc/bashrc ]; then . /etc/bashrc fi # Uncomment the following line if you don't like systemctl's auto-paging feature: # export SYSTEMD_PAGER= # User specific aliases and functions 보통 .bashrc는 손대지 않는다. 명령어 # cd   ⇒   현재 로그인한 디렉토리로 돌아가기 # whoami   ⇒   내가 누구야? root # pwd   ⇒   /root # exit   ⇒   아예 나가기 student 유저 비밀번호 생성 # passwd student [root@bitcamp-svr-final ~]# passwd student Changing password for user student. New password: Retype new password: passwd: all authentication tokens updated successfully. 서버에 student로 접속하기 ssh student@IP river@BOOK-VKBCE9E5R0 MINGW64 ~/git/bitcamp-final (backnback) $ ssh student@211.188.48.5 student@211.188.48.5's password: [student@bitcamp-svr-final ~]$ 가능한 일반 사용자로 접속해서 사용하자 !! (3-2) Root SSH 접속 제한하기root 사용자 로그인 불가하게 설정 (Root SSH 접속 제한하기) # nano /etc/ssh/sshd_config river@BOOK-VKBCE9E5R0 MINGW64 ~/git/bitcamp-final (backnback) $ ssh root@211.188.48.5 root@211.188.48.5's password: [root@bitcamp-svr-final ~]# cat /etc/ssh/sshd_config # $OpenBSD: sshd_config,v 1.100 2016/08/15 12:32:04 naddy Exp $ # This is the sshd server system-wide configuration file. See # sshd_config(5) for more information. # This sshd was compiled with PATH=/usr/local/bin:/usr/bin ... # Authentication: #LoginGraceTime 2m PermitRootLogin yes (이것을 찾는다) #StrictModes yes #MaxAuthTries 6 #MaxSessions 10 #PubkeyAuthentication yes # The default is to check both .ssh/authorized_keys and .ssh/authorized_keys2 # but this is overridden so installations will only check .ssh/authorized_keys AuthorizedKeysFile .ssh/authorized_keys #AuthorizedPrincipalsFile none ... PermitRootLogin yes 를 찾는다. PermitRootLogin yes    ⇒    PermitRootLogin no 로 수정 [root@bitcamp-svr1 ~]# nano /etc/ssh/sshd_config CTRL + O (저장)    ⇒    CTRL + X (나가기) 변경 사항 적용하기 [root@bitcamp-svr-final ~]# systemctl restart sshd.service ⇒   이제 직접 root로 로그인 할 수 없다. root 권한 요구 그러나 일반 사용자로 사용할 때 root 권한이 필요한 경우가 있다. river@BOOK-VKBCE9E5R0 MINGW64 ~/git/bitcamp-final (backnback) $ ssh student@211.188.48.5 student@211.188.48.5's password: [student@bitcamp-svr-final ~]$ yum update Loaded plugins: fastestmirror, langpacks You need to be root to perform this command. You need to be root to perform this command. ⇒   root 권한으로 수행하라고 한다. (3-3) visudo를 사용하여 일반 사용자에게 sudo 명령어 권한 주기root로 로그인 하지 않고 root 권한으로 실행하는 법 sudo   :   super user do yum   :   pakage manager $ sudo yum update   :   yum 서버의 최신 프로그램 목록 가져오기 river@BOOK-VKBCE9E5R0 MINGW64 ~/git/bitcamp-final (backnback) $ ssh student@211.188.48.5 student@211.188.48.5's password: [student@bitcamp-svr-final ~]$ sudo yum update We trust you have received the usual lecture from the local System Administrator. It usually boils down to these three things: #1) Respect the privacy of others. #2) Think before you type. #3) With great power comes great responsibility. [sudo] password for student: student is not in the sudoers file. This incident will be reported. visudo 사용하기 (저장할 때 문법 체크해주는 기능) 루트(Root)로 전환   ($ su) # visudo    (/etc/sudoerc 파일 편집) esc 누르고 a를 누르면 엔터를 입력할 수 있다. 맨 마지막 줄에 한 줄 띄우고 student ALL=(ALL:ALL) ALL 저장할 때 esc 누르고 : 이거 입력하고 wq 입력 $ exit로 student로 다시 돌아가기 [student@bitcamp-svr-final ~]$ sudo yum update We trust you have received the usual lecture from the local System Administrator. It usually boils down to these three things: #1) Respect the privacy of others. #2) Think before you type. #3) With great power comes great responsibility. [sudo] password for student: student is not in the sudoers file. This incident will be reported. [student@bitcamp-svr-final ~]$ su Password:ㅓ [root@bitcamp-svr-final student]# visudo [root@bitcamp-svr-final student]# exit exit [student@bitcamp-svr-final ~] 다시 $ sudo yum update 실행 [student@bitcamp-svr-final ~]$ sudo yum update [sudo] password for student: Loaded plugins: fastestmirror, langpacks Determining fastest mirrors .... .... (업데이트 실행 중) .... Complete! 커널은 업데이트 하면 안된다. (3-4) JDK를 설치 하기설치 확인하기 $ java -version [student@bitcamp-svr-final ~]$ java -version -bash: java: command not found [student@bitcamp-svr-final ~]$ sudo yum install java-21-openjdk [sudo] password for student: Loaded plugins: fastestmirror, langpacks Loading mirror speeds from cached hostfile No package java-21-openjdk available. Error: Nothing to do 설치가 안되어 있는 것을 확인할 수 있다. 설치 가능 리스트부터 확인하기 $ sudo yum list java*jdk-devel [student@bitcamp-svr-final ~]$ sudo yum list java*jdk-devel Loaded plugins: fastestmirror, langpacks Determining fastest mirrors Available Packages java-1.6.0-openjdk-devel.x86_64 1:1.6.0.41-1.13.13.1.el7_3 base java-1.7.0-openjdk-devel.x86_64 1:1.7.0.261-2.6.22.2.el7_8 base java-1.8.0-openjdk-devel.i686 1:1.8.0.412.b08-1.el7_9 update java-1.8.0-openjdk-devel.x86_64 1:1.8.0.412.b08-1.el7_9 update java-11-openjdk-devel.i686 1:11.0.23.0.9-2.el7_9 update java-11-openjdk-devel.x86_64 1:11.0.23.0.9-2.el7_9 update jdk-21이 없음 Zulu OpenJDK로 JDK 설치 $ sudo yum install -y https://cdn.azul.com/zulu/bin/zulu-repo-1.0.0-1.noarch.rpm ⇒ Azul의 Zulu JDK 패키지를 쉽게 설치할 수 있는 **환경 설정** ```haskell [student@bitcamp-svr-final ~]$ sudo yum install -y https://cdn.azul.com/zulu/bin/zulu-repo-1.0.0-1.noarch.rpm Loaded plugins: fastestmirror, langpacks zulu-repo-1.0.0-1.noarch.rpm | 3.0 kB 00:00 Examining /var/tmp/yum-root-6gw8Yd/zulu-repo-1.0.0-1.noarch.rpm: zulu-repo-1.0.0-1.noarch Marking /var/tmp/yum-root-6gw8Yd/zulu-repo-1.0.0-1.noarch.rpm to be installed Resolving Dependencies --&gt; Running transaction check ---&gt; Package zulu-repo.noarch 0:1.0.0-1 will be installed --&gt; Finished Dependency Resolution Dependencies Resolved ================================================================================ Package Arch Version Repository Size ================================================================================ Installing: zulu-repo noarch 1.0.0-1 /zulu-repo-1.0.0-1.noarch 0.0 Transaction Summary ================================================================================ Install 1 Package Installed size: 0 Downloading packages: Running transaction check Running transaction test Transaction test succeeded Running transaction Installing : zulu-repo-1.0.0-1.noarch 1/1 Verifying : zulu-repo-1.0.0-1.noarch 1/1 Installed: zulu-repo.noarch 0:1.0.0-1 Complete! ``` $ sudo yum install zulu21-jdk    (-y 명령어로 자동 yes 처리 가능) [student@bitcamp-svr-final ~]$ sudo yum install -y zulu21-jdk Loaded plugins: fastestmirror, langpacks Loading mirror speeds from cached hostfile * epel: repo.jing.rocks zulu-openjdk | 2.9 kB 00:00 zulu-openjdk/primary_db | 906 kB 00:00 Resolving Dependencies --&gt; .... --&gt; Finished Dependency Resolution Dependencies Resolved ... Installing:... Install 1 Package (+9 Dependent packages) Total download size: 132 M Installed size: 293 M Is this ok [y/d/N]: y Downloading packages: (1/10): .... Running transaction check Running transaction test Transaction test succeeded Running transaction Installing : ..... Installed: zulu21-jdk.x86_64 0:21.0.5-3 Dependency Installed: .... Complete! JDK 설치 확인 $ which javac   :   javac 실행 파일의 경로 출력 [student@bitcamp-svr-final ~]$ javac -version javac 21.0.5 [student@bitcamp-svr-final ~]$ which javac /usr/bin/javac [student@bitcamp-svr-final ~]$ ls -al /usr/bin/javac lrwxrwxrwx 1 root root 23 Nov 5 15:43 /usr/bin/javac -&gt; /etc/alternatives/javac [student@bitcamp-svr-final ~]$ echo $JAVA_HOME JAVA_HOME이 설정 안되어 있는 것을 확인할 수 있다. (3-5) JAVA_HOME 환경 변수 설정JAVA_HOME 설정하기 JAVA_HOME [student@bitcamp-svr-final ~]$ cd /usr/lib [student@bitcamp-svr-final lib]$ ls binfmt.d games locale python2.7 tmpfiles.d cpp gcc modprobe.d rpm tuned crda grub modules sendmail udev debug jvm modules-load.d sendmail.postfix yum-plugins dracut kbd NetworkManager sse2 firewalld kdump os-release sysctl.d firmware kernel polkit-1 systemd [student@bitcamp-svr-final lib]$ cd jvm [student@bitcamp-svr-final jvm]$ ls java-21-zulu-openjdk java-21-zulu-openjdk-ca jre zulu21 zulu21-ca [student@bitcamp-svr-final jvm]$ ls -al total 4 drwxr-xr-x 3 root root 107 Nov 5 15:43 . dr-xr-xr-x. 30 root root 4096 Nov 5 15:42 .. lrwxrwxrwx 1 root root 23 Nov 5 15:43 java-21-zulu-openjdk -&gt; java-21-zulu-openjdk-ca drwxr-xr-x 9 root root 163 Oct 16 19:18 java-21-zulu-openjdk-ca lrwxrwxrwx 1 root root 21 Nov 5 15:43 jre -&gt; /etc/alternatives/jre lrwxrwxrwx 1 root root 9 Nov 5 15:43 zulu21 -&gt; zulu21-ca lrwxrwxrwx 1 root root 36 Nov 5 15:43 zulu21-ca -&gt; /usr/lib/jvm/java-21-zulu-openjdk-ca [student@bitcamp-svr-final jvm]$ cd java-21-zulu-openjdk [student@bitcamp-svr-final java-21-zulu-openjdk]$ pwd /usr/lib/jvm/java-21-zulu-openjdk 출력된 결과(/usr/lib/jvm/java-21-zulu-openjdk)를 JAVA_HOME으로 잡는다. $ nano ~/.bash_profile 루트 경로로 이동 후 nano .bash_profile export JAVA_HOME=/usr/lib/jvm/java-21-zulu-openjdk [student@bitcamp-svr-final java-21-zulu-openjdk]$ cd [student@bitcamp-svr-final ~]$ nano .bash_profile ctrl + o (저장)   ⇒   enter   ⇒   ctrl + x (나가기) .bash_profile를 바꾸면 나갔다가 들어오거나 아래의 코드를 입력 해야 한다. [student@bitcamp-svr-final ~]$ source .bash_profile 환경변수 확인 $ echo $JAVA_HOME [student@bitcamp-svr-final ~]$ echo $JAVA_HOME /usr/lib/jvm/java-21-zulu-openjdk [student@bitcamp-svr-final ~]$ javac -version javac 21.0.5 [student@bitcamp-svr-final ~]$ java -version openjdk version \"21.0.5\" 2024-10-15 LTS OpenJDK Runtime Environment Zulu21.38+21-CA (build 21.0.5+11-LTS) OpenJDK 64-Bit Server VM Zulu21.38+21-CA (build 21.0.5+11-LTS, mixed mode, sharing) (3-6) 리눅스 서버에 프로젝트 폴더를 가져오기 (GIT CLONE)프로젝트 가져오기 사용자 홈폴더에서 [student@bitcamp-svr-final ~]$ mkdir git [student@bitcamp-svr-final ~]$ cd git [student@bitcamp-svr-final git]$ git clone https://github.com/backnback/bitcamp-final Cloning into 'bitcamp-final'... remote: Enumerating objects: 98, done. remote: Counting objects: 100% (98/98), done. remote: Compressing objects: 100% (71/71), done. remote: Total 98 (delta 15), reused 95 (delta 15), pack-reused 0 (from 0) Unpacking objects: 100% (98/98), done. gradle은 따로 설치할 필요 없다. $ ./gradlew build [student@bitcamp-svr-final git]$ cd bitcamp-final [student@bitcamp-svr-final bitcamp-final]$ ./gradlew build -bash: ./gradlew: Permission denied [student@bitcamp-svr-final bitcamp-final]$ chmod +x gradlew [student@bitcamp-svr-final bitcamp-final]$ ./gradlew build Downloading https://services.gradle.org/distributions/gradle-8.10.2-bin.zip .............10%.............20%.............30%.............40%.............50%.............60%.............70%.............80%.............90%.............100% Welcome to Gradle 8.10.2! Here are the highlights of this release: - Support for Java 23 - Faster configuration cache - Better configuration cache reports For more details see https://docs.gradle.org/8.10.2/release-notes.html Starting a Gradle Daemon (subsequent builds will be faster) BUILD SUCCESSFUL in 1m 25s 5 actionable tasks: 5 executed permission denied가 뜨는 경우 권한을 바꿔줘야 한다. (chmod) build 후 JAR 파일 실행 시 실행 안된다. ⇒ ncp.properties 파일이 서버에 존재하지 않기 때문에 실행할 수 없다. 우리의 경우는 final.properties와 email.properties (4) NCP 보안 파일 생성서버에 NCP 보안 파일 만들기 사용자 홈폴더에서 $ mkdir config $ cd config $ nano final.properties (로컬 파일의 내용 복사 후 붙여넣기) [student@bitcamp-svr-final bitcamp-final]$ cd [student@bitcamp-svr-final ~]$ mkdir config [student@bitcamp-svr-final ~]$ cd config [student@bitcamp-svr-final config]$ nano final.properties ctrl + o (저장)   ⇒   enter   ⇒   ctrl + x (나가기) email.properties도 같은 방법으로 처리 [student@bitcamp-svr-final config]$ nano email.properties ctrl + o (저장)   ⇒   enter   ⇒   ctrl + x (나가기) (5) 애플리케이션 배치 및 실행애플리케이션 배치 및 실행 Git 저장소를 가져와서 build 후 JAR 파일 실행 ~$ mkdir git ~$ cd git ~/git$ git clone https://github.com/backnbakc/bitcamp-final ~/git$ cd bitcamp-final ~/git/bitcamp-myapp$ ./gradlew build ~/git/bitcamp-myapp$ java -jar ./app/build/libs/bitcamp-final.jar 현재는 DB에 접속 포트가 허용되지 않아서 db의 데이터를 가져오지 못한다. (6) MySQL ACL에 접속 서버의 IP 등록NCP 콘솔에서 DB 허용 추가하기 서버   ⇒   acg   ⇒   mysql   ⇒   inbound 규칙 수정 (TCP : 211.188.48.5/32 , 허용 포트 : 1-65535) " } ]
